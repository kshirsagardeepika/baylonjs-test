"use strict";
(self["webpackChunksample1"] = self["webpackChunksample1"] || []).push([["vendors-node_modules_babylonjs_core_Shaders_ShadersInclude_bumpFragment_js-node_modules_babyl-f602c9"],{

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpFragment: () => (/* binding */ bumpFragment)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bumpFragment";
const shader = `vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bumpFragment = { name, shader };
//# sourceMappingURL=bumpFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpFragmentFunctions: () => (/* binding */ bumpFragmentFunctions)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
/* harmony import */ var _samplerFragmentDeclaration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./samplerFragmentDeclaration.js */ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js");
// Do not edit.


const name = "bumpFragmentFunctions";
const shader = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)
{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bumpFragmentFunctions = { name, shader };
//# sourceMappingURL=bumpFragmentFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpFragmentMainFunctions: () => (/* binding */ bumpFragmentMainFunctions)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bumpFragmentMainFunctions";
const shader = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#if defined(WEBGL2) || defined(WEBGPU)
mat4 toNormalMatrix(mat4 wMatrix)
{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}
#else
mat4 toNormalMatrix(mat4 m)
{float
a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],
a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],
a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],
a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],
b00=a00*a11-a01*a10,
b01=a00*a12-a02*a10,
b02=a00*a13-a03*a10,
b03=a01*a12-a02*a11,
b04=a01*a13-a03*a11,
b05=a02*a13-a03*a12,
b06=a20*a31-a21*a30,
b07=a20*a32-a22*a30,
b08=a20*a33-a23*a30,
b09=a21*a32-a22*a31,
b10=a21*a33-a23*a31,
b11=a22*a33-a23*a32,
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(
a11*b11-a12*b10+a13*b09,
a02*b10-a01*b11-a03*b09,
a31*b05-a32*b04+a33*b03,
a22*b04-a21*b05-a23*b03,
a12*b08-a10*b11-a13*b07,
a00*b11-a02*b08+a03*b07,
a32*b02-a30*b05-a33*b01,
a20*b05-a22*b02+a23*b01,
a10*b10-a11*b08+a13*b06,
a01*b08-a00*b10-a03*b06,
a30*b04-a31*b02+a33*b00,
a21*b02-a20*b04-a23*b00,
a11*b07-a10*b09-a12*b06,
a00*b09-a01*b07+a02*b06,
a31*b01-a30*b03-a32*b00,
a20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bumpFragmentMainFunctions = { name, shader };
//# sourceMappingURL=bumpFragmentMainFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragment.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragment.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decalFragment: () => (/* binding */ decalFragment)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "decalFragment";
const shader = `#ifdef DECAL
#ifdef GAMMADECAL
decalColor.rgb=toLinearSpace(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalColor.a*=decalColor.a;
#endif
surfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const decalFragment = { name, shader };
//# sourceMappingURL=decalFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragmentDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragmentDeclaration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decalFragmentDeclaration: () => (/* binding */ decalFragmentDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "decalFragmentDeclaration";
const shader = `#ifdef DECAL
uniform vec4 vDecalInfos;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const decalFragmentDeclaration = { name, shader };
//# sourceMappingURL=decalFragmentDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   depthPrePass: () => (/* binding */ depthPrePass)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "depthPrePass";
const shader = `#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);return;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const depthPrePass = { name, shader };
//# sourceMappingURL=depthPrePass.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   imageProcessingDeclaration: () => (/* binding */ imageProcessingDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "imageProcessingDeclaration";
const shader = `#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const imageProcessingDeclaration = { name, shader };
//# sourceMappingURL=imageProcessingDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   imageProcessingFunctions: () => (/* binding */ imageProcessingFunctions)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "imageProcessingFunctions";
const shader = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;}
#endif
#if TONEMAPPING==3
const float PBRNeutralStartCompression=0.8-0.04;const float PBRNeutralDesaturation=0.15;vec3 PBRNeutralToneMapping( vec3 color ) {float x=min(color.r,min(color.g,color.b));float offset=x<0.08 ? x-6.25*x*x : 0.04;color-=offset;float peak=max(color.r,max(color.g,color.b));if (peak<PBRNeutralStartCompression) return color;float d=1.-PBRNeutralStartCompression;float newPeak=1.-d*d/(peak+d-PBRNeutralStartCompression);color*=newPeak/peak;float g=1.-1./(PBRNeutralDesaturation*(peak-newPeak)+1.);return mix(color,newPeak*vec3(1,1,1),g);}
#endif
#if TONEMAPPING==2
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);vec3 RRTAndODTFit(vec3 v)
{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
vec3 ACESFitted(vec3 color)
{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#if TONEMAPPING==3
result.rgb=PBRNeutralToneMapping(result.rgb);
#elif TONEMAPPING==2
result.rgb=ACESFitted(result.rgb);
#elif TONEMAPPING==1
const float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
result.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;}`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const imageProcessingFunctions = { name, shader };
//# sourceMappingURL=imageProcessingFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightFragment: () => (/* binding */ lightFragment)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "lightFragment";
const shader = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,vPositionW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,vPositionW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightTexture{X},textureProjectionMatrix{X},vPositionW);
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const lightFragment = { name, shader };
//# sourceMappingURL=lightFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightFragmentDeclaration: () => (/* binding */ lightFragmentDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "lightFragmentDeclaration";
const shader = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowTexture{X};uniform highp sampler2DArray depthTexture{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowTexture{X};
#else
uniform highp sampler2DArray shadowTexture{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowTexture{X};
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowTexture{X};uniform highp sampler2D depthTexture{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowTexture{X};
#else
uniform sampler2D shadowTexture{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightTexture{X};
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const lightFragmentDeclaration = { name, shader };
//# sourceMappingURL=lightFragmentDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightUboDeclaration: () => (/* binding */ lightUboDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "lightUboDeclaration";
const shader = `#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightTexture{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowTexture{X};uniform highp sampler2DArray depthTexture{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowTexture{X};
#else
uniform highp sampler2DArray shadowTexture{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowTexture{X}; 
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowTexture{X};uniform highp sampler2D depthTexture{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowTexture{X};
#else
uniform sampler2D shadowTexture{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const lightUboDeclaration = { name, shader };
//# sourceMappingURL=lightUboDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mainUVVaryingDeclaration: () => (/* binding */ mainUVVaryingDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "mainUVVaryingDeclaration";
const shader = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const mainUVVaryingDeclaration = { name, shader };
//# sourceMappingURL=mainUVVaryingDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   oitDeclaration: () => (/* binding */ oitDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "oitDeclaration";
const shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const oitDeclaration = { name, shader };
//# sourceMappingURL=oitDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   oitFragment: () => (/* binding */ oitFragment)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "oitFragment";
const shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);return;}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const oitFragment = { name, shader };
//# sourceMappingURL=oitFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prePassDeclaration: () => (/* binding */ prePassDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "prePassDeclaration";
const shader = `#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const prePassDeclaration = { name, shader };
//# sourceMappingURL=prePassDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionFunction: () => (/* binding */ reflectionFunction)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "reflectionFunction";
const shader = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*(view*worldPos));}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*vec4(positionW,1.));}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const reflectionFunction = { name, shader };
//# sourceMappingURL=reflectionFunction.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   samplerFragmentDeclaration: () => (/* binding */ samplerFragmentDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "samplerFragmentDeclaration";
const shader = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const samplerFragmentDeclaration = { name, shader };
//# sourceMappingURL=samplerFragmentDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shadowsFragmentFunctions: () => (/* binding */ shadowsFragmentFunctions)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "shadowsFragmentFunctions";
const shader = `#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
#define inline
float computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);}
#define inline
float computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
#define inline
float computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
#define DISABLE_UNIFORMITY_ANALYSIS
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.)
);const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}
else
{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
if (numBlocker<1.0) {return 1.0;}
else
{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const shadowsFragmentFunctions = { name, shader };
//# sourceMappingURL=shadowsFragmentFunctions.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfU2hhZGVyc19TaGFkZXJzSW5jbHVkZV9idW1wRnJhZ21lbnRfanMtbm9kZV9tb2R1bGVzX2JhYnlsLWY2MDJjOS5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsMkNBQTJDLDBFQUEwRTtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsZ0NBQWdDLDhCQUE4QixrQ0FBa0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLHVCQUF1QjtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUMyRDtBQUNsQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQix5QkFBeUIsNEZBQTRGLHlEQUF5RCw2QkFBNkIsMENBQTBDLHlDQUF5QyxrRkFBa0YsOEJBQThCLHdCQUF3QiwyQkFBMkIsMkJBQTJCLDRCQUE0Qiw0QkFBNEIsc0JBQXNCLGNBQWMsZUFBZTtBQUM1bkIsQ0FBQyxnRUFBZ0U7QUFDakU7QUFDQTtBQUNBLENBQUMsNkNBQTZDLHdEQUF3RCxtQ0FBbUMseURBQXlEO0FBQ2xNO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyxnQ0FBZ0M7QUFDdkM7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQixtQkFBbUIsYUFBYSxhQUFhLGFBQWEseUJBQXlCO0FBQzlHO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsaUJBQWlCLGlCQUFpQixtQkFBbUIsbUJBQW1CLCtCQUErQiwrQkFBK0IsMkNBQTJDLDZDQUE2Qyw4QkFBOEIsZ0NBQWdDLDZEQUE2RCwrQ0FBK0M7QUFDelk7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLG9DQUFvQztBQUMzQzs7Ozs7Ozs7Ozs7Ozs7O0FDckVBO0FBQzJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyx3QkFBd0I7QUFDL0I7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBVztBQUNYO0FBQ08sbUNBQW1DO0FBQzFDOzs7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyx1QkFBdUI7QUFDOUI7Ozs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQzJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLHVDQUF1QyxzQ0FBc0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyxxQ0FBcUM7QUFDNUM7Ozs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtDQUFrQywwQkFBMEIsbURBQW1ELHFCQUFxQiwwQkFBMEIsbURBQW1EO0FBQ3RPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsd0NBQXdDLDBDQUEwQywwQ0FBMEMsd0NBQXdDLGNBQWMsNkNBQTZDLGtEQUFrRCxzQ0FBc0MseURBQXlELG9CQUFvQix5REFBeUQ7QUFDN2U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDLG1DQUFtQyx5Q0FBeUM7QUFDN0U7QUFDQSxDQUFDLHlCQUF5QiwwQkFBMEIsMEJBQTBCLHNCQUFzQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhCQUE4QixnRkFBZ0YsZ0RBQWdELHFEQUFxRDtBQUN0UTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLG9DQUFvQztBQUNwQztBQUNBLG1FQUFtRSxtQkFBbUIsd0RBQXdELE1BQU07QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwRUFBMEUsbUhBQW1ILDJCQUEyQjtBQUM1UDtBQUNBO0FBQ0EsdURBQXVELHdEQUF3RDtBQUMvRztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLG1DQUFtQztBQUMxQzs7Ozs7Ozs7Ozs7Ozs7O0FDL0ZBO0FBQzJEO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCLHlFQUF5RSxFQUFFLGdDQUFnQyxFQUFFO0FBQzdHO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaURBQWlELEVBQUU7QUFDbkQseUJBQXlCLEVBQUU7QUFDM0IsaURBQWlELEVBQUU7QUFDbkQsd0JBQXdCLEVBQUU7QUFDMUIsZ0RBQWdELEVBQUU7QUFDbEQsdUJBQXVCLEVBQUU7QUFDekIsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUIsd0ZBQXdGLEVBQUUsa0JBQWtCLCtEQUErRCxFQUFFLHFDQUFxQyxFQUFFLHVCQUF1QixFQUFFO0FBQzdPLHFDQUFxQyxFQUFFO0FBQ3ZDLHVGQUF1RixtRUFBbUUsRUFBRSxxQ0FBcUMsRUFBRTtBQUNuTSxxQ0FBcUMsRUFBRTtBQUN2QyxtRkFBbUYsRUFBRSxrQkFBa0IsbUVBQW1FLEVBQUUscUNBQXFDLEVBQUUseUJBQXlCLEVBQUU7QUFDOU87QUFDQSx1R0FBdUcsRUFBRSx1QkFBdUIsRUFBRSxrQkFBa0IsMERBQTBELEVBQUUscUNBQXFDLEVBQUUseUJBQXlCLEVBQUUsb0JBQW9CLEVBQUUsdUJBQXVCLEVBQUU7QUFDalU7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQiwwQkFBMEI7QUFDMUIsd0ZBQXdGLEVBQUU7QUFDMUYscUNBQXFDLEVBQUU7QUFDdkM7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QyxtRkFBbUYsRUFBRTtBQUNyRjtBQUNBLHVHQUF1RyxFQUFFLHVCQUF1QixFQUFFO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2REFBNkQsRUFBRSx5QkFBeUIsRUFBRTtBQUMxRjtBQUNBLGdFQUFnRSxFQUFFO0FBQ2xFO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EscVFBQXFRLEVBQUU7QUFDdlE7QUFDQSwySUFBMkksRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1GQUFtRixFQUFFO0FBQ3JGO0FBQ0E7QUFDQSxzSEFBc0gsRUFBRTtBQUN4SDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyRkFBMkYsRUFBRTtBQUM3RjtBQUNBLCtKQUErSixFQUFFO0FBQ2pLO0FBQ0Esc05BQXNOO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNEQUFzRCxFQUFFLGtCQUFrQixFQUFFLHVCQUF1QixFQUFFLHlCQUF5QixFQUFFLDBCQUEwQixFQUFFO0FBQzVKLHdCQUF3QixFQUFFO0FBQzFCLDZEQUE2RCxFQUFFLGtCQUFrQixFQUFFLHlCQUF5QixFQUFFLDBCQUEwQixFQUFFO0FBQzFJLHlCQUF5QixFQUFFLHNCQUFzQixFQUFFO0FBQ25ELGtEQUFrRCxFQUFFLGtCQUFrQixFQUFFLHlCQUF5QixFQUFFLDBCQUEwQixFQUFFO0FBQy9IO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkVBQTZFLEVBQUUseUJBQXlCLEVBQUU7QUFDMUc7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsY0FBYyx3QkFBd0IsSUFBSTtBQUMxQztBQUNBLDZCQUE2QjtBQUM3QixLQUFLLEVBQUUsY0FBYyxFQUFFLHdCQUF3QixFQUFFO0FBQ2pEO0FBQ0EsS0FBSyxFQUFFLGNBQWMsRUFBRSx3QkFBd0IsRUFBRTtBQUNqRDtBQUNBLFNBQVMsRUFBRSxPQUFPLE1BQU0sRUFBRSxHQUFHO0FBQzdCLDhCQUE4QjtBQUM5QixVQUFVLEVBQUU7QUFDWjtBQUNBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEIsNkJBQTZCLEVBQUU7QUFDL0IsNENBQTRDLEVBQUUscUJBQXFCLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFO0FBQzFKLGtDQUFrQyxFQUFFO0FBQ3BDLDRDQUE0QyxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRTtBQUNsTDtBQUNBLDRDQUE0QyxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRTtBQUNsTDtBQUNBLHlCQUF5QixFQUFFO0FBQzNCLDZCQUE2QixFQUFFO0FBQy9CLDhDQUE4QyxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLHFDQUFxQyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUU7QUFDNVQsa0NBQWtDLEVBQUU7QUFDcEMsOENBQThDLEVBQUUscUJBQXFCLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUNBQXFDLEVBQUUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRTtBQUM1VDtBQUNBLDhDQUE4QyxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLHFDQUFxQyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUU7QUFDNVQ7QUFDQTtBQUNBLG9DQUFvQyxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRTtBQUNsSjtBQUNBLHNCQUFzQjtBQUN0QixZQUFZLEVBQUUsdUNBQXVDLEVBQUUsT0FBTyxFQUFFO0FBQ2hFO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQyxFQUFFLE9BQU8sRUFBRSxFQUFFLDJCQUEyQixFQUFFLHlDQUF5QyxHQUFHLFVBQVUsRUFBRSx3QkFBd0IsRUFBRTtBQUMvSixDQUFDLE1BQU0sRUFBRSxJQUFJO0FBQ2Isc0JBQXNCLEVBQUU7QUFDeEIsNkJBQTZCLEVBQUU7QUFDL0IsZ0RBQWdELEVBQUUscUJBQXFCLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFO0FBQzlKLGtDQUFrQyxFQUFFO0FBQ3BDLGdEQUFnRCxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRTtBQUN0TDtBQUNBLGdEQUFnRCxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRTtBQUN0TDtBQUNBLHlCQUF5QixFQUFFO0FBQzNCLDZCQUE2QixFQUFFO0FBQy9CLGtEQUFrRCxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLHFDQUFxQyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUU7QUFDaFUsa0NBQWtDLEVBQUU7QUFDcEMsa0RBQWtELEVBQUUscUJBQXFCLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUNBQXFDLEVBQUUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRTtBQUNoVTtBQUNBLGtEQUFrRCxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLHFDQUFxQyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUU7QUFDaFU7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLHFCQUFxQixFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRTtBQUN0SjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFlBQVksRUFBRSwrQ0FBK0MsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0IsdUJBQXVCLEVBQUU7QUFDekIsc0RBQXNELEVBQUUsOEJBQThCLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFO0FBQy9JO0FBQ0Esb0RBQW9ELEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUU7QUFDOUk7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQix1QkFBdUIsRUFBRTtBQUN6QixpREFBaUQsRUFBRSw4QkFBOEIsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUU7QUFDMUk7QUFDQSwrQ0FBK0MsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRTtBQUN6STtBQUNBLDRCQUE0QixFQUFFO0FBQzlCLHVCQUF1QixFQUFFO0FBQ3pCLDZEQUE2RCxFQUFFLDhCQUE4QixFQUFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRTtBQUN0SjtBQUNBLDJEQUEyRCxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFO0FBQ3JKO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUIsNkJBQTZCLEVBQUU7QUFDL0IsZ0RBQWdELEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUU7QUFDbkgsa0NBQWtDLEVBQUU7QUFDcEMsZ0RBQWdELEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUU7QUFDM0k7QUFDQSxnREFBZ0QsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRTtBQUMzSTtBQUNBLHlCQUF5QixFQUFFO0FBQzNCLDZCQUE2QixFQUFFO0FBQy9CLGtEQUFrRCxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRTtBQUNuTCxrQ0FBa0MsRUFBRTtBQUNwQyxrREFBa0QsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUU7QUFDbkw7QUFDQSxrREFBa0QsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUU7QUFDbkw7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCLDBDQUEwQyxFQUFFLDhCQUE4QixFQUFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRTtBQUM1RztBQUNBLHdDQUF3QyxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLHdCQUF3QjtBQUMvQjs7Ozs7Ozs7Ozs7Ozs7O0FDOVFBO0FBQzJEO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCLHdCQUF3QixHQUFHLDJCQUEyQjtBQUN0RDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0EsY0FBYztBQUNkLGlCQUFpQjtBQUNqQix5QkFBeUIsRUFBRSx1QkFBdUIsRUFBRSxFQUFFLDJCQUEyQixFQUFFLHVCQUF1QixFQUFFLEVBQUUsNkJBQTZCLEVBQUUsdUJBQXVCLEVBQUUsRUFBRSxpQ0FBaUMsR0FBRyxnQ0FBZ0MsRUFBRSx1QkFBdUIsRUFBRSxFQUFFLDJCQUEyQixFQUFFLHVCQUF1QixFQUFFLEVBQUUsaUNBQWlDO0FBQ2xXLHVCQUF1QixFQUFFO0FBQ3pCLGlEQUFpRCxHQUFHLDBDQUEwQyxHQUFHLG1DQUFtQyxFQUFFLHVCQUF1QixFQUFFLEVBQUUsOEJBQThCLEVBQUUsdUJBQXVCLEVBQUUsRUFBRSwrQkFBK0I7QUFDM1Asd0JBQXdCLEVBQUU7QUFDMUIsaURBQWlEO0FBQ2pEO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsaUJBQWlCO0FBQ25CO0FBQ0EsOEJBQThCO0FBQzlCLFVBQVUsRUFBRTtBQUNaO0FBQ0EsVUFBVSxFQUFFLHVCQUF1QixFQUFFO0FBQ3JDO0FBQ0EsV0FBVyxFQUFFO0FBQ2IseUJBQXlCLEVBQUU7QUFDM0Isa0NBQWtDO0FBQ2xDO0FBQ0EsZ0NBQWdDLEdBQUcsMkJBQTJCO0FBQzlELHVCQUF1QixFQUFFO0FBQ3pCLDRDQUE0QyxHQUFHLHFDQUFxQztBQUNwRix3QkFBd0IsRUFBRTtBQUMxQiw0Q0FBNEM7QUFDNUM7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDckQ7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCLEdBQUcsMkJBQTJCO0FBQzNELHlCQUF5QixFQUFFO0FBQzNCLDJCQUEyQjtBQUMzQix3QkFBd0IsRUFBRTtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQSw2QkFBNkI7QUFDN0IscUNBQXFDLEdBQUcseUNBQXlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLG1DQUFtQztBQUMxQzs7Ozs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQzJEO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCLGNBQWM7QUFDZCxDQUFDLGdCQUFnQixtQkFBbUI7QUFDcEMsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQix5QkFBeUIsRUFBRTtBQUMzQjtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CLE1BQU07QUFDMUMsNkJBQTZCO0FBQzdCLHFDQUFxQyxHQUFHLHlDQUF5QztBQUNqRjtBQUNBLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIseUJBQXlCLEVBQUUsdUJBQXVCLEVBQUUsRUFBRSwyQkFBMkIsRUFBRSx1QkFBdUIsRUFBRSxFQUFFLDZCQUE2QixFQUFFLHVCQUF1QixFQUFFLEVBQUUsaUNBQWlDLEdBQUcsZ0NBQWdDLEVBQUUsdUJBQXVCLEVBQUUsRUFBRSwyQkFBMkIsRUFBRSx1QkFBdUIsRUFBRSxFQUFFLGlDQUFpQztBQUNsVyx1QkFBdUIsRUFBRTtBQUN6QixpREFBaUQsR0FBRywwQ0FBMEMsR0FBRyxtQ0FBbUMsRUFBRSx1QkFBdUIsRUFBRSxFQUFFLDhCQUE4QixFQUFFLHVCQUF1QixFQUFFLEVBQUUsK0JBQStCO0FBQzNQLHdCQUF3QixFQUFFO0FBQzFCLGlEQUFpRDtBQUNqRDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGlCQUFpQjtBQUNuQjtBQUNBLDhCQUE4QjtBQUM5QixVQUFVLEVBQUU7QUFDWjtBQUNBLFVBQVUsRUFBRSx1QkFBdUIsRUFBRTtBQUNyQztBQUNBLFdBQVcsRUFBRTtBQUNiLHlCQUF5QixFQUFFO0FBQzNCLGtDQUFrQztBQUNsQztBQUNBLGdDQUFnQyxHQUFHLDJCQUEyQjtBQUM5RCx1QkFBdUIsRUFBRTtBQUN6Qiw0Q0FBNEMsR0FBRyxxQ0FBcUM7QUFDcEYsd0JBQXdCLEVBQUU7QUFDMUIsNENBQTRDO0FBQzVDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBVztBQUNYO0FBQ08sOEJBQThCO0FBQ3JDOzs7Ozs7Ozs7Ozs7Ozs7QUNsRUE7QUFDMkQ7QUFDM0Q7QUFDQSw4QkFBOEI7QUFDOUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyxtQ0FBbUM7QUFDMUM7Ozs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQzJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxnRUFBVztBQUNYO0FBQ08seUJBQXlCO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvQ0FBb0M7QUFDakY7QUFDQSx1Q0FBdUMsMERBQTBELGlFQUFpRSwwQkFBMEIsMEJBQTBCO0FBQ3ROO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyxzQkFBc0I7QUFDN0I7Ozs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRSxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLDZCQUE2QjtBQUNwQzs7Ozs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQzJEO0FBQzNEO0FBQ0E7QUFDQSxDQUFDLHdDQUF3Qyw0QkFBNEIsbURBQW1ELCtCQUErQix1QkFBdUI7QUFDOUs7QUFDQSxDQUFDLHdDQUF3Qyw0QkFBNEIsbURBQW1ELCtCQUErQix1QkFBdUI7QUFDOUs7QUFDQSxDQUFDLHdEQUF3RCxzREFBc0QsbUNBQW1DLHdCQUF3QixvQkFBb0IsbURBQW1ELCtCQUErQix1QkFBdUI7QUFDdlM7QUFDQSxDQUFDLDRDQUE0Qyw0REFBNEQsbUNBQW1DLG1DQUFtQyxZQUFZLHNCQUFzQjtBQUNqTjtBQUNBLENBQUMsc0NBQXNDLG9EQUFvRDtBQUMzRjtBQUNBLENBQUMsaURBQWlELHlDQUF5QztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpREFBaUQseUNBQXlDLG9GQUFvRjtBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLDZCQUE2QjtBQUNwQzs7Ozs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQzJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyxxQ0FBcUM7QUFDNUM7Ozs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1GQUFtRjtBQUNwRjtBQUNBO0FBQ0EsQ0FBQywrRkFBK0Y7QUFDaEc7QUFDQTtBQUNBLENBQUMsNkNBQTZDLHFDQUFxQyw0Q0FBNEMsMEJBQTBCLDZDQUE2QztBQUN0TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2Q0FBNkMscUNBQXFDLDRDQUE0QywwQkFBMEIsNkNBQTZDLHVDQUF1QyxvQkFBb0Isb0JBQW9CLG1DQUFtQyxtQ0FBbUMsb0NBQW9DO0FBQy9YO0FBQ0EsdUdBQXVHLHVHQUF1Ryx1R0FBdUc7QUFDclQ7QUFDQSxpR0FBaUcsaUdBQWlHLGlHQUFpRztBQUNuUztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkNBQTZDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLDZDQUE2QztBQUN2TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQSxDQUFDLDZDQUE2QyxxQ0FBcUMsNENBQTRDLDJDQUEyQyw2Q0FBNkM7QUFDdk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJEQUEyRCxtQ0FBbUMsbUNBQW1DO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkRBQTJELG1DQUFtQztBQUMvRixDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkRBQTJELG1DQUFtQztBQUMvRixDQUFDO0FBQ0Q7QUFDQSxDQUFDLGlEQUFpRCxvQkFBb0Isb0JBQW9CLDZDQUE2Qyw0Q0FBNEMsOENBQThDO0FBQ2pPO0FBQ0EsdUdBQXVHLHVHQUF1Ryx1R0FBdUc7QUFDclQ7QUFDQSxpR0FBaUcsaUdBQWlHLGlHQUFpRztBQUNuUztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkRBQTJELG1DQUFtQztBQUMvRixDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0EsQ0FBQywyREFBMkQsbUNBQW1DO0FBQy9GLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyREFBMkQsK0NBQStDLG1EQUFtRCw0REFBNEQsbURBQW1ELCtCQUErQjtBQUM1UztBQUNBO0FBQ0EsQ0FBQywyREFBMkQsK0NBQStDLG1EQUFtRDtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUIsMEVBQTBFLDBFQUEwRSxnQkFBZ0IsZ0dBQWdHLGdHQUFnRyxnR0FBZ0csZ0dBQWdHLGtCQUFrQiwrQkFBK0I7QUFDM25CO0FBQ0E7QUFDQSxDQUFDLDJEQUEyRCwrQ0FBK0MsbURBQW1EO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQixtQkFBbUIsOEZBQThGLDhGQUE4RixnQkFBZ0IsZ0dBQWdHLGdHQUFnRyxnR0FBZ0csZ0dBQWdHLGdHQUFnRyxnR0FBZ0csZ0dBQWdHLGdHQUFnRyxnR0FBZ0csbUJBQW1CLCtCQUErQjtBQUN2cEM7QUFDQTtBQUNBLENBQUMseUNBQXlDO0FBQzFDO0FBQ0EsQ0FBQywyREFBMkQsK0NBQStDLGtCQUFrQixtREFBbUQsK0JBQStCO0FBQy9NO0FBQ0E7QUFDQSxDQUFDLHlDQUF5QztBQUMxQztBQUNBLENBQUMsMkRBQTJELCtDQUErQyxrQkFBa0I7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CLDBFQUEwRSwwRUFBMEUsZ0JBQWdCLCtGQUErRiwrRkFBK0YsK0ZBQStGLCtGQUErRixrQkFBa0IsK0JBQStCO0FBQ3ZuQjtBQUNBO0FBQ0EsQ0FBQyx5Q0FBeUM7QUFDMUM7QUFDQSxDQUFDLDJEQUEyRCwrQ0FBK0Msa0JBQWtCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQixtQkFBbUIsOEZBQThGLDhGQUE4RixnQkFBZ0IsK0ZBQStGLCtGQUErRiwrRkFBK0YsK0ZBQStGLCtGQUErRiwrRkFBK0YsK0ZBQStGLCtGQUErRiwrRkFBK0YsbUJBQW1CLCtCQUErQjtBQUM5b0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkRBQTJELCtDQUErQyxtREFBbUQsNERBQTRELHVCQUF1QiwwQkFBMEIscUJBQXFCLGNBQWMsa0JBQWtCLE9BQU8sK0lBQStJLCtCQUErQiw4QkFBOEI7QUFDbmhCLGlEQUFpRCx3Q0FBd0MsNkVBQTZFLG1HQUFtRyw0Q0FBNEMscUNBQXFDLGdFQUFnRSxnQkFBZ0IsY0FBYyxlQUFlLE1BQU0sd0NBQXdDLDJIQUEySDtBQUNobkIsMkJBQTJCLDZGQUE2RiwrQkFBK0IscUJBQXFCO0FBQzVLO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLHlDQUF5QztBQUMxQztBQUNBLENBQUMsMkRBQTJELCtDQUErQyxrQkFBa0IsdUJBQXVCLDBCQUEwQixxQkFBcUIsY0FBYyxrQkFBa0IsT0FBTyxrSEFBa0gsK0JBQStCLDhCQUE4QjtBQUN6WixxQkFBcUI7QUFDckI7QUFDQSxDQUFDLGlEQUFpRCx3Q0FBd0MsNkRBQTZELGtFQUFrRSw0Q0FBNEMscUNBQXFDLGdFQUFnRSxnQkFBZ0IsY0FBYyxlQUFlLE1BQU0sK0JBQStCLHdIQUF3SDtBQUNwakIsMkJBQTJCLGtEQUFrRCwrQkFBK0I7QUFDNUc7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBVztBQUNYO0FBQ08sbUNBQW1DO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9idW1wRnJhZ21lbnQuanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9idW1wRnJhZ21lbnRGdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9idW1wRnJhZ21lbnRNYWluRnVuY3Rpb25zLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvZGVjYWxGcmFnbWVudC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL2RlY2FsRnJhZ21lbnREZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL2RlcHRoUHJlUGFzcy5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL2ltYWdlUHJvY2Vzc2luZ0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvaW1hZ2VQcm9jZXNzaW5nRnVuY3Rpb25zLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvbGlnaHRGcmFnbWVudC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL2xpZ2h0RnJhZ21lbnREZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL2xpZ2h0VWJvRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9tYWluVVZWYXJ5aW5nRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9vaXREZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL29pdEZyYWdtZW50LmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvcHJlUGFzc0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvcmVmbGVjdGlvbkZ1bmN0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvc2FtcGxlckZyYWdtZW50RGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9zaGFkb3dzRnJhZ21lbnRGdW5jdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJidW1wRnJhZ21lbnRcIjtcbmNvbnN0IHNoYWRlciA9IGB2ZWMyIHV2T2Zmc2V0PXZlYzIoMC4wLDAuMCk7XG4jaWYgZGVmaW5lZChCVU1QKSB8fCBkZWZpbmVkKFBBUkFMTEFYKSB8fCBkZWZpbmVkKERFVEFJTClcbiNpZmRlZiBOT1JNQUxYWVNDQUxFXG5mbG9hdCBub3JtYWxTY2FsZT0xLjA7XG4jZWxpZiBkZWZpbmVkKEJVTVApXG5mbG9hdCBub3JtYWxTY2FsZT12QnVtcEluZm9zLnk7XG4jZWxzZVxuZmxvYXQgbm9ybWFsU2NhbGU9MS4wO1xuI2VuZGlmXG4jaWYgZGVmaW5lZChUQU5HRU5UKSAmJiBkZWZpbmVkKE5PUk1BTClcbm1hdDMgVEJOPXZUQk47XG4jZWxpZiBkZWZpbmVkKEJVTVApXG52ZWMyIFRCTlVWPWdsX0Zyb250RmFjaW5nID8gdkJ1bXBVViA6IC12QnVtcFVWO21hdDMgVEJOPWNvdGFuZ2VudF9mcmFtZShub3JtYWxXKm5vcm1hbFNjYWxlLHZQb3NpdGlvblcsVEJOVVYsdlRhbmdlbnRTcGFjZVBhcmFtcyk7XG4jZWxzZVxudmVjMiBUQk5VVj1nbF9Gcm9udEZhY2luZyA/IHZEZXRhaWxVViA6IC12RGV0YWlsVVY7bWF0MyBUQk49Y290YW5nZW50X2ZyYW1lKG5vcm1hbFcqbm9ybWFsU2NhbGUsdlBvc2l0aW9uVyxUQk5VVix2ZWMyKDEuLDEuKSk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoQU5JU09UUk9QSUMpXG4jaWYgZGVmaW5lZChUQU5HRU5UKSAmJiBkZWZpbmVkKE5PUk1BTClcbm1hdDMgVEJOPXZUQk47XG4jZWxzZVxudmVjMiBUQk5VVj1nbF9Gcm9udEZhY2luZyA/IHZNYWluVVYxIDogLXZNYWluVVYxO21hdDMgVEJOPWNvdGFuZ2VudF9mcmFtZShub3JtYWxXLHZQb3NpdGlvblcsVEJOVVYsdmVjMigxLiwxLikpO1xuI2VuZGlmXG4jZW5kaWZcbiNpZmRlZiBQQVJBTExBWFxubWF0MyBpbnZUQk49dHJhbnNwb3NlTWF0MyhUQk4pO1xuI2lmZGVmIFBBUkFMTEFYT0NDTFVTSU9OXG51dk9mZnNldD1wYXJhbGxheE9jY2x1c2lvbihpbnZUQk4qLXZpZXdEaXJlY3Rpb25XLGludlRCTipub3JtYWxXLHZCdW1wVVYsdkJ1bXBJbmZvcy56KTtcbiNlbHNlXG51dk9mZnNldD1wYXJhbGxheE9mZnNldChpbnZUQk4qdmlld0RpcmVjdGlvblcsdkJ1bXBJbmZvcy56KTtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgREVUQUlMXG52ZWM0IGRldGFpbENvbG9yPXRleHR1cmUyRChkZXRhaWxTYW1wbGVyLHZEZXRhaWxVVit1dk9mZnNldCk7dmVjMiBkZXRhaWxOb3JtYWxSRz1kZXRhaWxDb2xvci53eSoyLjAtMS4wO2Zsb2F0IGRldGFpbE5vcm1hbEI9c3FydCgxLi1zYXR1cmF0ZShkb3QoZGV0YWlsTm9ybWFsUkcsZGV0YWlsTm9ybWFsUkcpKSk7dmVjMyBkZXRhaWxOb3JtYWw9dmVjMyhkZXRhaWxOb3JtYWxSRyxkZXRhaWxOb3JtYWxCKTtcbiNlbmRpZlxuI2lmZGVmIEJVTVBcbiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcbiNkZWZpbmUgQ1VTVE9NX0ZSQUdNRU5UX0JVTVBfRlJBR01FTlRcbm5vcm1hbFc9bm9ybWFsaXplKHRleHR1cmUyRChidW1wU2FtcGxlcix2QnVtcFVWKS54eXogKjIuMC0xLjApO25vcm1hbFc9bm9ybWFsaXplKG1hdDMobm9ybWFsTWF0cml4KSpub3JtYWxXKTtcbiNlbGlmICFkZWZpbmVkKERFVEFJTClcbm5vcm1hbFc9cGVydHVyYk5vcm1hbChUQk4sdGV4dHVyZTJEKGJ1bXBTYW1wbGVyLHZCdW1wVVYrdXZPZmZzZXQpLnh5eix2QnVtcEluZm9zLnkpO1xuI2Vsc2VcbnZlYzMgYnVtcE5vcm1hbD10ZXh0dXJlMkQoYnVtcFNhbXBsZXIsdkJ1bXBVVit1dk9mZnNldCkueHl6KjIuMC0xLjA7XG4jaWYgREVUQUlMX05PUk1BTEJMRU5ETUVUSE9EPT0wIFxuZGV0YWlsTm9ybWFsLnh5Kj12RGV0YWlsSW5mb3Muejt2ZWMzIGJsZW5kZWROb3JtYWw9bm9ybWFsaXplKHZlYzMoYnVtcE5vcm1hbC54eStkZXRhaWxOb3JtYWwueHksYnVtcE5vcm1hbC56KmRldGFpbE5vcm1hbC56KSk7XG4jZWxpZiBERVRBSUxfTk9STUFMQkxFTkRNRVRIT0Q9PTEgXG5kZXRhaWxOb3JtYWwueHkqPXZEZXRhaWxJbmZvcy56O2J1bXBOb3JtYWwrPXZlYzMoMC4wLDAuMCwxLjApO2RldGFpbE5vcm1hbCo9dmVjMygtMS4wLC0xLjAsMS4wKTt2ZWMzIGJsZW5kZWROb3JtYWw9YnVtcE5vcm1hbCpkb3QoYnVtcE5vcm1hbCxkZXRhaWxOb3JtYWwpL2J1bXBOb3JtYWwuei1kZXRhaWxOb3JtYWw7XG4jZW5kaWZcbm5vcm1hbFc9cGVydHVyYk5vcm1hbEJhc2UoVEJOLGJsZW5kZWROb3JtYWwsdkJ1bXBJbmZvcy55KTtcbiNlbmRpZlxuI2VsaWYgZGVmaW5lZChERVRBSUwpXG5kZXRhaWxOb3JtYWwueHkqPXZEZXRhaWxJbmZvcy56O25vcm1hbFc9cGVydHVyYk5vcm1hbEJhc2UoVEJOLGRldGFpbE5vcm1hbCx2RGV0YWlsSW5mb3Mueik7XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBidW1wRnJhZ21lbnQgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVtcEZyYWdtZW50LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuaW1wb3J0IFwiLi9zYW1wbGVyRnJhZ21lbnREZWNsYXJhdGlvbi5qc1wiO1xuY29uc3QgbmFtZSA9IFwiYnVtcEZyYWdtZW50RnVuY3Rpb25zXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmIGRlZmluZWQoQlVNUClcbiNpbmNsdWRlPHNhbXBsZXJGcmFnbWVudERlY2xhcmF0aW9uPihfREVGSU5FTkFNRV8sQlVNUCxfVkFSWUlOR05BTUVfLEJ1bXAsX1NBTVBMRVJOQU1FXyxidW1wKVxuI2VuZGlmXG4jaWYgZGVmaW5lZChERVRBSUwpXG4jaW5jbHVkZTxzYW1wbGVyRnJhZ21lbnREZWNsYXJhdGlvbj4oX0RFRklORU5BTUVfLERFVEFJTCxfVkFSWUlOR05BTUVfLERldGFpbCxfU0FNUExFUk5BTUVfLGRldGFpbClcbiNlbmRpZlxuI2lmIGRlZmluZWQoQlVNUCkgJiYgZGVmaW5lZChQQVJBTExBWClcbmNvbnN0IGZsb2F0IG1pblNhbXBsZXM9NC47Y29uc3QgZmxvYXQgbWF4U2FtcGxlcz0xNS47Y29uc3QgaW50IGlNYXhTYW1wbGVzPTE1O3ZlYzIgcGFyYWxsYXhPY2NsdXNpb24odmVjMyB2Vmlld0RpckNvVCx2ZWMzIHZOb3JtYWxDb1QsdmVjMiB0ZXhDb29yZCxmbG9hdCBwYXJhbGxheFNjYWxlKSB7ZmxvYXQgcGFyYWxsYXhMaW1pdD1sZW5ndGgodlZpZXdEaXJDb1QueHkpL3ZWaWV3RGlyQ29ULno7cGFyYWxsYXhMaW1pdCo9cGFyYWxsYXhTY2FsZTt2ZWMyIHZPZmZzZXREaXI9bm9ybWFsaXplKHZWaWV3RGlyQ29ULnh5KTt2ZWMyIHZNYXhPZmZzZXQ9dk9mZnNldERpcipwYXJhbGxheExpbWl0O2Zsb2F0IG51bVNhbXBsZXM9bWF4U2FtcGxlcysoZG90KHZWaWV3RGlyQ29ULHZOb3JtYWxDb1QpKihtaW5TYW1wbGVzLW1heFNhbXBsZXMpKTtmbG9hdCBzdGVwU2l6ZT0xLjAvbnVtU2FtcGxlcztmbG9hdCBjdXJyUmF5SGVpZ2h0PTEuMDt2ZWMyIHZDdXJyT2Zmc2V0PXZlYzIoMCwwKTt2ZWMyIHZMYXN0T2Zmc2V0PXZlYzIoMCwwKTtmbG9hdCBsYXN0U2FtcGxlZEhlaWdodD0xLjA7ZmxvYXQgY3VyclNhbXBsZWRIZWlnaHQ9MS4wO2Jvb2wga2VlcFdvcmtpbmc9dHJ1ZTtmb3IgKGludCBpPTA7IGk8aU1heFNhbXBsZXM7IGkrKylcbntjdXJyU2FtcGxlZEhlaWdodD10ZXh0dXJlMkQoYnVtcFNhbXBsZXIsdGV4Q29vcmQrdkN1cnJPZmZzZXQpLnc7aWYgKCFrZWVwV29ya2luZylcbnt9XG5lbHNlIGlmIChjdXJyU2FtcGxlZEhlaWdodD5jdXJyUmF5SGVpZ2h0KVxue2Zsb2F0IGRlbHRhMT1jdXJyU2FtcGxlZEhlaWdodC1jdXJyUmF5SGVpZ2h0O2Zsb2F0IGRlbHRhMj0oY3VyclJheUhlaWdodCtzdGVwU2l6ZSktbGFzdFNhbXBsZWRIZWlnaHQ7ZmxvYXQgcmF0aW89ZGVsdGExLyhkZWx0YTErZGVsdGEyKTt2Q3Vyck9mZnNldD0ocmF0aW8pKiB2TGFzdE9mZnNldCsoMS4wLXJhdGlvKSp2Q3Vyck9mZnNldDtrZWVwV29ya2luZz1mYWxzZTt9XG5lbHNlXG57Y3VyclJheUhlaWdodC09c3RlcFNpemU7dkxhc3RPZmZzZXQ9dkN1cnJPZmZzZXQ7XG4jaWZkZWYgUEFSQUxMQVhfUkhTXG52Q3Vyck9mZnNldC09c3RlcFNpemUqdk1heE9mZnNldDtcbiNlbHNlXG52Q3Vyck9mZnNldCs9c3RlcFNpemUqdk1heE9mZnNldDtcbiNlbmRpZlxubGFzdFNhbXBsZWRIZWlnaHQ9Y3VyclNhbXBsZWRIZWlnaHQ7fX1cbnJldHVybiB2Q3Vyck9mZnNldDt9XG52ZWMyIHBhcmFsbGF4T2Zmc2V0KHZlYzMgdmlld0RpcixmbG9hdCBoZWlnaHRTY2FsZSlcbntmbG9hdCBoZWlnaHQ9dGV4dHVyZTJEKGJ1bXBTYW1wbGVyLHZCdW1wVVYpLnc7dmVjMiB0ZXhDb29yZE9mZnNldD1oZWlnaHRTY2FsZSp2aWV3RGlyLnh5KmhlaWdodDtcbiNpZmRlZiBQQVJBTExBWF9SSFNcbnJldHVybiB0ZXhDb29yZE9mZnNldDtcbiNlbHNlXG5yZXR1cm4gLXRleENvb3JkT2Zmc2V0O1xuI2VuZGlmXG59XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBidW1wRnJhZ21lbnRGdW5jdGlvbnMgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVtcEZyYWdtZW50RnVuY3Rpb25zLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiYnVtcEZyYWdtZW50TWFpbkZ1bmN0aW9uc1wiO1xuY29uc3Qgc2hhZGVyID0gYCNpZiBkZWZpbmVkKEJVTVApIHx8IGRlZmluZWQoQ0xFQVJDT0FUX0JVTVApIHx8IGRlZmluZWQoQU5JU09UUk9QSUMpIHx8IGRlZmluZWQoREVUQUlMKVxuI2lmIGRlZmluZWQoVEFOR0VOVCkgJiYgZGVmaW5lZChOT1JNQUwpIFxudmFyeWluZyBtYXQzIHZUQk47XG4jZW5kaWZcbiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcbnVuaWZvcm0gbWF0NCBub3JtYWxNYXRyaXg7XG4jaWYgZGVmaW5lZChXRUJHTDIpIHx8IGRlZmluZWQoV0VCR1BVKVxubWF0NCB0b05vcm1hbE1hdHJpeChtYXQ0IHdNYXRyaXgpXG57bWF0NCByZXQ9aW52ZXJzZSh3TWF0cml4KTtyZXQ9dHJhbnNwb3NlKHJldCk7cmV0WzBdWzNdPTAuO3JldFsxXVszXT0wLjtyZXRbMl1bM109MC47cmV0WzNdPXZlYzQoMC4sMC4sMC4sMS4pO3JldHVybiByZXQ7fVxuI2Vsc2Vcbm1hdDQgdG9Ob3JtYWxNYXRyaXgobWF0NCBtKVxue2Zsb2F0XG5hMDA9bVswXVswXSxhMDE9bVswXVsxXSxhMDI9bVswXVsyXSxhMDM9bVswXVszXSxcbmExMD1tWzFdWzBdLGExMT1tWzFdWzFdLGExMj1tWzFdWzJdLGExMz1tWzFdWzNdLFxuYTIwPW1bMl1bMF0sYTIxPW1bMl1bMV0sYTIyPW1bMl1bMl0sYTIzPW1bMl1bM10sXG5hMzA9bVszXVswXSxhMzE9bVszXVsxXSxhMzI9bVszXVsyXSxhMzM9bVszXVszXSxcbmIwMD1hMDAqYTExLWEwMSphMTAsXG5iMDE9YTAwKmExMi1hMDIqYTEwLFxuYjAyPWEwMCphMTMtYTAzKmExMCxcbmIwMz1hMDEqYTEyLWEwMiphMTEsXG5iMDQ9YTAxKmExMy1hMDMqYTExLFxuYjA1PWEwMiphMTMtYTAzKmExMixcbmIwNj1hMjAqYTMxLWEyMSphMzAsXG5iMDc9YTIwKmEzMi1hMjIqYTMwLFxuYjA4PWEyMCphMzMtYTIzKmEzMCxcbmIwOT1hMjEqYTMyLWEyMiphMzEsXG5iMTA9YTIxKmEzMy1hMjMqYTMxLFxuYjExPWEyMiphMzMtYTIzKmEzMixcbmRldD1iMDAqYjExLWIwMSpiMTArYjAyKmIwOStiMDMqYjA4LWIwNCpiMDcrYjA1KmIwNjttYXQ0IG1pPW1hdDQoXG5hMTEqYjExLWExMipiMTArYTEzKmIwOSxcbmEwMipiMTAtYTAxKmIxMS1hMDMqYjA5LFxuYTMxKmIwNS1hMzIqYjA0K2EzMypiMDMsXG5hMjIqYjA0LWEyMSpiMDUtYTIzKmIwMyxcbmExMipiMDgtYTEwKmIxMS1hMTMqYjA3LFxuYTAwKmIxMS1hMDIqYjA4K2EwMypiMDcsXG5hMzIqYjAyLWEzMCpiMDUtYTMzKmIwMSxcbmEyMCpiMDUtYTIyKmIwMithMjMqYjAxLFxuYTEwKmIxMC1hMTEqYjA4K2ExMypiMDYsXG5hMDEqYjA4LWEwMCpiMTAtYTAzKmIwNixcbmEzMCpiMDQtYTMxKmIwMithMzMqYjAwLFxuYTIxKmIwMi1hMjAqYjA0LWEyMypiMDAsXG5hMTEqYjA3LWExMCpiMDktYTEyKmIwNixcbmEwMCpiMDktYTAxKmIwNythMDIqYjA2LFxuYTMxKmIwMS1hMzAqYjAzLWEzMipiMDAsXG5hMjAqYjAzLWEyMSpiMDErYTIyKmIwMCkvZGV0O3JldHVybiBtYXQ0KG1pWzBdWzBdLG1pWzFdWzBdLG1pWzJdWzBdLG1pWzNdWzBdLFxubWlbMF1bMV0sbWlbMV1bMV0sbWlbMl1bMV0sbWlbM11bMV0sXG5taVswXVsyXSxtaVsxXVsyXSxtaVsyXVsyXSxtaVszXVsyXSxcbm1pWzBdWzNdLG1pWzFdWzNdLG1pWzJdWzNdLG1pWzNdWzNdKTt9XG4jZW5kaWZcbiNlbmRpZlxudmVjMyBwZXJ0dXJiTm9ybWFsQmFzZShtYXQzIGNvdGFuZ2VudEZyYW1lLHZlYzMgbm9ybWFsLGZsb2F0IHNjYWxlKVxue1xuI2lmZGVmIE5PUk1BTFhZU0NBTEVcbm5vcm1hbD1ub3JtYWxpemUobm9ybWFsKnZlYzMoc2NhbGUsc2NhbGUsMS4wKSk7XG4jZW5kaWZcbnJldHVybiBub3JtYWxpemUoY290YW5nZW50RnJhbWUqbm9ybWFsKTt9XG52ZWMzIHBlcnR1cmJOb3JtYWwobWF0MyBjb3RhbmdlbnRGcmFtZSx2ZWMzIHRleHR1cmVTYW1wbGUsZmxvYXQgc2NhbGUpXG57cmV0dXJuIHBlcnR1cmJOb3JtYWxCYXNlKGNvdGFuZ2VudEZyYW1lLHRleHR1cmVTYW1wbGUqMi4wLTEuMCxzY2FsZSk7fVxubWF0MyBjb3RhbmdlbnRfZnJhbWUodmVjMyBub3JtYWwsdmVjMyBwLHZlYzIgdXYsdmVjMiB0YW5nZW50U3BhY2VQYXJhbXMpXG57dmVjMyBkcDE9ZEZkeChwKTt2ZWMzIGRwMj1kRmR5KHApO3ZlYzIgZHV2MT1kRmR4KHV2KTt2ZWMyIGR1djI9ZEZkeSh1dik7dmVjMyBkcDJwZXJwPWNyb3NzKGRwMixub3JtYWwpO3ZlYzMgZHAxcGVycD1jcm9zcyhub3JtYWwsZHAxKTt2ZWMzIHRhbmdlbnQ9ZHAycGVycCpkdXYxLngrZHAxcGVycCpkdXYyLng7dmVjMyBiaXRhbmdlbnQ9ZHAycGVycCpkdXYxLnkrZHAxcGVycCpkdXYyLnk7dGFuZ2VudCo9dGFuZ2VudFNwYWNlUGFyYW1zLng7Yml0YW5nZW50Kj10YW5nZW50U3BhY2VQYXJhbXMueTtmbG9hdCBkZXQ9bWF4KGRvdCh0YW5nZW50LHRhbmdlbnQpLGRvdChiaXRhbmdlbnQsYml0YW5nZW50KSk7ZmxvYXQgaW52bWF4PWRldD09MC4wID8gMC4wIDogaW52ZXJzZXNxcnQoZGV0KTtyZXR1cm4gbWF0Myh0YW5nZW50Kmludm1heCxiaXRhbmdlbnQqaW52bWF4LG5vcm1hbCk7fVxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgYnVtcEZyYWdtZW50TWFpbkZ1bmN0aW9ucyA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW1wRnJhZ21lbnRNYWluRnVuY3Rpb25zLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiZGVjYWxGcmFnbWVudFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBERUNBTFxuI2lmZGVmIEdBTU1BREVDQUxcbmRlY2FsQ29sb3IucmdiPXRvTGluZWFyU3BhY2UoZGVjYWxDb2xvci5yZ2IpO1xuI2VuZGlmXG4jaWZkZWYgREVDQUxfU01PT1RIQUxQSEFcbmRlY2FsQ29sb3IuYSo9ZGVjYWxDb2xvci5hO1xuI2VuZGlmXG5zdXJmYWNlQWxiZWRvLnJnYj1taXgoc3VyZmFjZUFsYmVkby5yZ2IsZGVjYWxDb2xvci5yZ2IsZGVjYWxDb2xvci5hKTtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGRlY2FsRnJhZ21lbnQgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjYWxGcmFnbWVudC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImRlY2FsRnJhZ21lbnREZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBERUNBTFxudW5pZm9ybSB2ZWM0IHZEZWNhbEluZm9zO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZGVjYWxGcmFnbWVudERlY2xhcmF0aW9uID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY2FsRnJhZ21lbnREZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImRlcHRoUHJlUGFzc1wiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBERVBUSFBSRVBBU1NcbmdsX0ZyYWdDb2xvcj12ZWM0KDAuLDAuLDAuLDEuMCk7cmV0dXJuO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZGVwdGhQcmVQYXNzID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcHRoUHJlUGFzcy5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImltYWdlUHJvY2Vzc2luZ0RlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIEVYUE9TVVJFXG51bmlmb3JtIGZsb2F0IGV4cG9zdXJlTGluZWFyO1xuI2VuZGlmXG4jaWZkZWYgQ09OVFJBU1RcbnVuaWZvcm0gZmxvYXQgY29udHJhc3Q7XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFZJR05FVFRFKSB8fCBkZWZpbmVkKERJVEhFUilcbnVuaWZvcm0gdmVjMiB2SW52ZXJzZVNjcmVlblNpemU7XG4jZW5kaWZcbiNpZmRlZiBWSUdORVRURVxudW5pZm9ybSB2ZWM0IHZpZ25ldHRlU2V0dGluZ3MxO3VuaWZvcm0gdmVjNCB2aWduZXR0ZVNldHRpbmdzMjtcbiNlbmRpZlxuI2lmZGVmIENPTE9SQ1VSVkVTXG51bmlmb3JtIHZlYzQgdkNhbWVyYUNvbG9yQ3VydmVOZWdhdGl2ZTt1bmlmb3JtIHZlYzQgdkNhbWVyYUNvbG9yQ3VydmVOZXV0cmFsO3VuaWZvcm0gdmVjNCB2Q2FtZXJhQ29sb3JDdXJ2ZVBvc2l0aXZlO1xuI2VuZGlmXG4jaWZkZWYgQ09MT1JHUkFESU5HXG4jaWZkZWYgQ09MT1JHUkFESU5HM0RcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjNEIHR4Q29sb3JUcmFuc2Zvcm07XG4jZWxzZVxudW5pZm9ybSBzYW1wbGVyMkQgdHhDb2xvclRyYW5zZm9ybTtcbiNlbmRpZlxudW5pZm9ybSB2ZWM0IGNvbG9yVHJhbnNmb3JtU2V0dGluZ3M7XG4jZW5kaWZcbiNpZmRlZiBESVRIRVJcbnVuaWZvcm0gZmxvYXQgZGl0aGVySW50ZW5zaXR5O1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaW1hZ2VQcm9jZXNzaW5nRGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2VQcm9jZXNzaW5nRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJpbWFnZVByb2Nlc3NpbmdGdW5jdGlvbnNcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWYgZGVmaW5lZChDT0xPUkdSQURJTkcpICYmICFkZWZpbmVkKENPTE9SR1JBRElORzNEKVxuLyoqIFxuKiBQb2x5ZmlsbCBmb3IgU0FNUExFX1RFWFRVUkVfM0Qsd2hpY2ggaXMgdW5zdXBwb3J0ZWQgaW4gV2ViR0wuXG4qIHNhbXBsZXIzZFNldHRpbmcueD10ZXh0dXJlT2Zmc2V0ICgwLjUvdGV4dHVyZVNpemUpLlxuKiBzYW1wbGVyM2RTZXR0aW5nLnk9dGV4dHVyZVNpemUuXG4qL1xuI2RlZmluZSBpbmxpbmVcbnZlYzMgc2FtcGxlVGV4dHVyZTNEKHNhbXBsZXIyRCBjb2xvclRyYW5zZm9ybSx2ZWMzIGNvbG9yLHZlYzIgc2FtcGxlcjNkU2V0dGluZylcbntmbG9hdCBzbGljZVNpemU9Mi4wKnNhbXBsZXIzZFNldHRpbmcueDsgXG4jaWZkZWYgU0FNUExFUjNER1JFRU5ERVBUSFxuZmxvYXQgc2xpY2VDb250aW51b3VzPShjb2xvci5nLXNhbXBsZXIzZFNldHRpbmcueCkqc2FtcGxlcjNkU2V0dGluZy55O1xuI2Vsc2VcbmZsb2F0IHNsaWNlQ29udGludW91cz0oY29sb3IuYi1zYW1wbGVyM2RTZXR0aW5nLngpKnNhbXBsZXIzZFNldHRpbmcueTtcbiNlbmRpZlxuZmxvYXQgc2xpY2VJbnRlZ2VyPWZsb29yKHNsaWNlQ29udGludW91cyk7ZmxvYXQgc2xpY2VGcmFjdGlvbj1zbGljZUNvbnRpbnVvdXMtc2xpY2VJbnRlZ2VyO1xuI2lmZGVmIFNBTVBMRVIzREdSRUVOREVQVEhcbnZlYzIgc2xpY2VVVj1jb2xvci5yYjtcbiNlbHNlXG52ZWMyIHNsaWNlVVY9Y29sb3Iucmc7XG4jZW5kaWZcbnNsaWNlVVYueCo9c2xpY2VTaXplO3NsaWNlVVYueCs9c2xpY2VJbnRlZ2VyKnNsaWNlU2l6ZTtzbGljZVVWPXNhdHVyYXRlKHNsaWNlVVYpO3ZlYzQgc2xpY2UwQ29sb3I9dGV4dHVyZTJEKGNvbG9yVHJhbnNmb3JtLHNsaWNlVVYpO3NsaWNlVVYueCs9c2xpY2VTaXplO3NsaWNlVVY9c2F0dXJhdGUoc2xpY2VVVik7dmVjNCBzbGljZTFDb2xvcj10ZXh0dXJlMkQoY29sb3JUcmFuc2Zvcm0sc2xpY2VVVik7dmVjMyByZXN1bHQ9bWl4KHNsaWNlMENvbG9yLnJnYixzbGljZTFDb2xvci5yZ2Isc2xpY2VGcmFjdGlvbik7XG4jaWZkZWYgU0FNUExFUjNEQkdSTUFQXG5jb2xvci5yZ2I9cmVzdWx0LnJnYjtcbiNlbHNlXG5jb2xvci5yZ2I9cmVzdWx0LmJncjtcbiNlbmRpZlxucmV0dXJuIGNvbG9yO31cbiNlbmRpZlxuI2lmIFRPTkVNQVBQSU5HPT0zXG5jb25zdCBmbG9hdCBQQlJOZXV0cmFsU3RhcnRDb21wcmVzc2lvbj0wLjgtMC4wNDtjb25zdCBmbG9hdCBQQlJOZXV0cmFsRGVzYXR1cmF0aW9uPTAuMTU7dmVjMyBQQlJOZXV0cmFsVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7ZmxvYXQgeD1taW4oY29sb3IucixtaW4oY29sb3IuZyxjb2xvci5iKSk7ZmxvYXQgb2Zmc2V0PXg8MC4wOCA/IHgtNi4yNSp4KnggOiAwLjA0O2NvbG9yLT1vZmZzZXQ7ZmxvYXQgcGVhaz1tYXgoY29sb3IucixtYXgoY29sb3IuZyxjb2xvci5iKSk7aWYgKHBlYWs8UEJSTmV1dHJhbFN0YXJ0Q29tcHJlc3Npb24pIHJldHVybiBjb2xvcjtmbG9hdCBkPTEuLVBCUk5ldXRyYWxTdGFydENvbXByZXNzaW9uO2Zsb2F0IG5ld1BlYWs9MS4tZCpkLyhwZWFrK2QtUEJSTmV1dHJhbFN0YXJ0Q29tcHJlc3Npb24pO2NvbG9yKj1uZXdQZWFrL3BlYWs7ZmxvYXQgZz0xLi0xLi8oUEJSTmV1dHJhbERlc2F0dXJhdGlvbioocGVhay1uZXdQZWFrKSsxLik7cmV0dXJuIG1peChjb2xvcixuZXdQZWFrKnZlYzMoMSwxLDEpLGcpO31cbiNlbmRpZlxuI2lmIFRPTkVNQVBQSU5HPT0yXG5jb25zdCBtYXQzIEFDRVNJbnB1dE1hdD1tYXQzKFxudmVjMygwLjU5NzE5LDAuMDc2MDAsMC4wMjg0MCksXG52ZWMzKDAuMzU0NTgsMC45MDgzNCwwLjEzMzgzKSxcbnZlYzMoMC4wNDgyMywwLjAxNTY2LDAuODM3NzcpXG4pO2NvbnN0IG1hdDMgQUNFU091dHB1dE1hdD1tYXQzKFxudmVjMyggMS42MDQ3NSwtMC4xMDIwOCwtMC4wMDMyNyksXG52ZWMzKC0wLjUzMTA4LCAxLjEwODEzLC0wLjA3Mjc2KSxcbnZlYzMoLTAuMDczNjcsLTAuMDA2MDUsIDEuMDc2MDIpXG4pO3ZlYzMgUlJUQW5kT0RURml0KHZlYzMgdilcbnt2ZWMzIGE9dioodiswLjAyNDU3ODYpLTAuMDAwMDkwNTM3O3ZlYzMgYj12KigwLjk4MzcyOSp2KzAuNDMyOTUxMCkrMC4yMzgwODE7cmV0dXJuIGEvYjt9XG52ZWMzIEFDRVNGaXR0ZWQodmVjMyBjb2xvcilcbntjb2xvcj1BQ0VTSW5wdXRNYXQqY29sb3I7Y29sb3I9UlJUQW5kT0RURml0KGNvbG9yKTtjb2xvcj1BQ0VTT3V0cHV0TWF0KmNvbG9yO2NvbG9yPXNhdHVyYXRlKGNvbG9yKTtyZXR1cm4gY29sb3I7fVxuI2VuZGlmXG4jZGVmaW5lIENVU1RPTV9JTUFHRVBST0NFU1NJTkdGVU5DVElPTlNfREVGSU5JVElPTlNcbnZlYzQgYXBwbHlJbWFnZVByb2Nlc3NpbmcodmVjNCByZXN1bHQpIHtcbiNkZWZpbmUgQ1VTVE9NX0lNQUdFUFJPQ0VTU0lOR0ZVTkNUSU9OU19VUERBVEVSRVNVTFRfQVRTVEFSVFxuI2lmZGVmIEVYUE9TVVJFXG5yZXN1bHQucmdiKj1leHBvc3VyZUxpbmVhcjtcbiNlbmRpZlxuI2lmZGVmIFZJR05FVFRFXG52ZWMyIHZpZXdwb3J0WFk9Z2xfRnJhZ0Nvb3JkLnh5KnZJbnZlcnNlU2NyZWVuU2l6ZTt2aWV3cG9ydFhZPXZpZXdwb3J0WFkqMi4wLTEuMDt2ZWMzIHZpZ25ldHRlWFkxPXZlYzModmlld3BvcnRYWSp2aWduZXR0ZVNldHRpbmdzMS54eSt2aWduZXR0ZVNldHRpbmdzMS56dywxLjApO2Zsb2F0IHZpZ25ldHRlVGVybT1kb3QodmlnbmV0dGVYWTEsdmlnbmV0dGVYWTEpO2Zsb2F0IHZpZ25ldHRlPXBvdyh2aWduZXR0ZVRlcm0sdmlnbmV0dGVTZXR0aW5nczIudyk7dmVjMyB2aWduZXR0ZUNvbG9yPXZpZ25ldHRlU2V0dGluZ3MyLnJnYjtcbiNpZmRlZiBWSUdORVRURUJMRU5ETU9ERU1VTFRJUExZXG52ZWMzIHZpZ25ldHRlQ29sb3JNdWx0aXBsaWVyPW1peCh2aWduZXR0ZUNvbG9yLHZlYzMoMSwxLDEpLHZpZ25ldHRlKTtyZXN1bHQucmdiKj12aWduZXR0ZUNvbG9yTXVsdGlwbGllcjtcbiNlbmRpZlxuI2lmZGVmIFZJR05FVFRFQkxFTkRNT0RFT1BBUVVFXG5yZXN1bHQucmdiPW1peCh2aWduZXR0ZUNvbG9yLHJlc3VsdC5yZ2IsdmlnbmV0dGUpO1xuI2VuZGlmXG4jZW5kaWZcbiNpZiBUT05FTUFQUElORz09M1xucmVzdWx0LnJnYj1QQlJOZXV0cmFsVG9uZU1hcHBpbmcocmVzdWx0LnJnYik7XG4jZWxpZiBUT05FTUFQUElORz09MlxucmVzdWx0LnJnYj1BQ0VTRml0dGVkKHJlc3VsdC5yZ2IpO1xuI2VsaWYgVE9ORU1BUFBJTkc9PTFcbmNvbnN0IGZsb2F0IHRvbmVtYXBwaW5nQ2FsaWJyYXRpb249MS41OTA1Nzk7cmVzdWx0LnJnYj0xLjAtZXhwMigtdG9uZW1hcHBpbmdDYWxpYnJhdGlvbipyZXN1bHQucmdiKTtcbiNlbmRpZlxucmVzdWx0LnJnYj10b0dhbW1hU3BhY2UocmVzdWx0LnJnYik7cmVzdWx0LnJnYj1zYXR1cmF0ZShyZXN1bHQucmdiKTtcbiNpZmRlZiBDT05UUkFTVFxudmVjMyByZXN1bHRIaWdoQ29udHJhc3Q9cmVzdWx0LnJnYipyZXN1bHQucmdiKigzLjAtMi4wKnJlc3VsdC5yZ2IpO2lmIChjb250cmFzdDwxLjApIHtyZXN1bHQucmdiPW1peCh2ZWMzKDAuNSwwLjUsMC41KSxyZXN1bHQucmdiLGNvbnRyYXN0KTt9IGVsc2Uge3Jlc3VsdC5yZ2I9bWl4KHJlc3VsdC5yZ2IscmVzdWx0SGlnaENvbnRyYXN0LGNvbnRyYXN0LTEuMCk7fVxuI2VuZGlmXG4jaWZkZWYgQ09MT1JHUkFESU5HXG52ZWMzIGNvbG9yVHJhbnNmb3JtSW5wdXQ9cmVzdWx0LnJnYipjb2xvclRyYW5zZm9ybVNldHRpbmdzLnh4eCtjb2xvclRyYW5zZm9ybVNldHRpbmdzLnl5eTtcbiNpZmRlZiBDT0xPUkdSQURJTkczRFxudmVjMyBjb2xvclRyYW5zZm9ybU91dHB1dD10ZXh0dXJlKHR4Q29sb3JUcmFuc2Zvcm0sY29sb3JUcmFuc2Zvcm1JbnB1dCkucmdiO1xuI2Vsc2VcbnZlYzMgY29sb3JUcmFuc2Zvcm1PdXRwdXQ9c2FtcGxlVGV4dHVyZTNEKHR4Q29sb3JUcmFuc2Zvcm0sY29sb3JUcmFuc2Zvcm1JbnB1dCxjb2xvclRyYW5zZm9ybVNldHRpbmdzLnl6KS5yZ2I7XG4jZW5kaWZcbnJlc3VsdC5yZ2I9bWl4KHJlc3VsdC5yZ2IsY29sb3JUcmFuc2Zvcm1PdXRwdXQsY29sb3JUcmFuc2Zvcm1TZXR0aW5ncy53d3cpO1xuI2VuZGlmXG4jaWZkZWYgQ09MT1JDVVJWRVNcbmZsb2F0IGx1bWE9Z2V0THVtaW5hbmNlKHJlc3VsdC5yZ2IpO3ZlYzIgY3VydmVNaXg9Y2xhbXAodmVjMihsdW1hKjMuMC0xLjUsbHVtYSotMy4wKzEuNSksdmVjMigwLjApLHZlYzIoMS4wKSk7dmVjNCBjb2xvckN1cnZlPXZDYW1lcmFDb2xvckN1cnZlTmV1dHJhbCtjdXJ2ZU1peC54KnZDYW1lcmFDb2xvckN1cnZlUG9zaXRpdmUtY3VydmVNaXgueSp2Q2FtZXJhQ29sb3JDdXJ2ZU5lZ2F0aXZlO3Jlc3VsdC5yZ2IqPWNvbG9yQ3VydmUucmdiO3Jlc3VsdC5yZ2I9bWl4KHZlYzMobHVtYSkscmVzdWx0LnJnYixjb2xvckN1cnZlLmEpO1xuI2VuZGlmXG4jaWZkZWYgRElUSEVSXG5mbG9hdCByYW5kPWdldFJhbmQoZ2xfRnJhZ0Nvb3JkLnh5KnZJbnZlcnNlU2NyZWVuU2l6ZSk7ZmxvYXQgZGl0aGVyPW1peCgtZGl0aGVySW50ZW5zaXR5LGRpdGhlckludGVuc2l0eSxyYW5kKTtyZXN1bHQucmdiPXNhdHVyYXRlKHJlc3VsdC5yZ2IrdmVjMyhkaXRoZXIpKTtcbiNlbmRpZlxuI2RlZmluZSBDVVNUT01fSU1BR0VQUk9DRVNTSU5HRlVOQ1RJT05TX1VQREFURVJFU1VMVF9BVEVORFxucmV0dXJuIHJlc3VsdDt9YDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGltYWdlUHJvY2Vzc2luZ0Z1bmN0aW9ucyA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZVByb2Nlc3NpbmdGdW5jdGlvbnMuanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJsaWdodEZyYWdtZW50XCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIExJR0hUe1h9XG4jaWYgZGVmaW5lZChTSEFET1dPTkxZKSB8fCBkZWZpbmVkKExJR0hUTUFQKSAmJiBkZWZpbmVkKExJR0hUTUFQRVhDTFVERUR7WH0pICYmIGRlZmluZWQoTElHSFRNQVBOT1NQRUNVTEFSe1h9KVxuI2Vsc2VcbiNpZmRlZiBQQlJcbiNpZmRlZiBTUE9UTElHSFR7WH1cbnByZUluZm89Y29tcHV0ZVBvaW50QW5kU3BvdFByZUxpZ2h0aW5nSW5mbyhsaWdodHtYfS52TGlnaHREYXRhLHZpZXdEaXJlY3Rpb25XLG5vcm1hbFcsdlBvc2l0aW9uVyk7XG4jZWxpZiBkZWZpbmVkKFBPSU5UTElHSFR7WH0pXG5wcmVJbmZvPWNvbXB1dGVQb2ludEFuZFNwb3RQcmVMaWdodGluZ0luZm8obGlnaHR7WH0udkxpZ2h0RGF0YSx2aWV3RGlyZWN0aW9uVyxub3JtYWxXLHZQb3NpdGlvblcpO1xuI2VsaWYgZGVmaW5lZChIRU1JTElHSFR7WH0pXG5wcmVJbmZvPWNvbXB1dGVIZW1pc3BoZXJpY1ByZUxpZ2h0aW5nSW5mbyhsaWdodHtYfS52TGlnaHREYXRhLHZpZXdEaXJlY3Rpb25XLG5vcm1hbFcpO1xuI2VsaWYgZGVmaW5lZChESVJMSUdIVHtYfSlcbnByZUluZm89Y29tcHV0ZURpcmVjdGlvbmFsUHJlTGlnaHRpbmdJbmZvKGxpZ2h0e1h9LnZMaWdodERhdGEsdmlld0RpcmVjdGlvblcsbm9ybWFsVyk7XG4jZW5kaWZcbnByZUluZm8uTmRvdFY9TmRvdFY7XG4jaWZkZWYgU1BPVExJR0hUe1h9XG4jaWZkZWYgTElHSFRfRkFMTE9GRl9HTFRGe1h9XG5wcmVJbmZvLmF0dGVudWF0aW9uPWNvbXB1dGVEaXN0YW5jZUxpZ2h0RmFsbG9mZl9HTFRGKHByZUluZm8ubGlnaHREaXN0YW5jZVNxdWFyZWQsbGlnaHR7WH0udkxpZ2h0RmFsbG9mZi55KTtwcmVJbmZvLmF0dGVudWF0aW9uKj1jb21wdXRlRGlyZWN0aW9uYWxMaWdodEZhbGxvZmZfR0xURihsaWdodHtYfS52TGlnaHREaXJlY3Rpb24ueHl6LHByZUluZm8uTCxsaWdodHtYfS52TGlnaHRGYWxsb2ZmLnosbGlnaHR7WH0udkxpZ2h0RmFsbG9mZi53KTtcbiNlbGlmIGRlZmluZWQoTElHSFRfRkFMTE9GRl9QSFlTSUNBTHtYfSlcbnByZUluZm8uYXR0ZW51YXRpb249Y29tcHV0ZURpc3RhbmNlTGlnaHRGYWxsb2ZmX1BoeXNpY2FsKHByZUluZm8ubGlnaHREaXN0YW5jZVNxdWFyZWQpO3ByZUluZm8uYXR0ZW51YXRpb24qPWNvbXB1dGVEaXJlY3Rpb25hbExpZ2h0RmFsbG9mZl9QaHlzaWNhbChsaWdodHtYfS52TGlnaHREaXJlY3Rpb24ueHl6LHByZUluZm8uTCxsaWdodHtYfS52TGlnaHREaXJlY3Rpb24udyk7XG4jZWxpZiBkZWZpbmVkKExJR0hUX0ZBTExPRkZfU1RBTkRBUkR7WH0pXG5wcmVJbmZvLmF0dGVudWF0aW9uPWNvbXB1dGVEaXN0YW5jZUxpZ2h0RmFsbG9mZl9TdGFuZGFyZChwcmVJbmZvLmxpZ2h0T2Zmc2V0LGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYueCk7cHJlSW5mby5hdHRlbnVhdGlvbio9Y29tcHV0ZURpcmVjdGlvbmFsTGlnaHRGYWxsb2ZmX1N0YW5kYXJkKGxpZ2h0e1h9LnZMaWdodERpcmVjdGlvbi54eXoscHJlSW5mby5MLGxpZ2h0e1h9LnZMaWdodERpcmVjdGlvbi53LGxpZ2h0e1h9LnZMaWdodERhdGEudyk7XG4jZWxzZVxucHJlSW5mby5hdHRlbnVhdGlvbj1jb21wdXRlRGlzdGFuY2VMaWdodEZhbGxvZmYocHJlSW5mby5saWdodE9mZnNldCxwcmVJbmZvLmxpZ2h0RGlzdGFuY2VTcXVhcmVkLGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYueCxsaWdodHtYfS52TGlnaHRGYWxsb2ZmLnkpO3ByZUluZm8uYXR0ZW51YXRpb24qPWNvbXB1dGVEaXJlY3Rpb25hbExpZ2h0RmFsbG9mZihsaWdodHtYfS52TGlnaHREaXJlY3Rpb24ueHl6LHByZUluZm8uTCxsaWdodHtYfS52TGlnaHREaXJlY3Rpb24udyxsaWdodHtYfS52TGlnaHREYXRhLncsbGlnaHR7WH0udkxpZ2h0RmFsbG9mZi56LGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYudyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoUE9JTlRMSUdIVHtYfSlcbiNpZmRlZiBMSUdIVF9GQUxMT0ZGX0dMVEZ7WH1cbnByZUluZm8uYXR0ZW51YXRpb249Y29tcHV0ZURpc3RhbmNlTGlnaHRGYWxsb2ZmX0dMVEYocHJlSW5mby5saWdodERpc3RhbmNlU3F1YXJlZCxsaWdodHtYfS52TGlnaHRGYWxsb2ZmLnkpO1xuI2VsaWYgZGVmaW5lZChMSUdIVF9GQUxMT0ZGX1BIWVNJQ0FMe1h9KVxucHJlSW5mby5hdHRlbnVhdGlvbj1jb21wdXRlRGlzdGFuY2VMaWdodEZhbGxvZmZfUGh5c2ljYWwocHJlSW5mby5saWdodERpc3RhbmNlU3F1YXJlZCk7XG4jZWxpZiBkZWZpbmVkKExJR0hUX0ZBTExPRkZfU1RBTkRBUkR7WH0pXG5wcmVJbmZvLmF0dGVudWF0aW9uPWNvbXB1dGVEaXN0YW5jZUxpZ2h0RmFsbG9mZl9TdGFuZGFyZChwcmVJbmZvLmxpZ2h0T2Zmc2V0LGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYueCk7XG4jZWxzZVxucHJlSW5mby5hdHRlbnVhdGlvbj1jb21wdXRlRGlzdGFuY2VMaWdodEZhbGxvZmYocHJlSW5mby5saWdodE9mZnNldCxwcmVJbmZvLmxpZ2h0RGlzdGFuY2VTcXVhcmVkLGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYueCxsaWdodHtYfS52TGlnaHRGYWxsb2ZmLnkpO1xuI2VuZGlmXG4jZWxzZVxucHJlSW5mby5hdHRlbnVhdGlvbj0xLjA7XG4jZW5kaWZcbiNpZmRlZiBIRU1JTElHSFR7WH1cbnByZUluZm8ucm91Z2huZXNzPXJvdWdobmVzcztcbiNlbHNlXG5wcmVJbmZvLnJvdWdobmVzcz1hZGp1c3RSb3VnaG5lc3NGcm9tTGlnaHRQcm9wZXJ0aWVzKHJvdWdobmVzcyxsaWdodHtYfS52TGlnaHRTcGVjdWxhci5hLHByZUluZm8ubGlnaHREaXN0YW5jZSk7XG4jZW5kaWZcbiNpZmRlZiBJUklERVNDRU5DRVxucHJlSW5mby5pcmlkZXNjZW5jZUludGVuc2l0eT1pcmlkZXNjZW5jZUludGVuc2l0eTtcbiNlbmRpZlxuI2lmZGVmIEhFTUlMSUdIVHtYfVxuaW5mby5kaWZmdXNlPWNvbXB1dGVIZW1pc3BoZXJpY0RpZmZ1c2VMaWdodGluZyhwcmVJbmZvLGxpZ2h0e1h9LnZMaWdodERpZmZ1c2UucmdiLGxpZ2h0e1h9LnZMaWdodEdyb3VuZCk7XG4jZWxpZiBkZWZpbmVkKFNTX1RSQU5TTFVDRU5DWSlcbmluZm8uZGlmZnVzZT1jb21wdXRlRGlmZnVzZUFuZFRyYW5zbWl0dGVkTGlnaHRpbmcocHJlSW5mbyxsaWdodHtYfS52TGlnaHREaWZmdXNlLnJnYixzdWJTdXJmYWNlT3V0LnRyYW5zbWl0dGFuY2UpO1xuI2Vsc2VcbmluZm8uZGlmZnVzZT1jb21wdXRlRGlmZnVzZUxpZ2h0aW5nKHByZUluZm8sbGlnaHR7WH0udkxpZ2h0RGlmZnVzZS5yZ2IpO1xuI2VuZGlmXG4jaWZkZWYgU1BFQ1VMQVJURVJNXG4jaWZkZWYgQU5JU09UUk9QSUNcbmluZm8uc3BlY3VsYXI9Y29tcHV0ZUFuaXNvdHJvcGljU3BlY3VsYXJMaWdodGluZyhwcmVJbmZvLHZpZXdEaXJlY3Rpb25XLG5vcm1hbFcsYW5pc290cm9waWNPdXQuYW5pc290cm9waWNUYW5nZW50LGFuaXNvdHJvcGljT3V0LmFuaXNvdHJvcGljQml0YW5nZW50LGFuaXNvdHJvcGljT3V0LmFuaXNvdHJvcHksY2xlYXJjb2F0T3V0LnNwZWN1bGFyRW52aXJvbm1lbnRSMCxzcGVjdWxhckVudmlyb25tZW50UjkwLEFBUm91Z2huZXNzRmFjdG9ycy54LGxpZ2h0e1h9LnZMaWdodERpZmZ1c2UucmdiKTtcbiNlbHNlXG5pbmZvLnNwZWN1bGFyPWNvbXB1dGVTcGVjdWxhckxpZ2h0aW5nKHByZUluZm8sbm9ybWFsVyxjbGVhcmNvYXRPdXQuc3BlY3VsYXJFbnZpcm9ubWVudFIwLHNwZWN1bGFyRW52aXJvbm1lbnRSOTAsQUFSb3VnaG5lc3NGYWN0b3JzLngsbGlnaHR7WH0udkxpZ2h0RGlmZnVzZS5yZ2IpO1xuI2VuZGlmXG4jZW5kaWZcbiNpZmRlZiBTSEVFTlxuI2lmZGVmIFNIRUVOX0xJTktXSVRIQUxCRURPXG5wcmVJbmZvLnJvdWdobmVzcz1zaGVlbk91dC5zaGVlbkludGVuc2l0eTtcbiNlbHNlXG4jaWZkZWYgSEVNSUxJR0hUe1h9XG5wcmVJbmZvLnJvdWdobmVzcz1zaGVlbk91dC5zaGVlblJvdWdobmVzcztcbiNlbHNlXG5wcmVJbmZvLnJvdWdobmVzcz1hZGp1c3RSb3VnaG5lc3NGcm9tTGlnaHRQcm9wZXJ0aWVzKHNoZWVuT3V0LnNoZWVuUm91Z2huZXNzLGxpZ2h0e1h9LnZMaWdodFNwZWN1bGFyLmEscHJlSW5mby5saWdodERpc3RhbmNlKTtcbiNlbmRpZlxuI2VuZGlmXG5pbmZvLnNoZWVuPWNvbXB1dGVTaGVlbkxpZ2h0aW5nKHByZUluZm8sbm9ybWFsVyxzaGVlbk91dC5zaGVlbkNvbG9yLHNwZWN1bGFyRW52aXJvbm1lbnRSOTAsQUFSb3VnaG5lc3NGYWN0b3JzLngsbGlnaHR7WH0udkxpZ2h0RGlmZnVzZS5yZ2IpO1xuI2VuZGlmXG4jaWZkZWYgQ0xFQVJDT0FUXG4jaWZkZWYgSEVNSUxJR0hUe1h9XG5wcmVJbmZvLnJvdWdobmVzcz1jbGVhcmNvYXRPdXQuY2xlYXJDb2F0Um91Z2huZXNzO1xuI2Vsc2VcbnByZUluZm8ucm91Z2huZXNzPWFkanVzdFJvdWdobmVzc0Zyb21MaWdodFByb3BlcnRpZXMoY2xlYXJjb2F0T3V0LmNsZWFyQ29hdFJvdWdobmVzcyxsaWdodHtYfS52TGlnaHRTcGVjdWxhci5hLHByZUluZm8ubGlnaHREaXN0YW5jZSk7XG4jZW5kaWZcbmluZm8uY2xlYXJDb2F0PWNvbXB1dGVDbGVhckNvYXRMaWdodGluZyhwcmVJbmZvLGNsZWFyY29hdE91dC5jbGVhckNvYXROb3JtYWxXLGNsZWFyY29hdE91dC5jbGVhckNvYXRBQVJvdWdobmVzc0ZhY3RvcnMueCxjbGVhcmNvYXRPdXQuY2xlYXJDb2F0SW50ZW5zaXR5LGxpZ2h0e1h9LnZMaWdodERpZmZ1c2UucmdiKTtcbiNpZmRlZiBDTEVBUkNPQVRfVElOVFxuYWJzb3JwdGlvbj1jb21wdXRlQ2xlYXJDb2F0TGlnaHRpbmdBYnNvcnB0aW9uKGNsZWFyY29hdE91dC5jbGVhckNvYXROZG90VlJlZnJhY3QscHJlSW5mby5MLGNsZWFyY29hdE91dC5jbGVhckNvYXROb3JtYWxXLGNsZWFyY29hdE91dC5jbGVhckNvYXRDb2xvcixjbGVhcmNvYXRPdXQuY2xlYXJDb2F0VGhpY2tuZXNzLGNsZWFyY29hdE91dC5jbGVhckNvYXRJbnRlbnNpdHkpO2luZm8uZGlmZnVzZSo9YWJzb3JwdGlvbjtcbiNpZmRlZiBTUEVDVUxBUlRFUk1cbmluZm8uc3BlY3VsYXIqPWFic29ycHRpb247XG4jZW5kaWZcbiNlbmRpZlxuaW5mby5kaWZmdXNlKj1pbmZvLmNsZWFyQ29hdC53O1xuI2lmZGVmIFNQRUNVTEFSVEVSTVxuaW5mby5zcGVjdWxhcio9aW5mby5jbGVhckNvYXQudztcbiNlbmRpZlxuI2lmZGVmIFNIRUVOXG5pbmZvLnNoZWVuKj1pbmZvLmNsZWFyQ29hdC53O1xuI2VuZGlmXG4jZW5kaWZcbiNlbHNlXG4jaWZkZWYgU1BPVExJR0hUe1h9XG5pbmZvPWNvbXB1dGVTcG90TGlnaHRpbmcodmlld0RpcmVjdGlvblcsbm9ybWFsVyxsaWdodHtYfS52TGlnaHREYXRhLGxpZ2h0e1h9LnZMaWdodERpcmVjdGlvbixsaWdodHtYfS52TGlnaHREaWZmdXNlLnJnYixsaWdodHtYfS52TGlnaHRTcGVjdWxhci5yZ2IsbGlnaHR7WH0udkxpZ2h0RGlmZnVzZS5hLGdsb3NzaW5lc3MpO1xuI2VsaWYgZGVmaW5lZChIRU1JTElHSFR7WH0pXG5pbmZvPWNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLG5vcm1hbFcsbGlnaHR7WH0udkxpZ2h0RGF0YSxsaWdodHtYfS52TGlnaHREaWZmdXNlLnJnYixsaWdodHtYfS52TGlnaHRTcGVjdWxhci5yZ2IsbGlnaHR7WH0udkxpZ2h0R3JvdW5kLGdsb3NzaW5lc3MpO1xuI2VsaWYgZGVmaW5lZChQT0lOVExJR0hUe1h9KSB8fCBkZWZpbmVkKERJUkxJR0hUe1h9KVxuaW5mbz1jb21wdXRlTGlnaHRpbmcodmlld0RpcmVjdGlvblcsbm9ybWFsVyxsaWdodHtYfS52TGlnaHREYXRhLGxpZ2h0e1h9LnZMaWdodERpZmZ1c2UucmdiLGxpZ2h0e1h9LnZMaWdodFNwZWN1bGFyLnJnYixsaWdodHtYfS52TGlnaHREaWZmdXNlLmEsZ2xvc3NpbmVzcyk7XG4jZW5kaWZcbiNlbmRpZlxuI2lmZGVmIFBST0pFQ1RFRExJR0hUVEVYVFVSRXtYfVxuaW5mby5kaWZmdXNlKj1jb21wdXRlUHJvamVjdGlvblRleHR1cmVEaWZmdXNlTGlnaHRpbmcocHJvamVjdGlvbkxpZ2h0VGV4dHVyZXtYfSx0ZXh0dXJlUHJvamVjdGlvbk1hdHJpeHtYfSx2UG9zaXRpb25XKTtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgU0hBRE9Xe1h9XG4jaWZkZWYgU0hBRE9XQ1NNe1h9XG5mb3IgKGludCBpPTA7IGk8U0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9OyBpKyspIFxue1xuI2lmZGVmIFNIQURPV0NTTV9SSUdIVEhBTkRFRHtYfVxuZGlmZntYfT12aWV3RnJ1c3R1bVp7WH1baV0rdlBvc2l0aW9uRnJvbUNhbWVyYXtYfS56O1xuI2Vsc2VcbmRpZmZ7WH09dmlld0ZydXN0dW1ae1h9W2ldLXZQb3NpdGlvbkZyb21DYW1lcmF7WH0uejtcbiNlbmRpZlxuaWYgKGRpZmZ7WH0+PTAuKSB7aW5kZXh7WH09aTticmVhazt9fVxuI2lmZGVmIFNIQURPV0NTTVVTRVNIQURPV01BWFp7WH1cbmlmIChpbmRleHtYfT49MClcbiNlbmRpZlxue1xuI2lmIGRlZmluZWQoU0hBRE9XUENGe1h9KVxuI2lmIGRlZmluZWQoU0hBRE9XTE9XUVVBTElUWXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDRjEoZmxvYXQoaW5kZXh7WH0pLHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZWxpZiBkZWZpbmVkKFNIQURPV01FRElVTVFVQUxJVFl7WH0pXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhDU01QQ0YzKGZsb2F0KGluZGV4e1h9KSx2UG9zaXRpb25Gcm9tTGlnaHR7WH1baW5kZXh7WH1dLHZEZXB0aE1ldHJpY3tYfVtpbmRleHtYfV0sc2hhZG93VGV4dHVyZXtYfSxsaWdodHtYfS5zaGFkb3dzSW5mby55eixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2Vsc2VcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDRjUoZmxvYXQoaW5kZXh7WH0pLHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnl6LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoU0hBRE9XUENTU3tYfSlcbiNpZiBkZWZpbmVkKFNIQURPV0xPV1FVQUxJVFl7WH0pXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhDU01QQ1NTMTYoZmxvYXQoaW5kZXh7WH0pLHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxkZXB0aFRleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfSxsaWdodHtYfS5zaGFkb3dzSW5mby55LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnosbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53LGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbntYfVtpbmRleHtYfV0sZGVwdGhDb3JyZWN0aW9ue1h9W2luZGV4e1h9XSxwZW51bWJyYURhcmtuZXNze1h9KTtcbiNlbGlmIGRlZmluZWQoU0hBRE9XTUVESVVNUVVBTElUWXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDU1MzMihmbG9hdChpbmRleHtYfSksdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2luZGV4e1h9XSx2RGVwdGhNZXRyaWN7WH1baW5kZXh7WH1dLGRlcHRoVGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnksbGlnaHR7WH0uc2hhZG93c0luZm8ueixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncsbGlnaHRTaXplVVZDb3JyZWN0aW9ue1h9W2luZGV4e1h9XSxkZXB0aENvcnJlY3Rpb257WH1baW5kZXh7WH1dLHBlbnVtYnJhRGFya25lc3N7WH0pO1xuI2Vsc2VcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDU1M2NChmbG9hdChpbmRleHtYfSksdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2luZGV4e1h9XSx2RGVwdGhNZXRyaWN7WH1baW5kZXh7WH1dLGRlcHRoVGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnksbGlnaHR7WH0uc2hhZG93c0luZm8ueixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncsbGlnaHRTaXplVVZDb3JyZWN0aW9ue1h9W2luZGV4e1h9XSxkZXB0aENvcnJlY3Rpb257WH1baW5kZXh7WH1dLHBlbnVtYnJhRGFya25lc3N7WH0pO1xuI2VuZGlmXG4jZWxzZVxuc2hhZG93PWNvbXB1dGVTaGFkb3dDU00oZmxvYXQoaW5kZXh7WH0pLHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbiNpZmRlZiBTSEFET1dDU01ERUJVR3tYfVxuc2hhZG93RGVidWd7WH09dmVjMyhzaGFkb3cpKnZDYXNjYWRlQ29sb3JzTXVsdGlwbGllcntYfVtpbmRleHtYfV07XG4jZW5kaWZcbiNpZm5kZWYgU0hBRE9XQ1NNTk9CTEVORHtYfVxuZmxvYXQgZnJ1c3R1bUxlbmd0aD1mcnVzdHVtTGVuZ3Roc3tYfVtpbmRleHtYfV07ZmxvYXQgZGlmZlJhdGlvPWNsYW1wKGRpZmZ7WH0vZnJ1c3R1bUxlbmd0aCwwLiwxLikqY2FzY2FkZUJsZW5kRmFjdG9ye1h9O2lmIChpbmRleHtYfTwoU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9LTEpICYmIGRpZmZSYXRpbzwxLilcbntpbmRleHtYfSs9MTtmbG9hdCBuZXh0U2hhZG93PTAuO1xuI2lmIGRlZmluZWQoU0hBRE9XUENGe1h9KVxuI2lmIGRlZmluZWQoU0hBRE9XTE9XUVVBTElUWXtYfSlcbm5leHRTaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhDU01QQ0YxKGZsb2F0KGluZGV4e1h9KSx2UG9zaXRpb25Gcm9tTGlnaHR7WH1baW5kZXh7WH1dLHZEZXB0aE1ldHJpY3tYfVtpbmRleHtYfV0sc2hhZG93VGV4dHVyZXtYfSxsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2VsaWYgZGVmaW5lZChTSEFET1dNRURJVU1RVUFMSVRZe1h9KVxubmV4dFNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDRjMoZmxvYXQoaW5kZXh7WH0pLHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnl6LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZWxzZVxubmV4dFNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDRjUoZmxvYXQoaW5kZXh7WH0pLHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnl6LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoU0hBRE9XUENTU3tYfSlcbiNpZiBkZWZpbmVkKFNIQURPV0xPV1FVQUxJVFl7WH0pXG5uZXh0U2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUzE2KGZsb2F0KGluZGV4e1h9KSx2UG9zaXRpb25Gcm9tTGlnaHR7WH1baW5kZXh7WH1dLHZEZXB0aE1ldHJpY3tYfVtpbmRleHtYfV0sZGVwdGhUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyxsaWdodFNpemVVVkNvcnJlY3Rpb257WH1baW5kZXh7WH1dLGRlcHRoQ29ycmVjdGlvbntYfVtpbmRleHtYfV0scGVudW1icmFEYXJrbmVzc3tYfSk7XG4jZWxpZiBkZWZpbmVkKFNIQURPV01FRElVTVFVQUxJVFl7WH0pXG5uZXh0U2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUzMyKGZsb2F0KGluZGV4e1h9KSx2UG9zaXRpb25Gcm9tTGlnaHR7WH1baW5kZXh7WH1dLHZEZXB0aE1ldHJpY3tYfVtpbmRleHtYfV0sZGVwdGhUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyxsaWdodFNpemVVVkNvcnJlY3Rpb257WH1baW5kZXh7WH1dLGRlcHRoQ29ycmVjdGlvbntYfVtpbmRleHtYfV0scGVudW1icmFEYXJrbmVzc3tYfSk7XG4jZWxzZVxubmV4dFNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDU1M2NChmbG9hdChpbmRleHtYfSksdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2luZGV4e1h9XSx2RGVwdGhNZXRyaWN7WH1baW5kZXh7WH1dLGRlcHRoVGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnksbGlnaHR7WH0uc2hhZG93c0luZm8ueixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncsbGlnaHRTaXplVVZDb3JyZWN0aW9ue1h9W2luZGV4e1h9XSxkZXB0aENvcnJlY3Rpb257WH1baW5kZXh7WH1dLHBlbnVtYnJhRGFya25lc3N7WH0pO1xuI2VuZGlmXG4jZWxzZVxubmV4dFNoYWRvdz1jb21wdXRlU2hhZG93Q1NNKGZsb2F0KGluZGV4e1h9KSx2UG9zaXRpb25Gcm9tTGlnaHR7WH1baW5kZXh7WH1dLHZEZXB0aE1ldHJpY3tYfVtpbmRleHtYfV0sc2hhZG93VGV4dHVyZXtYfSxsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2VuZGlmXG5zaGFkb3c9bWl4KG5leHRTaGFkb3csc2hhZG93LGRpZmZSYXRpbyk7XG4jaWZkZWYgU0hBRE9XQ1NNREVCVUd7WH1cbnNoYWRvd0RlYnVne1h9PW1peCh2ZWMzKG5leHRTaGFkb3cpKnZDYXNjYWRlQ29sb3JzTXVsdGlwbGllcntYfVtpbmRleHtYfV0sc2hhZG93RGVidWd7WH0sZGlmZlJhdGlvKTtcbiNlbmRpZlxufVxuI2VuZGlmXG59XG4jZWxpZiBkZWZpbmVkKFNIQURPV0NMT1NFRVNNe1h9KVxuI2lmIGRlZmluZWQoU0hBRE9XQ1VCRXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENsb3NlRVNNQ3ViZSh2UG9zaXRpb25XLGxpZ2h0e1h9LnZMaWdodERhdGEueHl6LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LmRlcHRoVmFsdWVzKTtcbiNlbHNlXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhDbG9zZUVTTSh2UG9zaXRpb25Gcm9tTGlnaHR7WH0sdkRlcHRoTWV0cmlje1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2VuZGlmXG4jZWxpZiBkZWZpbmVkKFNIQURPV0VTTXtYfSlcbiNpZiBkZWZpbmVkKFNIQURPV0NVQkV7WH0pXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhFU01DdWJlKHZQb3NpdGlvblcsbGlnaHR7WH0udkxpZ2h0RGF0YS54eXosc2hhZG93VGV4dHVyZXtYfSxsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnosbGlnaHR7WH0uZGVwdGhWYWx1ZXMpO1xuI2Vsc2VcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aEVTTSh2UG9zaXRpb25Gcm9tTGlnaHR7WH0sdkRlcHRoTWV0cmlje1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2VuZGlmXG4jZWxpZiBkZWZpbmVkKFNIQURPV1BPSVNTT057WH0pXG4jaWYgZGVmaW5lZChTSEFET1dDVUJFe1h9KVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoUG9pc3NvblNhbXBsaW5nQ3ViZSh2UG9zaXRpb25XLGxpZ2h0e1h9LnZMaWdodERhdGEueHl6LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LmRlcHRoVmFsdWVzKTtcbiNlbHNlXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhQb2lzc29uU2FtcGxpbmcodlBvc2l0aW9uRnJvbUxpZ2h0e1h9LHZEZXB0aE1ldHJpY3tYfSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnksbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbmRpZlxuI2VsaWYgZGVmaW5lZChTSEFET1dQQ0Z7WH0pXG4jaWYgZGVmaW5lZChTSEFET1dMT1dRVUFMSVRZe1h9KVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoUENGMSh2UG9zaXRpb25Gcm9tTGlnaHR7WH0sdkRlcHRoTWV0cmlje1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbGlmIGRlZmluZWQoU0hBRE9XTUVESVVNUVVBTElUWXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aFBDRjModlBvc2l0aW9uRnJvbUxpZ2h0e1h9LHZEZXB0aE1ldHJpY3tYfSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnl6LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZWxzZVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoUENGNSh2UG9zaXRpb25Gcm9tTGlnaHR7WH0sdkRlcHRoTWV0cmlje1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueXosbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbmRpZlxuI2VsaWYgZGVmaW5lZChTSEFET1dQQ1NTe1h9KVxuI2lmIGRlZmluZWQoU0hBRE9XTE9XUVVBTElUWXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aFBDU1MxNih2UG9zaXRpb25Gcm9tTGlnaHR7WH0sdkRlcHRoTWV0cmlje1h9LGRlcHRoVGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnksbGlnaHR7WH0uc2hhZG93c0luZm8ueixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2VsaWYgZGVmaW5lZChTSEFET1dNRURJVU1RVUFMSVRZe1h9KVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoUENTUzMyKHZQb3NpdGlvbkZyb21MaWdodHtYfSx2RGVwdGhNZXRyaWN7WH0sZGVwdGhUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZWxzZVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoUENTUzY0KHZQb3NpdGlvbkZyb21MaWdodHtYfSx2RGVwdGhNZXRyaWN7WH0sZGVwdGhUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbiNlbHNlXG4jaWYgZGVmaW5lZChTSEFET1dDVUJFe1h9KVxuc2hhZG93PWNvbXB1dGVTaGFkb3dDdWJlKHZQb3NpdGlvblcsbGlnaHR7WH0udkxpZ2h0RGF0YS54eXosc2hhZG93VGV4dHVyZXtYfSxsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LmRlcHRoVmFsdWVzKTtcbiNlbHNlXG5zaGFkb3c9Y29tcHV0ZVNoYWRvdyh2UG9zaXRpb25Gcm9tTGlnaHR7WH0sdkRlcHRoTWV0cmlje1h9LHNoYWRvd1RleHR1cmV7WH0sbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgU0hBRE9XT05MWVxuI2lmbmRlZiBTSEFET1dJTlVTRVxuI2RlZmluZSBTSEFET1dJTlVTRVxuI2VuZGlmXG5nbG9iYWxTaGFkb3crPXNoYWRvdztzaGFkb3dMaWdodENvdW50Kz0xLjA7XG4jZW5kaWZcbiNlbHNlXG5zaGFkb3c9MS47XG4jZW5kaWZcbmFnZ1NoYWRvdys9c2hhZG93O251bUxpZ2h0cys9MS4wO1xuI2lmbmRlZiBTSEFET1dPTkxZXG4jaWZkZWYgQ1VTVE9NVVNFUkxJR0hUSU5HXG5kaWZmdXNlQmFzZSs9Y29tcHV0ZUN1c3RvbURpZmZ1c2VMaWdodGluZyhpbmZvLGRpZmZ1c2VCYXNlLHNoYWRvdyk7XG4jaWZkZWYgU1BFQ1VMQVJURVJNXG5zcGVjdWxhckJhc2UrPWNvbXB1dGVDdXN0b21TcGVjdWxhckxpZ2h0aW5nKGluZm8sc3BlY3VsYXJCYXNlLHNoYWRvdyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoTElHSFRNQVApICYmIGRlZmluZWQoTElHSFRNQVBFWENMVURFRHtYfSlcbmRpZmZ1c2VCYXNlKz1saWdodG1hcENvbG9yLnJnYipzaGFkb3c7XG4jaWZkZWYgU1BFQ1VMQVJURVJNXG4jaWZuZGVmIExJR0hUTUFQTk9TUEVDVUxBUntYfVxuc3BlY3VsYXJCYXNlKz1pbmZvLnNwZWN1bGFyKnNoYWRvdypsaWdodG1hcENvbG9yLnJnYjtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgQ0xFQVJDT0FUXG4jaWZuZGVmIExJR0hUTUFQTk9TUEVDVUxBUntYfVxuY2xlYXJDb2F0QmFzZSs9aW5mby5jbGVhckNvYXQucmdiKnNoYWRvdypsaWdodG1hcENvbG9yLnJnYjtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgU0hFRU5cbiNpZm5kZWYgTElHSFRNQVBOT1NQRUNVTEFSe1h9XG5zaGVlbkJhc2UrPWluZm8uc2hlZW4ucmdiKnNoYWRvdztcbiNlbmRpZlxuI2VuZGlmXG4jZWxzZVxuI2lmZGVmIFNIQURPV0NTTURFQlVHe1h9XG5kaWZmdXNlQmFzZSs9aW5mby5kaWZmdXNlKnNoYWRvd0RlYnVne1h9O1xuI2Vsc2UgXG5kaWZmdXNlQmFzZSs9aW5mby5kaWZmdXNlKnNoYWRvdztcbiNlbmRpZlxuI2lmZGVmIFNQRUNVTEFSVEVSTVxuc3BlY3VsYXJCYXNlKz1pbmZvLnNwZWN1bGFyKnNoYWRvdztcbiNlbmRpZlxuI2lmZGVmIENMRUFSQ09BVFxuY2xlYXJDb2F0QmFzZSs9aW5mby5jbGVhckNvYXQucmdiKnNoYWRvdztcbiNlbmRpZlxuI2lmZGVmIFNIRUVOXG5zaGVlbkJhc2UrPWluZm8uc2hlZW4ucmdiKnNoYWRvdztcbiNlbmRpZlxuI2VuZGlmXG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGxpZ2h0RnJhZ21lbnQgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlnaHRGcmFnbWVudC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImxpZ2h0RnJhZ21lbnREZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBMSUdIVHtYfVxudW5pZm9ybSB2ZWM0IHZMaWdodERhdGF7WH07dW5pZm9ybSB2ZWM0IHZMaWdodERpZmZ1c2V7WH07XG4jaWZkZWYgU1BFQ1VMQVJURVJNXG51bmlmb3JtIHZlYzQgdkxpZ2h0U3BlY3VsYXJ7WH07XG4jZWxzZVxudmVjNCB2TGlnaHRTcGVjdWxhcntYfT12ZWM0KDAuKTtcbiNlbmRpZlxuI2lmZGVmIFNIQURPV3tYfVxuI2lmZGVmIFNIQURPV0NTTXtYfVxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4e1h9W1NIQURPV0NTTU5VTV9DQVNDQURFU3tYfV07dW5pZm9ybSBmbG9hdCB2aWV3RnJ1c3R1bVp7WH1bU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9XTt1bmlmb3JtIGZsb2F0IGZydXN0dW1MZW5ndGhze1h9W1NIQURPV0NTTU5VTV9DQVNDQURFU3tYfV07dW5pZm9ybSBmbG9hdCBjYXNjYWRlQmxlbmRGYWN0b3J7WH07dmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodHtYfVtTSEFET1dDU01OVU1fQ0FTQ0FERVN7WH1dO3ZhcnlpbmcgZmxvYXQgdkRlcHRoTWV0cmlje1h9W1NIQURPV0NTTU5VTV9DQVNDQURFU3tYfV07dmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21DYW1lcmF7WH07XG4jaWYgZGVmaW5lZChTSEFET1dQQ1NTe1h9KVxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkRBcnJheVNoYWRvdyBzaGFkb3dUZXh0dXJle1h9O3VuaWZvcm0gaGlnaHAgc2FtcGxlcjJEQXJyYXkgZGVwdGhUZXh0dXJle1h9O3VuaWZvcm0gdmVjMiBsaWdodFNpemVVVkNvcnJlY3Rpb257WH1bU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9XTt1bmlmb3JtIGZsb2F0IGRlcHRoQ29ycmVjdGlvbntYfVtTSEFET1dDU01OVU1fQ0FTQ0FERVN7WH1dO3VuaWZvcm0gZmxvYXQgcGVudW1icmFEYXJrbmVzc3tYfTtcbiNlbGlmIGRlZmluZWQoU0hBRE9XUENGe1h9KVxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkRBcnJheVNoYWRvdyBzaGFkb3dUZXh0dXJle1h9O1xuI2Vsc2VcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEQXJyYXkgc2hhZG93VGV4dHVyZXtYfTtcbiNlbmRpZlxuI2lmZGVmIFNIQURPV0NTTURFQlVHe1h9XG5jb25zdCB2ZWMzIHZDYXNjYWRlQ29sb3JzTXVsdGlwbGllcntYfVs4XT12ZWMzWzhdXG4oXG52ZWMzICggMS41LDAuMCwwLjAgKSxcbnZlYzMgKCAwLjAsMS41LDAuMCApLFxudmVjMyAoIDAuMCwwLjAsNS41ICksXG52ZWMzICggMS41LDAuMCw1LjUgKSxcbnZlYzMgKCAxLjUsMS41LDAuMCApLFxudmVjMyAoIDEuMCwxLjAsMS4wICksXG52ZWMzICggMC4wLDEuMCw1LjUgKSxcbnZlYzMgKCAwLjUsMy41LDAuNzUgKVxuKTt2ZWMzIHNoYWRvd0RlYnVne1h9O1xuI2VuZGlmXG4jaWZkZWYgU0hBRE9XQ1NNVVNFU0hBRE9XTUFYWntYfVxuaW50IGluZGV4e1h9PS0xO1xuI2Vsc2VcbmludCBpbmRleHtYfT1TSEFET1dDU01OVU1fQ0FTQ0FERVN7WH0tMTtcbiNlbmRpZlxuZmxvYXQgZGlmZntYfT0wLjtcbiNlbGlmIGRlZmluZWQoU0hBRE9XQ1VCRXtYfSlcbnVuaWZvcm0gc2FtcGxlckN1YmUgc2hhZG93VGV4dHVyZXtYfTtcbiNlbHNlXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0e1h9O3ZhcnlpbmcgZmxvYXQgdkRlcHRoTWV0cmlje1h9O1xuI2lmIGRlZmluZWQoU0hBRE9XUENTU3tYfSlcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEU2hhZG93IHNoYWRvd1RleHR1cmV7WH07dW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhUZXh0dXJle1h9O1xuI2VsaWYgZGVmaW5lZChTSEFET1dQQ0Z7WH0pXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRFNoYWRvdyBzaGFkb3dUZXh0dXJle1h9O1xuI2Vsc2VcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd1RleHR1cmV7WH07XG4jZW5kaWZcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeHtYfTtcbiNlbmRpZlxudW5pZm9ybSB2ZWM0IHNoYWRvd3NJbmZve1h9O3VuaWZvcm0gdmVjMiBkZXB0aFZhbHVlc3tYfTtcbiNlbmRpZlxuI2lmZGVmIFNQT1RMSUdIVHtYfVxudW5pZm9ybSB2ZWM0IHZMaWdodERpcmVjdGlvbntYfTt1bmlmb3JtIHZlYzQgdkxpZ2h0RmFsbG9mZntYfTtcbiNlbGlmIGRlZmluZWQoUE9JTlRMSUdIVHtYfSlcbnVuaWZvcm0gdmVjNCB2TGlnaHRGYWxsb2Zme1h9O1xuI2VsaWYgZGVmaW5lZChIRU1JTElHSFR7WH0pXG51bmlmb3JtIHZlYzMgdkxpZ2h0R3JvdW5ke1h9O1xuI2VuZGlmXG4jaWZkZWYgUFJPSkVDVEVETElHSFRURVhUVVJFe1h9XG51bmlmb3JtIG1hdDQgdGV4dHVyZVByb2plY3Rpb25NYXRyaXh7WH07dW5pZm9ybSBzYW1wbGVyMkQgcHJvamVjdGlvbkxpZ2h0VGV4dHVyZXtYfTtcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbGlnaHRGcmFnbWVudERlY2xhcmF0aW9uID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZ2h0RnJhZ21lbnREZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImxpZ2h0VWJvRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTElHSFR7WH1cbnVuaWZvcm0gTGlnaHR7WH1cbnt2ZWM0IHZMaWdodERhdGE7dmVjNCB2TGlnaHREaWZmdXNlO3ZlYzQgdkxpZ2h0U3BlY3VsYXI7XG4jaWZkZWYgU1BPVExJR0hUe1h9XG52ZWM0IHZMaWdodERpcmVjdGlvbjt2ZWM0IHZMaWdodEZhbGxvZmY7XG4jZWxpZiBkZWZpbmVkKFBPSU5UTElHSFR7WH0pXG52ZWM0IHZMaWdodEZhbGxvZmY7XG4jZWxpZiBkZWZpbmVkKEhFTUlMSUdIVHtYfSlcbnZlYzMgdkxpZ2h0R3JvdW5kO1xuI2VuZGlmXG52ZWM0IHNoYWRvd3NJbmZvO3ZlYzIgZGVwdGhWYWx1ZXM7fSBsaWdodHtYfTtcbiNpZmRlZiBQUk9KRUNURURMSUdIVFRFWFRVUkV7WH1cbnVuaWZvcm0gbWF0NCB0ZXh0dXJlUHJvamVjdGlvbk1hdHJpeHtYfTt1bmlmb3JtIHNhbXBsZXIyRCBwcm9qZWN0aW9uTGlnaHRUZXh0dXJle1h9O1xuI2VuZGlmXG4jaWZkZWYgU0hBRE9Xe1h9XG4jaWZkZWYgU0hBRE9XQ1NNe1h9XG51bmlmb3JtIG1hdDQgbGlnaHRNYXRyaXh7WH1bU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9XTt1bmlmb3JtIGZsb2F0IHZpZXdGcnVzdHVtWntYfVtTSEFET1dDU01OVU1fQ0FTQ0FERVN7WH1dO3VuaWZvcm0gZmxvYXQgZnJ1c3R1bUxlbmd0aHN7WH1bU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9XTt1bmlmb3JtIGZsb2F0IGNhc2NhZGVCbGVuZEZhY3RvcntYfTt2YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W1NIQURPV0NTTU5VTV9DQVNDQURFU3tYfV07dmFyeWluZyBmbG9hdCB2RGVwdGhNZXRyaWN7WH1bU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9XTt2YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUNhbWVyYXtYfTtcbiNpZiBkZWZpbmVkKFNIQURPV1BDU1N7WH0pXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyREFycmF5U2hhZG93IHNoYWRvd1RleHR1cmV7WH07dW5pZm9ybSBoaWdocCBzYW1wbGVyMkRBcnJheSBkZXB0aFRleHR1cmV7WH07dW5pZm9ybSB2ZWMyIGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbntYfVtTSEFET1dDU01OVU1fQ0FTQ0FERVN7WH1dO3VuaWZvcm0gZmxvYXQgZGVwdGhDb3JyZWN0aW9ue1h9W1NIQURPV0NTTU5VTV9DQVNDQURFU3tYfV07dW5pZm9ybSBmbG9hdCBwZW51bWJyYURhcmtuZXNze1h9O1xuI2VsaWYgZGVmaW5lZChTSEFET1dQQ0Z7WH0pXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyREFycmF5U2hhZG93IHNoYWRvd1RleHR1cmV7WH07XG4jZWxzZVxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkRBcnJheSBzaGFkb3dUZXh0dXJle1h9O1xuI2VuZGlmXG4jaWZkZWYgU0hBRE9XQ1NNREVCVUd7WH1cbmNvbnN0IHZlYzMgdkNhc2NhZGVDb2xvcnNNdWx0aXBsaWVye1h9WzhdPXZlYzNbOF1cbihcbnZlYzMgKCAxLjUsMC4wLDAuMCApLFxudmVjMyAoIDAuMCwxLjUsMC4wICksXG52ZWMzICggMC4wLDAuMCw1LjUgKSxcbnZlYzMgKCAxLjUsMC4wLDUuNSApLFxudmVjMyAoIDEuNSwxLjUsMC4wICksXG52ZWMzICggMS4wLDEuMCwxLjAgKSxcbnZlYzMgKCAwLjAsMS4wLDUuNSApLFxudmVjMyAoIDAuNSwzLjUsMC43NSApXG4pO3ZlYzMgc2hhZG93RGVidWd7WH07XG4jZW5kaWZcbiNpZmRlZiBTSEFET1dDU01VU0VTSEFET1dNQVhae1h9XG5pbnQgaW5kZXh7WH09LTE7XG4jZWxzZVxuaW50IGluZGV4e1h9PVNIQURPV0NTTU5VTV9DQVNDQURFU3tYfS0xO1xuI2VuZGlmXG5mbG9hdCBkaWZme1h9PTAuO1xuI2VsaWYgZGVmaW5lZChTSEFET1dDVUJFe1h9KVxudW5pZm9ybSBzYW1wbGVyQ3ViZSBzaGFkb3dUZXh0dXJle1h9OyBcbiNlbHNlXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0e1h9O3ZhcnlpbmcgZmxvYXQgdkRlcHRoTWV0cmlje1h9O1xuI2lmIGRlZmluZWQoU0hBRE9XUENTU3tYfSlcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEU2hhZG93IHNoYWRvd1RleHR1cmV7WH07dW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhUZXh0dXJle1h9O1xuI2VsaWYgZGVmaW5lZChTSEFET1dQQ0Z7WH0pXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRFNoYWRvdyBzaGFkb3dUZXh0dXJle1h9O1xuI2Vsc2VcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd1RleHR1cmV7WH07XG4jZW5kaWZcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeHtYfTtcbiNlbmRpZlxuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBsaWdodFVib0RlY2xhcmF0aW9uID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZ2h0VWJvRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJtYWluVVZWYXJ5aW5nRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTUFJTlVWe1h9XG52YXJ5aW5nIHZlYzIgdk1haW5VVntYfTtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG1haW5VVlZhcnlpbmdEZWNsYXJhdGlvbiA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluVVZWYXJ5aW5nRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJvaXREZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBPUkRFUl9JTkRFUEVOREVOVF9UUkFOU1BBUkVOQ1lcbiNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcbmxheW91dChsb2NhdGlvbj0wKSBvdXQgdmVjMiBkZXB0aDsgXG5sYXlvdXQobG9jYXRpb249MSkgb3V0IHZlYzQgZnJvbnRDb2xvcjtsYXlvdXQobG9jYXRpb249Mikgb3V0IHZlYzQgYmFja0NvbG9yO1xuI2RlZmluZSBNQVhfREVQVEggOTk5OTkuMFxuaGlnaHAgdmVjNCBnbF9GcmFnQ29sb3I7dW5pZm9ybSBzYW1wbGVyMkQgb2l0RGVwdGhTYW1wbGVyO3VuaWZvcm0gc2FtcGxlcjJEIG9pdEZyb250Q29sb3JTYW1wbGVyO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3Qgb2l0RGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2l0RGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJvaXRGcmFnbWVudFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBPUkRFUl9JTkRFUEVOREVOVF9UUkFOU1BBUkVOQ1lcbmZsb2F0IGZyYWdEZXB0aD1nbF9GcmFnQ29vcmQuejsgXG4jaWZkZWYgT1JERVJfSU5ERVBFTkRFTlRfVFJBTlNQQVJFTkNZXzE2QklUU1xudWludCBoYWxmRmxvYXQ9cGFja0hhbGYyeDE2KHZlYzIoZnJhZ0RlcHRoKSk7dmVjMiBmdWxsPXVucGFja0hhbGYyeDE2KGhhbGZGbG9hdCk7ZnJhZ0RlcHRoPWZ1bGwueDtcbiNlbmRpZlxuaXZlYzIgZnJhZ0Nvb3JkPWl2ZWMyKGdsX0ZyYWdDb29yZC54eSk7dmVjMiBsYXN0RGVwdGg9dGV4ZWxGZXRjaChvaXREZXB0aFNhbXBsZXIsZnJhZ0Nvb3JkLDApLnJnO3ZlYzQgbGFzdEZyb250Q29sb3I9dGV4ZWxGZXRjaChvaXRGcm9udENvbG9yU2FtcGxlcixmcmFnQ29vcmQsMCk7ZGVwdGgucmc9dmVjMigtTUFYX0RFUFRIKTtmcm9udENvbG9yPWxhc3RGcm9udENvbG9yO2JhY2tDb2xvcj12ZWM0KDAuMCk7XG4jaWZkZWYgVVNFX1JFVkVSU0VfREVQVEhCVUZGRVJcbmZsb2F0IGZ1cnRoZXN0RGVwdGg9LWxhc3REZXB0aC54O2Zsb2F0IG5lYXJlc3REZXB0aD1sYXN0RGVwdGgueTtcbiNlbHNlXG5mbG9hdCBuZWFyZXN0RGVwdGg9LWxhc3REZXB0aC54O2Zsb2F0IGZ1cnRoZXN0RGVwdGg9bGFzdERlcHRoLnk7XG4jZW5kaWZcbmZsb2F0IGFscGhhTXVsdGlwbGllcj0xLjAtbGFzdEZyb250Q29sb3IuYTtcbiNpZmRlZiBVU0VfUkVWRVJTRV9ERVBUSEJVRkZFUlxuaWYgKGZyYWdEZXB0aD5uZWFyZXN0RGVwdGggfHwgZnJhZ0RlcHRoPGZ1cnRoZXN0RGVwdGgpIHtcbiNlbHNlXG5pZiAoZnJhZ0RlcHRoPG5lYXJlc3REZXB0aCB8fCBmcmFnRGVwdGg+ZnVydGhlc3REZXB0aCkge1xuI2VuZGlmXG5yZXR1cm47fVxuI2lmZGVmIFVTRV9SRVZFUlNFX0RFUFRIQlVGRkVSXG5pZiAoZnJhZ0RlcHRoPG5lYXJlc3REZXB0aCAmJiBmcmFnRGVwdGg+ZnVydGhlc3REZXB0aCkge1xuI2Vsc2VcbmlmIChmcmFnRGVwdGg+bmVhcmVzdERlcHRoICYmIGZyYWdEZXB0aDxmdXJ0aGVzdERlcHRoKSB7XG4jZW5kaWZcbmRlcHRoLnJnPXZlYzIoLWZyYWdEZXB0aCxmcmFnRGVwdGgpO3JldHVybjt9XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBvaXRGcmFnbWVudCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vaXRGcmFnbWVudC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcInByZVBhc3NEZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBQUkVQQVNTXG4jZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlXG5sYXlvdXQobG9jYXRpb249MCkgb3V0IGhpZ2hwIHZlYzQgZ2xGcmFnRGF0YVt7WH1dO2hpZ2hwIHZlYzQgZ2xfRnJhZ0NvbG9yO1xuI2lmZGVmIFBSRVBBU1NfREVQVEhcbnZhcnlpbmcgaGlnaHAgdmVjMyB2Vmlld1BvcztcbiNlbmRpZlxuI2lmZGVmIFBSRVBBU1NfVkVMT0NJVFlcbnZhcnlpbmcgaGlnaHAgdmVjNCB2Q3VycmVudFBvc2l0aW9uO3ZhcnlpbmcgaGlnaHAgdmVjNCB2UHJldmlvdXNQb3NpdGlvbjtcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcHJlUGFzc0RlY2xhcmF0aW9uID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZVBhc3NEZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcInJlZmxlY3Rpb25GdW5jdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYHZlYzMgY29tcHV0ZUZpeGVkRXF1aXJlY3Rhbmd1bGFyQ29vcmRzKHZlYzQgd29ybGRQb3MsdmVjMyB3b3JsZE5vcm1hbCx2ZWMzIGRpcmVjdGlvbilcbntmbG9hdCBsb249YXRhbihkaXJlY3Rpb24ueixkaXJlY3Rpb24ueCk7ZmxvYXQgbGF0PWFjb3MoZGlyZWN0aW9uLnkpO3ZlYzIgc3BoZXJlQ29vcmRzPXZlYzIobG9uLGxhdCkqUkVDSVBST0NBTF9QSTIqMi4wO2Zsb2F0IHM9c3BoZXJlQ29vcmRzLngqMC41KzAuNTtmbG9hdCB0PXNwaGVyZUNvb3Jkcy55O3JldHVybiB2ZWMzKHMsdCwwKTsgfVxudmVjMyBjb21wdXRlTWlycm9yZWRGaXhlZEVxdWlyZWN0YW5ndWxhckNvb3Jkcyh2ZWM0IHdvcmxkUG9zLHZlYzMgd29ybGROb3JtYWwsdmVjMyBkaXJlY3Rpb24pXG57ZmxvYXQgbG9uPWF0YW4oZGlyZWN0aW9uLnosZGlyZWN0aW9uLngpO2Zsb2F0IGxhdD1hY29zKGRpcmVjdGlvbi55KTt2ZWMyIHNwaGVyZUNvb3Jkcz12ZWMyKGxvbixsYXQpKlJFQ0lQUk9DQUxfUEkyKjIuMDtmbG9hdCBzPXNwaGVyZUNvb3Jkcy54KjAuNSswLjU7ZmxvYXQgdD1zcGhlcmVDb29yZHMueTtyZXR1cm4gdmVjMygxLjAtcyx0LDApOyB9XG52ZWMzIGNvbXB1dGVFcXVpcmVjdGFuZ3VsYXJDb29yZHModmVjNCB3b3JsZFBvcyx2ZWMzIHdvcmxkTm9ybWFsLHZlYzMgZXllUG9zaXRpb24sbWF0NCByZWZsZWN0aW9uTWF0cml4KVxue3ZlYzMgY2FtZXJhVG9WZXJ0ZXg9bm9ybWFsaXplKHdvcmxkUG9zLnh5ei1leWVQb3NpdGlvbik7dmVjMyByPW5vcm1hbGl6ZShyZWZsZWN0KGNhbWVyYVRvVmVydGV4LHdvcmxkTm9ybWFsKSk7cj12ZWMzKHJlZmxlY3Rpb25NYXRyaXgqdmVjNChyLDApKTtmbG9hdCBsb249YXRhbihyLnosci54KTtmbG9hdCBsYXQ9YWNvcyhyLnkpO3ZlYzIgc3BoZXJlQ29vcmRzPXZlYzIobG9uLGxhdCkqUkVDSVBST0NBTF9QSTIqMi4wO2Zsb2F0IHM9c3BoZXJlQ29vcmRzLngqMC41KzAuNTtmbG9hdCB0PXNwaGVyZUNvb3Jkcy55O3JldHVybiB2ZWMzKHMsdCwwKTt9XG52ZWMzIGNvbXB1dGVTcGhlcmljYWxDb29yZHModmVjNCB3b3JsZFBvcyx2ZWMzIHdvcmxkTm9ybWFsLG1hdDQgdmlldyxtYXQ0IHJlZmxlY3Rpb25NYXRyaXgpXG57dmVjMyB2aWV3RGlyPW5vcm1hbGl6ZSh2ZWMzKHZpZXcqd29ybGRQb3MpKTt2ZWMzIHZpZXdOb3JtYWw9bm9ybWFsaXplKHZlYzModmlldyp2ZWM0KHdvcmxkTm9ybWFsLDAuMCkpKTt2ZWMzIHI9cmVmbGVjdCh2aWV3RGlyLHZpZXdOb3JtYWwpO3I9dmVjMyhyZWZsZWN0aW9uTWF0cml4KnZlYzQociwwKSk7ci56PXIuei0xLjA7ZmxvYXQgbT0yLjAqbGVuZ3RoKHIpO3JldHVybiB2ZWMzKHIueC9tKzAuNSwxLjAtci55L20tMC41LDApO31cbnZlYzMgY29tcHV0ZVBsYW5hckNvb3Jkcyh2ZWM0IHdvcmxkUG9zLHZlYzMgd29ybGROb3JtYWwsdmVjMyBleWVQb3NpdGlvbixtYXQ0IHJlZmxlY3Rpb25NYXRyaXgpXG57dmVjMyB2aWV3RGlyPXdvcmxkUG9zLnh5ei1leWVQb3NpdGlvbjt2ZWMzIGNvb3Jkcz1ub3JtYWxpemUocmVmbGVjdCh2aWV3RGlyLHdvcmxkTm9ybWFsKSk7cmV0dXJuIHZlYzMocmVmbGVjdGlvbk1hdHJpeCp2ZWM0KGNvb3JkcywxKSk7fVxudmVjMyBjb21wdXRlQ3ViaWNDb29yZHModmVjNCB3b3JsZFBvcyx2ZWMzIHdvcmxkTm9ybWFsLHZlYzMgZXllUG9zaXRpb24sbWF0NCByZWZsZWN0aW9uTWF0cml4KVxue3ZlYzMgdmlld0Rpcj1ub3JtYWxpemUod29ybGRQb3MueHl6LWV5ZVBvc2l0aW9uKTt2ZWMzIGNvb3Jkcz1yZWZsZWN0KHZpZXdEaXIsd29ybGROb3JtYWwpO2Nvb3Jkcz12ZWMzKHJlZmxlY3Rpb25NYXRyaXgqdmVjNChjb29yZHMsMCkpO1xuI2lmZGVmIElOVkVSVENVQklDTUFQXG5jb29yZHMueSo9LTEuMDtcbiNlbmRpZlxucmV0dXJuIGNvb3Jkczt9XG52ZWMzIGNvbXB1dGVDdWJpY0xvY2FsQ29vcmRzKHZlYzQgd29ybGRQb3MsdmVjMyB3b3JsZE5vcm1hbCx2ZWMzIGV5ZVBvc2l0aW9uLG1hdDQgcmVmbGVjdGlvbk1hdHJpeCx2ZWMzIHJlZmxlY3Rpb25TaXplLHZlYzMgcmVmbGVjdGlvblBvc2l0aW9uKVxue3ZlYzMgdmlld0Rpcj1ub3JtYWxpemUod29ybGRQb3MueHl6LWV5ZVBvc2l0aW9uKTt2ZWMzIGNvb3Jkcz1yZWZsZWN0KHZpZXdEaXIsd29ybGROb3JtYWwpO2Nvb3Jkcz1wYXJhbGxheENvcnJlY3ROb3JtYWwod29ybGRQb3MueHl6LGNvb3JkcyxyZWZsZWN0aW9uU2l6ZSxyZWZsZWN0aW9uUG9zaXRpb24pO2Nvb3Jkcz12ZWMzKHJlZmxlY3Rpb25NYXRyaXgqdmVjNChjb29yZHMsMCkpO1xuI2lmZGVmIElOVkVSVENVQklDTUFQXG5jb29yZHMueSo9LTEuMDtcbiNlbmRpZlxucmV0dXJuIGNvb3Jkczt9XG52ZWMzIGNvbXB1dGVQcm9qZWN0aW9uQ29vcmRzKHZlYzQgd29ybGRQb3MsbWF0NCB2aWV3LG1hdDQgcmVmbGVjdGlvbk1hdHJpeClcbntyZXR1cm4gdmVjMyhyZWZsZWN0aW9uTWF0cml4Kih2aWV3KndvcmxkUG9zKSk7fVxudmVjMyBjb21wdXRlU2t5Qm94Q29vcmRzKHZlYzMgcG9zaXRpb25XLG1hdDQgcmVmbGVjdGlvbk1hdHJpeClcbntyZXR1cm4gdmVjMyhyZWZsZWN0aW9uTWF0cml4KnZlYzQocG9zaXRpb25XLDEuKSk7fVxuI2lmZGVmIFJFRkxFQ1RJT05cbnZlYzMgY29tcHV0ZVJlZmxlY3Rpb25Db29yZHModmVjNCB3b3JsZFBvcyx2ZWMzIHdvcmxkTm9ybWFsKVxue1xuI2lmZGVmIFJFRkxFQ1RJT05NQVBfTUlSUk9SRURFUVVJUkVDVEFOR1VMQVJfRklYRURcbnZlYzMgZGlyZWN0aW9uPW5vcm1hbGl6ZSh2RGlyZWN0aW9uVyk7cmV0dXJuIGNvbXB1dGVNaXJyb3JlZEZpeGVkRXF1aXJlY3Rhbmd1bGFyQ29vcmRzKHdvcmxkUG9zLHdvcmxkTm9ybWFsLGRpcmVjdGlvbik7XG4jZW5kaWZcbiNpZmRlZiBSRUZMRUNUSU9OTUFQX0VRVUlSRUNUQU5HVUxBUl9GSVhFRFxudmVjMyBkaXJlY3Rpb249bm9ybWFsaXplKHZEaXJlY3Rpb25XKTtyZXR1cm4gY29tcHV0ZUZpeGVkRXF1aXJlY3Rhbmd1bGFyQ29vcmRzKHdvcmxkUG9zLHdvcmxkTm9ybWFsLGRpcmVjdGlvbik7XG4jZW5kaWZcbiNpZmRlZiBSRUZMRUNUSU9OTUFQX0VRVUlSRUNUQU5HVUxBUlxucmV0dXJuIGNvbXB1dGVFcXVpcmVjdGFuZ3VsYXJDb29yZHMod29ybGRQb3Msd29ybGROb3JtYWwsdkV5ZVBvc2l0aW9uLnh5eixyZWZsZWN0aW9uTWF0cml4KTtcbiNlbmRpZlxuI2lmZGVmIFJFRkxFQ1RJT05NQVBfU1BIRVJJQ0FMXG5yZXR1cm4gY29tcHV0ZVNwaGVyaWNhbENvb3Jkcyh3b3JsZFBvcyx3b3JsZE5vcm1hbCx2aWV3LHJlZmxlY3Rpb25NYXRyaXgpO1xuI2VuZGlmXG4jaWZkZWYgUkVGTEVDVElPTk1BUF9QTEFOQVJcbnJldHVybiBjb21wdXRlUGxhbmFyQ29vcmRzKHdvcmxkUG9zLHdvcmxkTm9ybWFsLHZFeWVQb3NpdGlvbi54eXoscmVmbGVjdGlvbk1hdHJpeCk7XG4jZW5kaWZcbiNpZmRlZiBSRUZMRUNUSU9OTUFQX0NVQklDXG4jaWZkZWYgVVNFX0xPQ0FMX1JFRkxFQ1RJT05NQVBfQ1VCSUNcbnJldHVybiBjb21wdXRlQ3ViaWNMb2NhbENvb3Jkcyh3b3JsZFBvcyx3b3JsZE5vcm1hbCx2RXllUG9zaXRpb24ueHl6LHJlZmxlY3Rpb25NYXRyaXgsdlJlZmxlY3Rpb25TaXplLHZSZWZsZWN0aW9uUG9zaXRpb24pO1xuI2Vsc2VcbnJldHVybiBjb21wdXRlQ3ViaWNDb29yZHMod29ybGRQb3Msd29ybGROb3JtYWwsdkV5ZVBvc2l0aW9uLnh5eixyZWZsZWN0aW9uTWF0cml4KTtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgUkVGTEVDVElPTk1BUF9QUk9KRUNUSU9OXG5yZXR1cm4gY29tcHV0ZVByb2plY3Rpb25Db29yZHMod29ybGRQb3MsdmlldyxyZWZsZWN0aW9uTWF0cml4KTtcbiNlbmRpZlxuI2lmZGVmIFJFRkxFQ1RJT05NQVBfU0tZQk9YXG5yZXR1cm4gY29tcHV0ZVNreUJveENvb3Jkcyh2UG9zaXRpb25VVlcscmVmbGVjdGlvbk1hdHJpeCk7XG4jZW5kaWZcbiNpZmRlZiBSRUZMRUNUSU9OTUFQX0VYUExJQ0lUXG5yZXR1cm4gdmVjMygwLDAsMCk7XG4jZW5kaWZcbn1cbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHJlZmxlY3Rpb25GdW5jdGlvbiA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0aW9uRnVuY3Rpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJzYW1wbGVyRnJhZ21lbnREZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBfREVGSU5FTkFNRV9cbiNpZiBfREVGSU5FTkFNRV9ESVJFQ1RVVj09MVxuI2RlZmluZSB2X1ZBUllJTkdOQU1FX1VWIHZNYWluVVYxXG4jZWxpZiBfREVGSU5FTkFNRV9ESVJFQ1RVVj09MlxuI2RlZmluZSB2X1ZBUllJTkdOQU1FX1VWIHZNYWluVVYyXG4jZWxpZiBfREVGSU5FTkFNRV9ESVJFQ1RVVj09M1xuI2RlZmluZSB2X1ZBUllJTkdOQU1FX1VWIHZNYWluVVYzXG4jZWxpZiBfREVGSU5FTkFNRV9ESVJFQ1RVVj09NFxuI2RlZmluZSB2X1ZBUllJTkdOQU1FX1VWIHZNYWluVVY0XG4jZWxpZiBfREVGSU5FTkFNRV9ESVJFQ1RVVj09NVxuI2RlZmluZSB2X1ZBUllJTkdOQU1FX1VWIHZNYWluVVY1XG4jZWxpZiBfREVGSU5FTkFNRV9ESVJFQ1RVVj09NlxuI2RlZmluZSB2X1ZBUllJTkdOQU1FX1VWIHZNYWluVVY2XG4jZWxzZVxudmFyeWluZyB2ZWMyIHZfVkFSWUlOR05BTUVfVVY7XG4jZW5kaWZcbnVuaWZvcm0gc2FtcGxlcjJEIF9TQU1QTEVSTkFNRV9TYW1wbGVyO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3Qgc2FtcGxlckZyYWdtZW50RGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlckZyYWdtZW50RGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJzaGFkb3dzRnJhZ21lbnRGdW5jdGlvbnNcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgU0hBRE9XU1xuI2lmIGRlZmluZWQoV0VCR0wyKSB8fCBkZWZpbmVkKFdFQkdQVSkgfHwgZGVmaW5lZChOQVRJVkUpXG4jZGVmaW5lIFRFWFRVUkVGVU5DKHMsYyxsKSB0ZXh0dXJlMkRMb2RFWFQocyxjLGwpXG4jZWxzZVxuI2RlZmluZSBURVhUVVJFRlVOQyhzLGMsYikgdGV4dHVyZTJEKHMsYyxiKVxuI2VuZGlmXG4jaWZuZGVmIFNIQURPV0ZMT0FUXG5mbG9hdCB1bnBhY2sodmVjNCBjb2xvcilcbntjb25zdCB2ZWM0IGJpdF9zaGlmdD12ZWM0KDEuMC8oMjU1LjAqMjU1LjAqMjU1LjApLDEuMC8oMjU1LjAqMjU1LjApLDEuMC8yNTUuMCwxLjApO3JldHVybiBkb3QoY29sb3IsYml0X3NoaWZ0KTt9XG4jZW5kaWZcbmZsb2F0IGNvbXB1dGVGYWxsT2ZmKGZsb2F0IHZhbHVlLHZlYzIgY2xpcFNwYWNlLGZsb2F0IGZydXN0dW1FZGdlRmFsbG9mZilcbntmbG9hdCBtYXNrPXNtb290aHN0ZXAoMS4wLWZydXN0dW1FZGdlRmFsbG9mZiwxLjAwMDAwMDEyLGNsYW1wKGRvdChjbGlwU3BhY2UsY2xpcFNwYWNlKSwwLiwxLikpO3JldHVybiBtaXgodmFsdWUsMS4wLG1hc2spO31cbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93Q3ViZSh2ZWMzIHdvcmxkUG9zLHZlYzMgbGlnaHRQb3NpdGlvbixzYW1wbGVyQ3ViZSBzaGFkb3dTYW1wbGVyLGZsb2F0IGRhcmtuZXNzLHZlYzIgZGVwdGhWYWx1ZXMpXG57dmVjMyBkaXJlY3Rpb25Ub0xpZ2h0PXdvcmxkUG9zLWxpZ2h0UG9zaXRpb247ZmxvYXQgZGVwdGg9bGVuZ3RoKGRpcmVjdGlvblRvTGlnaHQpO2RlcHRoPShkZXB0aCtkZXB0aFZhbHVlcy54KS8oZGVwdGhWYWx1ZXMueSk7ZGVwdGg9Y2xhbXAoZGVwdGgsMC4sMS4wKTtkaXJlY3Rpb25Ub0xpZ2h0PW5vcm1hbGl6ZShkaXJlY3Rpb25Ub0xpZ2h0KTtkaXJlY3Rpb25Ub0xpZ2h0Lnk9LWRpcmVjdGlvblRvTGlnaHQueTtcbiNpZm5kZWYgU0hBRE9XRkxPQVRcbmZsb2F0IHNoYWRvdz11bnBhY2sodGV4dHVyZUN1YmUoc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0KSk7XG4jZWxzZVxuZmxvYXQgc2hhZG93PXRleHR1cmVDdWJlKHNoYWRvd1NhbXBsZXIsZGlyZWN0aW9uVG9MaWdodCkueDtcbiNlbmRpZlxucmV0dXJuIGRlcHRoPnNoYWRvdyA/IGRhcmtuZXNzIDogMS4wO31cbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aFBvaXNzb25TYW1wbGluZ0N1YmUodmVjMyB3b3JsZFBvcyx2ZWMzIGxpZ2h0UG9zaXRpb24sc2FtcGxlckN1YmUgc2hhZG93U2FtcGxlcixmbG9hdCBtYXBTaXplLGZsb2F0IGRhcmtuZXNzLHZlYzIgZGVwdGhWYWx1ZXMpXG57dmVjMyBkaXJlY3Rpb25Ub0xpZ2h0PXdvcmxkUG9zLWxpZ2h0UG9zaXRpb247ZmxvYXQgZGVwdGg9bGVuZ3RoKGRpcmVjdGlvblRvTGlnaHQpO2RlcHRoPShkZXB0aCtkZXB0aFZhbHVlcy54KS8oZGVwdGhWYWx1ZXMueSk7ZGVwdGg9Y2xhbXAoZGVwdGgsMC4sMS4wKTtkaXJlY3Rpb25Ub0xpZ2h0PW5vcm1hbGl6ZShkaXJlY3Rpb25Ub0xpZ2h0KTtkaXJlY3Rpb25Ub0xpZ2h0Lnk9LWRpcmVjdGlvblRvTGlnaHQueTtmbG9hdCB2aXNpYmlsaXR5PTEuO3ZlYzMgcG9pc3NvbkRpc2tbNF07cG9pc3NvbkRpc2tbMF09dmVjMygtMS4wLDEuMCwtMS4wKTtwb2lzc29uRGlza1sxXT12ZWMzKDEuMCwtMS4wLC0xLjApO3BvaXNzb25EaXNrWzJdPXZlYzMoLTEuMCwtMS4wLC0xLjApO3BvaXNzb25EaXNrWzNdPXZlYzMoMS4wLC0xLjAsMS4wKTtcbiNpZm5kZWYgU0hBRE9XRkxPQVRcbmlmICh1bnBhY2sodGV4dHVyZUN1YmUoc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0K3BvaXNzb25EaXNrWzBdKm1hcFNpemUpKTxkZXB0aCkgdmlzaWJpbGl0eS09MC4yNTtpZiAodW5wYWNrKHRleHR1cmVDdWJlKHNoYWRvd1NhbXBsZXIsZGlyZWN0aW9uVG9MaWdodCtwb2lzc29uRGlza1sxXSptYXBTaXplKSk8ZGVwdGgpIHZpc2liaWxpdHktPTAuMjU7aWYgKHVucGFjayh0ZXh0dXJlQ3ViZShzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQrcG9pc3NvbkRpc2tbMl0qbWFwU2l6ZSkpPGRlcHRoKSB2aXNpYmlsaXR5LT0wLjI1O2lmICh1bnBhY2sodGV4dHVyZUN1YmUoc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0K3BvaXNzb25EaXNrWzNdKm1hcFNpemUpKTxkZXB0aCkgdmlzaWJpbGl0eS09MC4yNTtcbiNlbHNlXG5pZiAodGV4dHVyZUN1YmUoc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0K3BvaXNzb25EaXNrWzBdKm1hcFNpemUpLng8ZGVwdGgpIHZpc2liaWxpdHktPTAuMjU7aWYgKHRleHR1cmVDdWJlKHNoYWRvd1NhbXBsZXIsZGlyZWN0aW9uVG9MaWdodCtwb2lzc29uRGlza1sxXSptYXBTaXplKS54PGRlcHRoKSB2aXNpYmlsaXR5LT0wLjI1O2lmICh0ZXh0dXJlQ3ViZShzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQrcG9pc3NvbkRpc2tbMl0qbWFwU2l6ZSkueDxkZXB0aCkgdmlzaWJpbGl0eS09MC4yNTtpZiAodGV4dHVyZUN1YmUoc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0K3BvaXNzb25EaXNrWzNdKm1hcFNpemUpLng8ZGVwdGgpIHZpc2liaWxpdHktPTAuMjU7XG4jZW5kaWZcbnJldHVybiBtaW4oMS4wLHZpc2liaWxpdHkrZGFya25lc3MpO31cbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aEVTTUN1YmUodmVjMyB3b3JsZFBvcyx2ZWMzIGxpZ2h0UG9zaXRpb24sc2FtcGxlckN1YmUgc2hhZG93U2FtcGxlcixmbG9hdCBkYXJrbmVzcyxmbG9hdCBkZXB0aFNjYWxlLHZlYzIgZGVwdGhWYWx1ZXMpXG57dmVjMyBkaXJlY3Rpb25Ub0xpZ2h0PXdvcmxkUG9zLWxpZ2h0UG9zaXRpb247ZmxvYXQgZGVwdGg9bGVuZ3RoKGRpcmVjdGlvblRvTGlnaHQpO2RlcHRoPShkZXB0aCtkZXB0aFZhbHVlcy54KS8oZGVwdGhWYWx1ZXMueSk7ZmxvYXQgc2hhZG93UGl4ZWxEZXB0aD1jbGFtcChkZXB0aCwwLiwxLjApO2RpcmVjdGlvblRvTGlnaHQ9bm9ybWFsaXplKGRpcmVjdGlvblRvTGlnaHQpO2RpcmVjdGlvblRvTGlnaHQueT0tZGlyZWN0aW9uVG9MaWdodC55O1xuI2lmbmRlZiBTSEFET1dGTE9BVFxuZmxvYXQgc2hhZG93TWFwU2FtcGxlPXVucGFjayh0ZXh0dXJlQ3ViZShzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQpKTtcbiNlbHNlXG5mbG9hdCBzaGFkb3dNYXBTYW1wbGU9dGV4dHVyZUN1YmUoc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0KS54O1xuI2VuZGlmXG5mbG9hdCBlc209MS4wLWNsYW1wKGV4cChtaW4oODcuLGRlcHRoU2NhbGUqc2hhZG93UGl4ZWxEZXB0aCkpKnNoYWRvd01hcFNhbXBsZSwwLiwxLi1kYXJrbmVzcyk7cmV0dXJuIGVzbTt9XG4jZGVmaW5lIGlubGluZVxuZmxvYXQgY29tcHV0ZVNoYWRvd1dpdGhDbG9zZUVTTUN1YmUodmVjMyB3b3JsZFBvcyx2ZWMzIGxpZ2h0UG9zaXRpb24sc2FtcGxlckN1YmUgc2hhZG93U2FtcGxlcixmbG9hdCBkYXJrbmVzcyxmbG9hdCBkZXB0aFNjYWxlLHZlYzIgZGVwdGhWYWx1ZXMpXG57dmVjMyBkaXJlY3Rpb25Ub0xpZ2h0PXdvcmxkUG9zLWxpZ2h0UG9zaXRpb247ZmxvYXQgZGVwdGg9bGVuZ3RoKGRpcmVjdGlvblRvTGlnaHQpO2RlcHRoPShkZXB0aCtkZXB0aFZhbHVlcy54KS8oZGVwdGhWYWx1ZXMueSk7ZmxvYXQgc2hhZG93UGl4ZWxEZXB0aD1jbGFtcChkZXB0aCwwLiwxLjApO2RpcmVjdGlvblRvTGlnaHQ9bm9ybWFsaXplKGRpcmVjdGlvblRvTGlnaHQpO2RpcmVjdGlvblRvTGlnaHQueT0tZGlyZWN0aW9uVG9MaWdodC55O1xuI2lmbmRlZiBTSEFET1dGTE9BVFxuZmxvYXQgc2hhZG93TWFwU2FtcGxlPXVucGFjayh0ZXh0dXJlQ3ViZShzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQpKTtcbiNlbHNlXG5mbG9hdCBzaGFkb3dNYXBTYW1wbGU9dGV4dHVyZUN1YmUoc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0KS54O1xuI2VuZGlmXG5mbG9hdCBlc209Y2xhbXAoZXhwKG1pbig4Ny4sLWRlcHRoU2NhbGUqKHNoYWRvd1BpeGVsRGVwdGgtc2hhZG93TWFwU2FtcGxlKSkpLGRhcmtuZXNzLDEuKTtyZXR1cm4gZXNtO31cbiNpZiBkZWZpbmVkKFdFQkdMMikgfHwgZGVmaW5lZChXRUJHUFUpIHx8IGRlZmluZWQoTkFUSVZFKVxuI2RlZmluZSBpbmxpbmVcbmZsb2F0IGNvbXB1dGVTaGFkb3dDU00oZmxvYXQgbGF5ZXIsdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsZmxvYXQgZGVwdGhNZXRyaWMsaGlnaHAgc2FtcGxlcjJEQXJyYXkgc2hhZG93U2FtcGxlcixmbG9hdCBkYXJrbmVzcyxmbG9hdCBmcnVzdHVtRWRnZUZhbGxvZmYpXG57dmVjMyBjbGlwU3BhY2U9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2ZWMyIHV2PTAuNSpjbGlwU3BhY2UueHkrdmVjMigwLjUpO3ZlYzMgdXZMYXllcj12ZWMzKHV2LngsdXYueSxsYXllcik7ZmxvYXQgc2hhZG93UGl4ZWxEZXB0aD1jbGFtcChkZXB0aE1ldHJpYywwLiwxLjApO1xuI2lmbmRlZiBTSEFET1dGTE9BVFxuZmxvYXQgc2hhZG93PXVucGFjayh0ZXh0dXJlMkQoc2hhZG93U2FtcGxlcix1dkxheWVyKSk7XG4jZWxzZVxuZmxvYXQgc2hhZG93PXRleHR1cmUyRChzaGFkb3dTYW1wbGVyLHV2TGF5ZXIpLng7XG4jZW5kaWZcbnJldHVybiBzaGFkb3dQaXhlbERlcHRoPnNoYWRvdyA/IGNvbXB1dGVGYWxsT2ZmKGRhcmtuZXNzLGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpIDogMS47fVxuI2VuZGlmXG4jZGVmaW5lIGlubGluZVxuZmxvYXQgY29tcHV0ZVNoYWRvdyh2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCxmbG9hdCBkZXB0aE1ldHJpYyxzYW1wbGVyMkQgc2hhZG93U2FtcGxlcixmbG9hdCBkYXJrbmVzcyxmbG9hdCBmcnVzdHVtRWRnZUZhbGxvZmYpXG57dmVjMyBjbGlwU3BhY2U9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2ZWMyIHV2PTAuNSpjbGlwU3BhY2UueHkrdmVjMigwLjUpO2lmICh1di54PDAuIHx8IHV2Lng+MS4wIHx8IHV2Lnk8MC4gfHwgdXYueT4xLjApXG57cmV0dXJuIDEuMDt9XG5lbHNlXG57ZmxvYXQgc2hhZG93UGl4ZWxEZXB0aD1jbGFtcChkZXB0aE1ldHJpYywwLiwxLjApO1xuI2lmbmRlZiBTSEFET1dGTE9BVFxuZmxvYXQgc2hhZG93PXVucGFjayhURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHV2LDAuKSk7XG4jZWxzZVxuZmxvYXQgc2hhZG93PVRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdXYsMC4pLng7XG4jZW5kaWZcbnJldHVybiBzaGFkb3dQaXhlbERlcHRoPnNoYWRvdyA/IGNvbXB1dGVGYWxsT2ZmKGRhcmtuZXNzLGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpIDogMS47fX1cbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aFBvaXNzb25TYW1wbGluZyh2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCxmbG9hdCBkZXB0aE1ldHJpYyxzYW1wbGVyMkQgc2hhZG93U2FtcGxlcixmbG9hdCBtYXBTaXplLGZsb2F0IGRhcmtuZXNzLGZsb2F0IGZydXN0dW1FZGdlRmFsbG9mZilcbnt2ZWMzIGNsaXBTcGFjZT12UG9zaXRpb25Gcm9tTGlnaHQueHl6L3ZQb3NpdGlvbkZyb21MaWdodC53O3ZlYzIgdXY9MC41KmNsaXBTcGFjZS54eSt2ZWMyKDAuNSk7aWYgKHV2Lng8MC4gfHwgdXYueD4xLjAgfHwgdXYueTwwLiB8fCB1di55PjEuMClcbntyZXR1cm4gMS4wO31cbmVsc2VcbntmbG9hdCBzaGFkb3dQaXhlbERlcHRoPWNsYW1wKGRlcHRoTWV0cmljLDAuLDEuMCk7ZmxvYXQgdmlzaWJpbGl0eT0xLjt2ZWMyIHBvaXNzb25EaXNrWzRdO3BvaXNzb25EaXNrWzBdPXZlYzIoLTAuOTQyMDE2MjQsLTAuMzk5MDYyMTYpO3BvaXNzb25EaXNrWzFdPXZlYzIoMC45NDU1ODYwOSwtMC43Njg5MDcyNSk7cG9pc3NvbkRpc2tbMl09dmVjMigtMC4wOTQxODQxMDEsLTAuOTI5Mzg4NzApO3BvaXNzb25EaXNrWzNdPXZlYzIoMC4zNDQ5NTkzOCwwLjI5Mzg3NzYwKTtcbiNpZm5kZWYgU0hBRE9XRkxPQVRcbmlmICh1bnBhY2soVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix1ditwb2lzc29uRGlza1swXSptYXBTaXplLDAuKSk8c2hhZG93UGl4ZWxEZXB0aCkgdmlzaWJpbGl0eS09MC4yNTtpZiAodW5wYWNrKFRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdXYrcG9pc3NvbkRpc2tbMV0qbWFwU2l6ZSwwLikpPHNoYWRvd1BpeGVsRGVwdGgpIHZpc2liaWxpdHktPTAuMjU7aWYgKHVucGFjayhURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHV2K3BvaXNzb25EaXNrWzJdKm1hcFNpemUsMC4pKTxzaGFkb3dQaXhlbERlcHRoKSB2aXNpYmlsaXR5LT0wLjI1O2lmICh1bnBhY2soVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix1ditwb2lzc29uRGlza1szXSptYXBTaXplLDAuKSk8c2hhZG93UGl4ZWxEZXB0aCkgdmlzaWJpbGl0eS09MC4yNTtcbiNlbHNlXG5pZiAoVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix1ditwb2lzc29uRGlza1swXSptYXBTaXplLDAuKS54PHNoYWRvd1BpeGVsRGVwdGgpIHZpc2liaWxpdHktPTAuMjU7aWYgKFRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdXYrcG9pc3NvbkRpc2tbMV0qbWFwU2l6ZSwwLikueDxzaGFkb3dQaXhlbERlcHRoKSB2aXNpYmlsaXR5LT0wLjI1O2lmIChURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHV2K3BvaXNzb25EaXNrWzJdKm1hcFNpemUsMC4pLng8c2hhZG93UGl4ZWxEZXB0aCkgdmlzaWJpbGl0eS09MC4yNTtpZiAoVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix1ditwb2lzc29uRGlza1szXSptYXBTaXplLDAuKS54PHNoYWRvd1BpeGVsRGVwdGgpIHZpc2liaWxpdHktPTAuMjU7XG4jZW5kaWZcbnJldHVybiBjb21wdXRlRmFsbE9mZihtaW4oMS4wLHZpc2liaWxpdHkrZGFya25lc3MpLGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpO319XG4jZGVmaW5lIGlubGluZVxuZmxvYXQgY29tcHV0ZVNoYWRvd1dpdGhFU00odmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsZmxvYXQgZGVwdGhNZXRyaWMsc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIsZmxvYXQgZGFya25lc3MsZmxvYXQgZGVwdGhTY2FsZSxmbG9hdCBmcnVzdHVtRWRnZUZhbGxvZmYpXG57dmVjMyBjbGlwU3BhY2U9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2ZWMyIHV2PTAuNSpjbGlwU3BhY2UueHkrdmVjMigwLjUpO2lmICh1di54PDAuIHx8IHV2Lng+MS4wIHx8IHV2Lnk8MC4gfHwgdXYueT4xLjApXG57cmV0dXJuIDEuMDt9XG5lbHNlXG57ZmxvYXQgc2hhZG93UGl4ZWxEZXB0aD1jbGFtcChkZXB0aE1ldHJpYywwLiwxLjApO1xuI2lmbmRlZiBTSEFET1dGTE9BVFxuZmxvYXQgc2hhZG93TWFwU2FtcGxlPXVucGFjayhURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHV2LDAuKSk7XG4jZWxzZVxuZmxvYXQgc2hhZG93TWFwU2FtcGxlPVRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdXYsMC4pLng7XG4jZW5kaWZcbmZsb2F0IGVzbT0xLjAtY2xhbXAoZXhwKG1pbig4Ny4sZGVwdGhTY2FsZSpzaGFkb3dQaXhlbERlcHRoKSkqc2hhZG93TWFwU2FtcGxlLDAuLDEuLWRhcmtuZXNzKTtyZXR1cm4gY29tcHV0ZUZhbGxPZmYoZXNtLGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpO319XG4jZGVmaW5lIGlubGluZVxuZmxvYXQgY29tcHV0ZVNoYWRvd1dpdGhDbG9zZUVTTSh2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCxmbG9hdCBkZXB0aE1ldHJpYyxzYW1wbGVyMkQgc2hhZG93U2FtcGxlcixmbG9hdCBkYXJrbmVzcyxmbG9hdCBkZXB0aFNjYWxlLGZsb2F0IGZydXN0dW1FZGdlRmFsbG9mZilcbnt2ZWMzIGNsaXBTcGFjZT12UG9zaXRpb25Gcm9tTGlnaHQueHl6L3ZQb3NpdGlvbkZyb21MaWdodC53O3ZlYzIgdXY9MC41KmNsaXBTcGFjZS54eSt2ZWMyKDAuNSk7aWYgKHV2Lng8MC4gfHwgdXYueD4xLjAgfHwgdXYueTwwLiB8fCB1di55PjEuMClcbntyZXR1cm4gMS4wO31cbmVsc2VcbntmbG9hdCBzaGFkb3dQaXhlbERlcHRoPWNsYW1wKGRlcHRoTWV0cmljLDAuLDEuMCk7IFxuI2lmbmRlZiBTSEFET1dGTE9BVFxuZmxvYXQgc2hhZG93TWFwU2FtcGxlPXVucGFjayhURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHV2LDAuKSk7XG4jZWxzZVxuZmxvYXQgc2hhZG93TWFwU2FtcGxlPVRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdXYsMC4pLng7XG4jZW5kaWZcbmZsb2F0IGVzbT1jbGFtcChleHAobWluKDg3LiwtZGVwdGhTY2FsZSooc2hhZG93UGl4ZWxEZXB0aC1zaGFkb3dNYXBTYW1wbGUpKSksZGFya25lc3MsMS4pO3JldHVybiBjb21wdXRlRmFsbE9mZihlc20sY2xpcFNwYWNlLnh5LGZydXN0dW1FZGdlRmFsbG9mZik7fX1cbiNpZmRlZiBJU19ORENfSEFMRl9aUkFOR0VcbiNkZWZpbmUgWklOQ0xJUCBjbGlwU3BhY2UuelxuI2Vsc2VcbiNkZWZpbmUgWklOQ0xJUCB1dkRlcHRoLnpcbiNlbmRpZlxuI2lmIGRlZmluZWQoV0VCR0wyKSB8fCBkZWZpbmVkKFdFQkdQVSkgfHwgZGVmaW5lZChOQVRJVkUpXG4jZGVmaW5lIEdSRUFURVNUX0xFU1NfVEhBTl9PTkUgMC45OTk5OTk5NFxuI2RlZmluZSBESVNBQkxFX1VOSUZPUk1JVFlfQU5BTFlTSVNcbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aENTTVBDRjEoZmxvYXQgbGF5ZXIsdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsZmxvYXQgZGVwdGhNZXRyaWMsaGlnaHAgc2FtcGxlcjJEQXJyYXlTaGFkb3cgc2hhZG93U2FtcGxlcixmbG9hdCBkYXJrbmVzcyxmbG9hdCBmcnVzdHVtRWRnZUZhbGxvZmYpXG57dmVjMyBjbGlwU3BhY2U9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2ZWMzIHV2RGVwdGg9dmVjMygwLjUqY2xpcFNwYWNlLnh5eit2ZWMzKDAuNSkpO3V2RGVwdGguej1jbGFtcChaSU5DTElQLDAuLEdSRUFURVNUX0xFU1NfVEhBTl9PTkUpO3ZlYzQgdXZEZXB0aExheWVyPXZlYzQodXZEZXB0aC54LHV2RGVwdGgueSxsYXllcix1dkRlcHRoLnopO2Zsb2F0IHNoYWRvdz10ZXh0dXJlMkQoc2hhZG93U2FtcGxlcix1dkRlcHRoTGF5ZXIpO3NoYWRvdz1taXgoZGFya25lc3MsMS4sc2hhZG93KTtyZXR1cm4gY29tcHV0ZUZhbGxPZmYoc2hhZG93LGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpO31cbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aENTTVBDRjMoZmxvYXQgbGF5ZXIsdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsZmxvYXQgZGVwdGhNZXRyaWMsaGlnaHAgc2FtcGxlcjJEQXJyYXlTaGFkb3cgc2hhZG93U2FtcGxlcix2ZWMyIHNoYWRvd01hcFNpemVBbmRJbnZlcnNlLGZsb2F0IGRhcmtuZXNzLGZsb2F0IGZydXN0dW1FZGdlRmFsbG9mZilcbnt2ZWMzIGNsaXBTcGFjZT12UG9zaXRpb25Gcm9tTGlnaHQueHl6L3ZQb3NpdGlvbkZyb21MaWdodC53O3ZlYzMgdXZEZXB0aD12ZWMzKDAuNSpjbGlwU3BhY2UueHl6K3ZlYzMoMC41KSk7dXZEZXB0aC56PWNsYW1wKFpJTkNMSVAsMC4sR1JFQVRFU1RfTEVTU19USEFOX09ORSk7dmVjMiB1dj11dkRlcHRoLnh5KnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLng7IFxudXYrPTAuNTsgXG52ZWMyIHN0PWZyYWN0KHV2KTsgXG52ZWMyIGJhc2VfdXY9Zmxvb3IodXYpLTAuNTsgXG5iYXNlX3V2Kj1zaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55OyBcbnZlYzIgdXZ3MD0zLi0yLipzdDt2ZWMyIHV2dzE9MS4rMi4qc3Q7dmVjMiB1PXZlYzIoKDIuLXN0LngpL3V2dzAueC0xLixzdC54L3V2dzEueCsxLikqc2hhZG93TWFwU2l6ZUFuZEludmVyc2UueTt2ZWMyIHY9dmVjMigoMi4tc3QueSkvdXZ3MC55LTEuLHN0LnkvdXZ3MS55KzEuKSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55O2Zsb2F0IHNoYWRvdz0wLjtzaGFkb3crPXV2dzAueCp1dncwLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVswXSx2WzBdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzEueCp1dncwLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVsxXSx2WzBdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzAueCp1dncxLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVswXSx2WzFdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzEueCp1dncxLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVsxXSx2WzFdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3c9c2hhZG93LzE2LjtzaGFkb3c9bWl4KGRhcmtuZXNzLDEuLHNoYWRvdyk7cmV0dXJuIGNvbXB1dGVGYWxsT2ZmKHNoYWRvdyxjbGlwU3BhY2UueHksZnJ1c3R1bUVkZ2VGYWxsb2ZmKTt9XG4jZGVmaW5lIGlubGluZVxuZmxvYXQgY29tcHV0ZVNoYWRvd1dpdGhDU01QQ0Y1KGZsb2F0IGxheWVyLHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LGZsb2F0IGRlcHRoTWV0cmljLGhpZ2hwIHNhbXBsZXIyREFycmF5U2hhZG93IHNoYWRvd1NhbXBsZXIsdmVjMiBzaGFkb3dNYXBTaXplQW5kSW52ZXJzZSxmbG9hdCBkYXJrbmVzcyxmbG9hdCBmcnVzdHVtRWRnZUZhbGxvZmYpXG57dmVjMyBjbGlwU3BhY2U9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2ZWMzIHV2RGVwdGg9dmVjMygwLjUqY2xpcFNwYWNlLnh5eit2ZWMzKDAuNSkpO3V2RGVwdGguej1jbGFtcChaSU5DTElQLDAuLEdSRUFURVNUX0xFU1NfVEhBTl9PTkUpO3ZlYzIgdXY9dXZEZXB0aC54eSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS54OyBcbnV2Kz0wLjU7IFxudmVjMiBzdD1mcmFjdCh1dik7IFxudmVjMiBiYXNlX3V2PWZsb29yKHV2KS0wLjU7IFxuYmFzZV91dio9c2hhZG93TWFwU2l6ZUFuZEludmVyc2UueTsgXG52ZWMyIHV2dzA9NC4tMy4qc3Q7dmVjMiB1dncxPXZlYzIoNy4pO3ZlYzIgdXZ3Mj0xLiszLipzdDt2ZWMzIHU9dmVjMygoMy4tMi4qc3QueCkvdXZ3MC54LTIuLCgzLitzdC54KS91dncxLngsc3QueC91dncyLngrMi4pKnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLnk7dmVjMyB2PXZlYzMoKDMuLTIuKnN0LnkpL3V2dzAueS0yLiwoMy4rc3QueSkvdXZ3MS55LHN0LnkvdXZ3Mi55KzIuKSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55O2Zsb2F0IHNoYWRvdz0wLjtzaGFkb3crPXV2dzAueCp1dncwLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVswXSx2WzBdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzEueCp1dncwLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVsxXSx2WzBdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzIueCp1dncwLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVsyXSx2WzBdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzAueCp1dncxLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVswXSx2WzFdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzEueCp1dncxLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVsxXSx2WzFdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzIueCp1dncxLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVsyXSx2WzFdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzAueCp1dncyLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVswXSx2WzJdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzEueCp1dncyLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVsxXSx2WzJdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3crPXV2dzIueCp1dncyLnkqdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsdmVjNChiYXNlX3V2Lnh5K3ZlYzIodVsyXSx2WzJdKSxsYXllcix1dkRlcHRoLnopKTtzaGFkb3c9c2hhZG93LzE0NC47c2hhZG93PW1peChkYXJrbmVzcywxLixzaGFkb3cpO3JldHVybiBjb21wdXRlRmFsbE9mZihzaGFkb3csY2xpcFNwYWNlLnh5LGZydXN0dW1FZGdlRmFsbG9mZik7fVxuI2RlZmluZSBpbmxpbmVcbmZsb2F0IGNvbXB1dGVTaGFkb3dXaXRoUENGMSh2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCxmbG9hdCBkZXB0aE1ldHJpYyxoaWdocCBzYW1wbGVyMkRTaGFkb3cgc2hhZG93U2FtcGxlcixmbG9hdCBkYXJrbmVzcyxmbG9hdCBmcnVzdHVtRWRnZUZhbGxvZmYpXG57aWYgKGRlcHRoTWV0cmljPjEuMCB8fCBkZXB0aE1ldHJpYzwwLjApIHtyZXR1cm4gMS4wO31cbmVsc2Vcbnt2ZWMzIGNsaXBTcGFjZT12UG9zaXRpb25Gcm9tTGlnaHQueHl6L3ZQb3NpdGlvbkZyb21MaWdodC53O3ZlYzMgdXZEZXB0aD12ZWMzKDAuNSpjbGlwU3BhY2UueHl6K3ZlYzMoMC41KSk7dXZEZXB0aC56PVpJTkNMSVA7ZmxvYXQgc2hhZG93PVRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdXZEZXB0aCwwLik7c2hhZG93PW1peChkYXJrbmVzcywxLixzaGFkb3cpO3JldHVybiBjb21wdXRlRmFsbE9mZihzaGFkb3csY2xpcFNwYWNlLnh5LGZydXN0dW1FZGdlRmFsbG9mZik7fX1cbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aFBDRjModmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsZmxvYXQgZGVwdGhNZXRyaWMsaGlnaHAgc2FtcGxlcjJEU2hhZG93IHNoYWRvd1NhbXBsZXIsdmVjMiBzaGFkb3dNYXBTaXplQW5kSW52ZXJzZSxmbG9hdCBkYXJrbmVzcyxmbG9hdCBmcnVzdHVtRWRnZUZhbGxvZmYpXG57aWYgKGRlcHRoTWV0cmljPjEuMCB8fCBkZXB0aE1ldHJpYzwwLjApIHtyZXR1cm4gMS4wO31cbmVsc2Vcbnt2ZWMzIGNsaXBTcGFjZT12UG9zaXRpb25Gcm9tTGlnaHQueHl6L3ZQb3NpdGlvbkZyb21MaWdodC53O3ZlYzMgdXZEZXB0aD12ZWMzKDAuNSpjbGlwU3BhY2UueHl6K3ZlYzMoMC41KSk7dXZEZXB0aC56PVpJTkNMSVA7dmVjMiB1dj11dkRlcHRoLnh5KnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLng7IFxudXYrPTAuNTsgXG52ZWMyIHN0PWZyYWN0KHV2KTsgXG52ZWMyIGJhc2VfdXY9Zmxvb3IodXYpLTAuNTsgXG5iYXNlX3V2Kj1zaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55OyBcbnZlYzIgdXZ3MD0zLi0yLipzdDt2ZWMyIHV2dzE9MS4rMi4qc3Q7dmVjMiB1PXZlYzIoKDIuLXN0LngpL3V2dzAueC0xLixzdC54L3V2dzEueCsxLikqc2hhZG93TWFwU2l6ZUFuZEludmVyc2UueTt2ZWMyIHY9dmVjMigoMi4tc3QueSkvdXZ3MC55LTEuLHN0LnkvdXZ3MS55KzEuKSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55O2Zsb2F0IHNoYWRvdz0wLjtzaGFkb3crPXV2dzAueCp1dncwLnkqVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix2ZWMzKGJhc2VfdXYueHkrdmVjMih1WzBdLHZbMF0pLHV2RGVwdGgueiksMC4pO3NoYWRvdys9dXZ3MS54KnV2dzAueSpURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHZlYzMoYmFzZV91di54eSt2ZWMyKHVbMV0sdlswXSksdXZEZXB0aC56KSwwLik7c2hhZG93Kz11dncwLngqdXZ3MS55KlRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdmVjMyhiYXNlX3V2Lnh5K3ZlYzIodVswXSx2WzFdKSx1dkRlcHRoLnopLDAuKTtzaGFkb3crPXV2dzEueCp1dncxLnkqVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix2ZWMzKGJhc2VfdXYueHkrdmVjMih1WzFdLHZbMV0pLHV2RGVwdGgueiksMC4pO3NoYWRvdz1zaGFkb3cvMTYuO3NoYWRvdz1taXgoZGFya25lc3MsMS4sc2hhZG93KTtyZXR1cm4gY29tcHV0ZUZhbGxPZmYoc2hhZG93LGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpO319XG4jZGVmaW5lIGlubGluZVxuZmxvYXQgY29tcHV0ZVNoYWRvd1dpdGhQQ0Y1KHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LGZsb2F0IGRlcHRoTWV0cmljLGhpZ2hwIHNhbXBsZXIyRFNoYWRvdyBzaGFkb3dTYW1wbGVyLHZlYzIgc2hhZG93TWFwU2l6ZUFuZEludmVyc2UsZmxvYXQgZGFya25lc3MsZmxvYXQgZnJ1c3R1bUVkZ2VGYWxsb2ZmKVxue2lmIChkZXB0aE1ldHJpYz4xLjAgfHwgZGVwdGhNZXRyaWM8MC4wKSB7cmV0dXJuIDEuMDt9XG5lbHNlXG57dmVjMyBjbGlwU3BhY2U9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2ZWMzIHV2RGVwdGg9dmVjMygwLjUqY2xpcFNwYWNlLnh5eit2ZWMzKDAuNSkpO3V2RGVwdGguej1aSU5DTElQO3ZlYzIgdXY9dXZEZXB0aC54eSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS54OyBcbnV2Kz0wLjU7IFxudmVjMiBzdD1mcmFjdCh1dik7IFxudmVjMiBiYXNlX3V2PWZsb29yKHV2KS0wLjU7IFxuYmFzZV91dio9c2hhZG93TWFwU2l6ZUFuZEludmVyc2UueTsgXG52ZWMyIHV2dzA9NC4tMy4qc3Q7dmVjMiB1dncxPXZlYzIoNy4pO3ZlYzIgdXZ3Mj0xLiszLipzdDt2ZWMzIHU9dmVjMygoMy4tMi4qc3QueCkvdXZ3MC54LTIuLCgzLitzdC54KS91dncxLngsc3QueC91dncyLngrMi4pKnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLnk7dmVjMyB2PXZlYzMoKDMuLTIuKnN0LnkpL3V2dzAueS0yLiwoMy4rc3QueSkvdXZ3MS55LHN0LnkvdXZ3Mi55KzIuKSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55O2Zsb2F0IHNoYWRvdz0wLjtzaGFkb3crPXV2dzAueCp1dncwLnkqVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix2ZWMzKGJhc2VfdXYueHkrdmVjMih1WzBdLHZbMF0pLHV2RGVwdGgueiksMC4pO3NoYWRvdys9dXZ3MS54KnV2dzAueSpURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHZlYzMoYmFzZV91di54eSt2ZWMyKHVbMV0sdlswXSksdXZEZXB0aC56KSwwLik7c2hhZG93Kz11dncyLngqdXZ3MC55KlRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdmVjMyhiYXNlX3V2Lnh5K3ZlYzIodVsyXSx2WzBdKSx1dkRlcHRoLnopLDAuKTtzaGFkb3crPXV2dzAueCp1dncxLnkqVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix2ZWMzKGJhc2VfdXYueHkrdmVjMih1WzBdLHZbMV0pLHV2RGVwdGgueiksMC4pO3NoYWRvdys9dXZ3MS54KnV2dzEueSpURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHZlYzMoYmFzZV91di54eSt2ZWMyKHVbMV0sdlsxXSksdXZEZXB0aC56KSwwLik7c2hhZG93Kz11dncyLngqdXZ3MS55KlRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdmVjMyhiYXNlX3V2Lnh5K3ZlYzIodVsyXSx2WzFdKSx1dkRlcHRoLnopLDAuKTtzaGFkb3crPXV2dzAueCp1dncyLnkqVEVYVFVSRUZVTkMoc2hhZG93U2FtcGxlcix2ZWMzKGJhc2VfdXYueHkrdmVjMih1WzBdLHZbMl0pLHV2RGVwdGgueiksMC4pO3NoYWRvdys9dXZ3MS54KnV2dzIueSpURVhUVVJFRlVOQyhzaGFkb3dTYW1wbGVyLHZlYzMoYmFzZV91di54eSt2ZWMyKHVbMV0sdlsyXSksdXZEZXB0aC56KSwwLik7c2hhZG93Kz11dncyLngqdXZ3Mi55KlRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdmVjMyhiYXNlX3V2Lnh5K3ZlYzIodVsyXSx2WzJdKSx1dkRlcHRoLnopLDAuKTtzaGFkb3c9c2hhZG93LzE0NC47c2hhZG93PW1peChkYXJrbmVzcywxLixzaGFkb3cpO3JldHVybiBjb21wdXRlRmFsbE9mZihzaGFkb3csY2xpcFNwYWNlLnh5LGZydXN0dW1FZGdlRmFsbG9mZik7fX1cbmNvbnN0IHZlYzMgUG9pc3NvblNhbXBsZXJzMzJbNjRdPXZlYzNbNjRdKFxudmVjMygwLjA2NDA3MDEzLDAuMDU0MDk5MjcsMC4pLFxudmVjMygwLjczNjY1NzcsMC41Nzg5Mzk0LDAuKSxcbnZlYzMoLTAuNjI3MDU0MiwtMC41MzIwMjc4LDAuKSxcbnZlYzMoLTAuNDA5NjEwNywwLjg0MTEwOTUsMC4pLFxudmVjMygwLjY4NDk1NjQsLTAuNDk5MDgxOCwwLiksXG52ZWMzKC0wLjg3NDE4MSwtMC4wNDU3OTczNSwwLiksXG52ZWMzKDAuOTk4OTk5OCwwLjAwMDk4ODAwNjYsMC4pLFxudmVjMygtMC4wMDQ5MjA1NzgsLTAuOTE1MTY0OSwwLiksXG52ZWMzKDAuMTgwNTc2MywwLjk3NDc0ODMsMC4pLFxudmVjMygtMC4yMTM4NDUxLDAuMjYzNTgxOCwwLiksXG52ZWMzKDAuMTA5ODQ1LDAuMzg4NDc4NSwwLiksXG52ZWMzKDAuMDY4NzY3NTUsLTAuMzU4MTA3NCwwLiksXG52ZWMzKDAuMzc0MDczLC0wLjc2NjEyNjYsMC4pLFxudmVjMygwLjMwNzkxMzIsLTAuMTIxNjc2MywwLiksXG52ZWMzKC0wLjM3OTQzMzUsLTAuODI3MTU4MywwLiksXG52ZWMzKC0wLjIwMzg3OCwtMC4wNzcxNTAzNCwwLiksXG52ZWMzKDAuNTkxMjY5NywwLjE0Njk3OTksMC4pLFxudmVjMygtMC44ODA2OSwwLjMwMzE3ODQsMC4pLFxudmVjMygwLjUwNDAxMDgsMC44MjgzNzIyLDAuKSxcbnZlYzMoLTAuNTg0NDEyNCwwLjU0OTQ4NzcsMC4pLFxudmVjMygwLjYwMTc3OTksLTAuMTcyNjY1NCwwLiksXG52ZWMzKC0wLjU1NTQ5ODEsMC4xNTU5OTk3LDAuKSxcbnZlYzMoLTAuMzAxNjM2OSwtMC4zOTAwOTI4LDAuKSxcbnZlYzMoLTAuNTU1MDYzMiwtMC4xNzIzNzYyLDAuKSxcbnZlYzMoMC45MjUwMjksMC4yOTk1MDQxLDAuKSxcbnZlYzMoLTAuMjQ3MzEzNywwLjU1Mzg1MDUsMC4pLFxudmVjMygwLjkxODMwMzcsLTAuMjg2MjM5MiwwLiksXG52ZWMzKDAuMjQ2OTQyMSwwLjY3MTg3MTIsMC4pLFxudmVjMygwLjM5MTYzOTcsLTAuNDMyODIwOSwwLiksXG52ZWMzKC0wLjAzNTc2OTI3LC0wLjYyMjAwMzIsMC4pLFxudmVjMygtMC4wNDY2MTI1NSwwLjc5OTUyMDEsMC4pLFxudmVjMygwLjQ0MDI5MjQsMC4zNjQwMzEyLDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLiksXG52ZWMzKDAuKSxcbnZlYzMoMC4pLFxudmVjMygwLilcbik7Y29uc3QgdmVjMyBQb2lzc29uU2FtcGxlcnM2NFs2NF09dmVjM1s2NF0oXG52ZWMzKC0wLjYxMzM5MiwwLjYxNzQ4MSwwLiksXG52ZWMzKDAuMTcwMDE5LC0wLjA0MDI1NCwwLiksXG52ZWMzKC0wLjI5OTQxNywwLjc5MTkyNSwwLiksXG52ZWMzKDAuNjQ1NjgwLDAuNDkzMjEwLDAuKSxcbnZlYzMoLTAuNjUxNzg0LDAuNzE3ODg3LDAuKSxcbnZlYzMoMC40MjEwMDMsMC4wMjcwNzAsMC4pLFxudmVjMygtMC44MTcxOTQsLTAuMjcxMDk2LDAuKSxcbnZlYzMoLTAuNzA1Mzc0LC0wLjY2ODIwMywwLiksXG52ZWMzKDAuOTc3MDUwLC0wLjEwODYxNSwwLiksXG52ZWMzKDAuMDYzMzI2LDAuMTQyMzY5LDAuKSxcbnZlYzMoMC4yMDM1MjgsMC4yMTQzMzEsMC4pLFxudmVjMygtMC42Njc1MzEsMC4zMjYwOTAsMC4pLFxudmVjMygtMC4wOTg0MjIsLTAuMjk1NzU1LDAuKSxcbnZlYzMoLTAuODg1OTIyLDAuMjE1MzY5LDAuKSxcbnZlYzMoMC41NjY2MzcsMC42MDUyMTMsMC4pLFxudmVjMygwLjAzOTc2NiwtMC4zOTYxMDAsMC4pLFxudmVjMygwLjc1MTk0NiwwLjQ1MzM1MiwwLiksXG52ZWMzKDAuMDc4NzA3LC0wLjcxNTMyMywwLiksXG52ZWMzKC0wLjA3NTgzOCwtMC41MjkzNDQsMC4pLFxudmVjMygwLjcyNDQ3OSwtMC41ODA3OTgsMC4pLFxudmVjMygwLjIyMjk5OSwtMC4yMTUxMjUsMC4pLFxudmVjMygtMC40Njc1NzQsLTAuNDA1NDM4LDAuKSxcbnZlYzMoLTAuMjQ4MjY4LC0wLjgxNDc1MywwLiksXG52ZWMzKDAuMzU0NDExLC0wLjg4NzU3MCwwLiksXG52ZWMzKDAuMTc1ODE3LDAuMzgyMzY2LDAuKSxcbnZlYzMoMC40ODc0NzIsLTAuMDYzMDgyLDAuKSxcbnZlYzMoLTAuMDg0MDc4LDAuODk4MzEyLDAuKSxcbnZlYzMoMC40ODg4NzYsLTAuNzgzNDQxLDAuKSxcbnZlYzMoMC40NzAwMTYsMC4yMTc5MzMsMC4pLFxudmVjMygtMC42OTY4OTAsLTAuNTQ5NzkxLDAuKSxcbnZlYzMoLTAuMTQ5NjkzLDAuNjA1NzYyLDAuKSxcbnZlYzMoMC4wMzQyMTEsMC45Nzk5ODAsMC4pLFxudmVjMygwLjUwMzA5OCwtMC4zMDg4NzgsMC4pLFxudmVjMygtMC4wMTYyMDUsLTAuODcyOTIxLDAuKSxcbnZlYzMoMC4zODU3ODQsLTAuMzkzOTAyLDAuKSxcbnZlYzMoLTAuMTQ2ODg2LC0wLjg1OTI0OSwwLiksXG52ZWMzKDAuNjQzMzYxLDAuMTY0MDk4LDAuKSxcbnZlYzMoMC42MzQzODgsLTAuMDQ5NDcxLDAuKSxcbnZlYzMoLTAuNjg4ODk0LDAuMDA3ODQzLDAuKSxcbnZlYzMoMC40NjQwMzQsLTAuMTg4ODE4LDAuKSxcbnZlYzMoLTAuNDQwODQwLDAuMTM3NDg2LDAuKSxcbnZlYzMoMC4zNjQ0ODMsMC41MTE3MDQsMC4pLFxudmVjMygwLjAzNDAyOCwwLjMyNTk2OCwwLiksXG52ZWMzKDAuMDk5MDk0LC0wLjMwODAyMywwLiksXG52ZWMzKDAuNjkzOTYwLC0wLjM2NjI1MywwLiksXG52ZWMzKDAuNjc4ODg0LC0wLjIwNDY4OCwwLiksXG52ZWMzKDAuMDAxODAxLDAuNzgwMzI4LDAuKSxcbnZlYzMoMC4xNDUxNzcsLTAuODk4OTg0LDAuKSxcbnZlYzMoMC4wNjI2NTUsLTAuNjExODY2LDAuKSxcbnZlYzMoMC4zMTUyMjYsLTAuNjA0Mjk3LDAuKSxcbnZlYzMoLTAuNzgwMTQ1LDAuNDg2MjUxLDAuKSxcbnZlYzMoLTAuMzcxODY4LDAuODgyMTM4LDAuKSxcbnZlYzMoMC4yMDA0NzYsMC40OTQ0MzAsMC4pLFxudmVjMygtMC40OTQ1NTIsLTAuNzExMDUxLDAuKSxcbnZlYzMoMC42MTI0NzYsMC43MDUyNTIsMC4pLFxudmVjMygtMC41Nzg4NDUsLTAuNzY4NzkyLDAuKSxcbnZlYzMoLTAuNzcyNDU0LC0wLjA5MDk3NiwwLiksXG52ZWMzKDAuNTA0NDQwLDAuMzcyMjk1LDAuKSxcbnZlYzMoMC4xNTU3MzYsMC4wNjUxNTcsMC4pLFxudmVjMygwLjM5MTUyMiwwLjg0OTYwNSwwLiksXG52ZWMzKC0wLjYyMDEwNiwtMC4zMjgxMDQsMC4pLFxudmVjMygwLjc4OTIzOSwtMC40MTk5NjUsMC4pLFxudmVjMygtMC41NDUzOTYsMC41MzgxMzMsMC4pLFxudmVjMygtMC4xNzg1NjQsLTAuNTk2MDU3LDAuKVxuKTtcbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aENTTVBDU1MoZmxvYXQgbGF5ZXIsdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsZmxvYXQgZGVwdGhNZXRyaWMsaGlnaHAgc2FtcGxlcjJEQXJyYXkgZGVwdGhTYW1wbGVyLGhpZ2hwIHNhbXBsZXIyREFycmF5U2hhZG93IHNoYWRvd1NhbXBsZXIsZmxvYXQgc2hhZG93TWFwU2l6ZUludmVyc2UsZmxvYXQgbGlnaHRTaXplVVYsZmxvYXQgZGFya25lc3MsZmxvYXQgZnJ1c3R1bUVkZ2VGYWxsb2ZmLGludCBzZWFyY2hUYXBDb3VudCxpbnQgcGNmVGFwQ291bnQsdmVjM1s2NF0gcG9pc3NvblNhbXBsZXJzLHZlYzIgbGlnaHRTaXplVVZDb3JyZWN0aW9uLGZsb2F0IGRlcHRoQ29ycmVjdGlvbixmbG9hdCBwZW51bWJyYURhcmtuZXNzKVxue3ZlYzMgY2xpcFNwYWNlPXZQb3NpdGlvbkZyb21MaWdodC54eXovdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7dmVjMyB1dkRlcHRoPXZlYzMoMC41KmNsaXBTcGFjZS54eXordmVjMygwLjUpKTt1dkRlcHRoLno9Y2xhbXAoWklOQ0xJUCwwLixHUkVBVEVTVF9MRVNTX1RIQU5fT05FKTt2ZWM0IHV2RGVwdGhMYXllcj12ZWM0KHV2RGVwdGgueCx1dkRlcHRoLnksbGF5ZXIsdXZEZXB0aC56KTtmbG9hdCBibG9ja2VyRGVwdGg9MC4wO2Zsb2F0IHN1bUJsb2NrZXJEZXB0aD0wLjA7ZmxvYXQgbnVtQmxvY2tlcj0wLjA7Zm9yIChpbnQgaT0wOyBpPHNlYXJjaFRhcENvdW50OyBpICsrKSB7YmxvY2tlckRlcHRoPXRleHR1cmUyRChkZXB0aFNhbXBsZXIsdmVjMyh1dkRlcHRoLnh5KyhsaWdodFNpemVVVipsaWdodFNpemVVVkNvcnJlY3Rpb24qc2hhZG93TWFwU2l6ZUludmVyc2UqUG9pc3NvblNhbXBsZXJzMzJbaV0ueHkpLGxheWVyKSkucjtpZiAoYmxvY2tlckRlcHRoPGRlcHRoTWV0cmljKSB7c3VtQmxvY2tlckRlcHRoKz1ibG9ja2VyRGVwdGg7bnVtQmxvY2tlcisrO319XG5mbG9hdCBhdmdCbG9ja2VyRGVwdGg9c3VtQmxvY2tlckRlcHRoL251bUJsb2NrZXI7ZmxvYXQgQUFPZmZzZXQ9c2hhZG93TWFwU2l6ZUludmVyc2UqMTAuO2Zsb2F0IHBlbnVtYnJhUmF0aW89KChkZXB0aE1ldHJpYy1hdmdCbG9ja2VyRGVwdGgpKmRlcHRoQ29ycmVjdGlvbitBQU9mZnNldCk7dmVjNCBmaWx0ZXJSYWRpdXM9dmVjNChwZW51bWJyYVJhdGlvKmxpZ2h0U2l6ZVVWKmxpZ2h0U2l6ZVVWQ29ycmVjdGlvbipzaGFkb3dNYXBTaXplSW52ZXJzZSwwLiwwLik7ZmxvYXQgcmFuZG9tPWdldFJhbmQodlBvc2l0aW9uRnJvbUxpZ2h0Lnh5KTtmbG9hdCByb3RhdGlvbkFuZ2xlPXJhbmRvbSozLjE0MTU5MjY7dmVjMiByb3RhdGlvblZlY3Rvcj12ZWMyKGNvcyhyb3RhdGlvbkFuZ2xlKSxzaW4ocm90YXRpb25BbmdsZSkpO2Zsb2F0IHNoYWRvdz0wLjtmb3IgKGludCBpPTA7IGk8cGNmVGFwQ291bnQ7IGkrKykge3ZlYzQgb2Zmc2V0PXZlYzQocG9pc3NvblNhbXBsZXJzW2ldLDAuKTtvZmZzZXQ9dmVjNChvZmZzZXQueCpyb3RhdGlvblZlY3Rvci54LW9mZnNldC55KnJvdGF0aW9uVmVjdG9yLnksb2Zmc2V0Lnkqcm90YXRpb25WZWN0b3IueCtvZmZzZXQueCpyb3RhdGlvblZlY3Rvci55LDAuLDAuKTtzaGFkb3crPXRleHR1cmUyRChzaGFkb3dTYW1wbGVyLHV2RGVwdGhMYXllcitvZmZzZXQqZmlsdGVyUmFkaXVzKTt9XG5zaGFkb3cvPWZsb2F0KHBjZlRhcENvdW50KTtzaGFkb3c9bWl4KHNoYWRvdywxLixtaW4oKGRlcHRoTWV0cmljLWF2Z0Jsb2NrZXJEZXB0aCkqZGVwdGhDb3JyZWN0aW9uKnBlbnVtYnJhRGFya25lc3MsMS4pKTtzaGFkb3c9bWl4KGRhcmtuZXNzLDEuLHNoYWRvdyk7aWYgKG51bUJsb2NrZXI8MS4wKSB7cmV0dXJuIDEuMDt9XG5lbHNlXG57cmV0dXJuIGNvbXB1dGVGYWxsT2ZmKHNoYWRvdyxjbGlwU3BhY2UueHksZnJ1c3R1bUVkZ2VGYWxsb2ZmKTt9fVxuI2RlZmluZSBpbmxpbmVcbmZsb2F0IGNvbXB1dGVTaGFkb3dXaXRoUENTUyh2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCxmbG9hdCBkZXB0aE1ldHJpYyxzYW1wbGVyMkQgZGVwdGhTYW1wbGVyLGhpZ2hwIHNhbXBsZXIyRFNoYWRvdyBzaGFkb3dTYW1wbGVyLGZsb2F0IHNoYWRvd01hcFNpemVJbnZlcnNlLGZsb2F0IGxpZ2h0U2l6ZVVWLGZsb2F0IGRhcmtuZXNzLGZsb2F0IGZydXN0dW1FZGdlRmFsbG9mZixpbnQgc2VhcmNoVGFwQ291bnQsaW50IHBjZlRhcENvdW50LHZlYzNbNjRdIHBvaXNzb25TYW1wbGVycylcbntpZiAoZGVwdGhNZXRyaWM+MS4wIHx8IGRlcHRoTWV0cmljPDAuMCkge3JldHVybiAxLjA7fVxuZWxzZVxue3ZlYzMgY2xpcFNwYWNlPXZQb3NpdGlvbkZyb21MaWdodC54eXovdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7dmVjMyB1dkRlcHRoPXZlYzMoMC41KmNsaXBTcGFjZS54eXordmVjMygwLjUpKTt1dkRlcHRoLno9WklOQ0xJUDtmbG9hdCBibG9ja2VyRGVwdGg9MC4wO2Zsb2F0IHN1bUJsb2NrZXJEZXB0aD0wLjA7ZmxvYXQgbnVtQmxvY2tlcj0wLjA7Zm9yIChpbnQgaT0wOyBpPHNlYXJjaFRhcENvdW50OyBpICsrKSB7YmxvY2tlckRlcHRoPVRFWFRVUkVGVU5DKGRlcHRoU2FtcGxlcix1dkRlcHRoLnh5KyhsaWdodFNpemVVVipzaGFkb3dNYXBTaXplSW52ZXJzZSpQb2lzc29uU2FtcGxlcnMzMltpXS54eSksMC4pLnI7aWYgKGJsb2NrZXJEZXB0aDxkZXB0aE1ldHJpYykge3N1bUJsb2NrZXJEZXB0aCs9YmxvY2tlckRlcHRoO251bUJsb2NrZXIrKzt9fVxuaWYgKG51bUJsb2NrZXI8MS4wKSB7cmV0dXJuIDEuMDt9XG5lbHNlXG57ZmxvYXQgYXZnQmxvY2tlckRlcHRoPXN1bUJsb2NrZXJEZXB0aC9udW1CbG9ja2VyO2Zsb2F0IEFBT2Zmc2V0PXNoYWRvd01hcFNpemVJbnZlcnNlKjEwLjtmbG9hdCBwZW51bWJyYVJhdGlvPSgoZGVwdGhNZXRyaWMtYXZnQmxvY2tlckRlcHRoKStBQU9mZnNldCk7ZmxvYXQgZmlsdGVyUmFkaXVzPXBlbnVtYnJhUmF0aW8qbGlnaHRTaXplVVYqc2hhZG93TWFwU2l6ZUludmVyc2U7ZmxvYXQgcmFuZG9tPWdldFJhbmQodlBvc2l0aW9uRnJvbUxpZ2h0Lnh5KTtmbG9hdCByb3RhdGlvbkFuZ2xlPXJhbmRvbSozLjE0MTU5MjY7dmVjMiByb3RhdGlvblZlY3Rvcj12ZWMyKGNvcyhyb3RhdGlvbkFuZ2xlKSxzaW4ocm90YXRpb25BbmdsZSkpO2Zsb2F0IHNoYWRvdz0wLjtmb3IgKGludCBpPTA7IGk8cGNmVGFwQ291bnQ7IGkrKykge3ZlYzMgb2Zmc2V0PXBvaXNzb25TYW1wbGVyc1tpXTtvZmZzZXQ9dmVjMyhvZmZzZXQueCpyb3RhdGlvblZlY3Rvci54LW9mZnNldC55KnJvdGF0aW9uVmVjdG9yLnksb2Zmc2V0Lnkqcm90YXRpb25WZWN0b3IueCtvZmZzZXQueCpyb3RhdGlvblZlY3Rvci55LDAuKTtzaGFkb3crPVRFWFRVUkVGVU5DKHNoYWRvd1NhbXBsZXIsdXZEZXB0aCtvZmZzZXQqZmlsdGVyUmFkaXVzLDAuKTt9XG5zaGFkb3cvPWZsb2F0KHBjZlRhcENvdW50KTtzaGFkb3c9bWl4KHNoYWRvdywxLixkZXB0aE1ldHJpYy1hdmdCbG9ja2VyRGVwdGgpO3NoYWRvdz1taXgoZGFya25lc3MsMS4sc2hhZG93KTtyZXR1cm4gY29tcHV0ZUZhbGxPZmYoc2hhZG93LGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpO319fVxuI2RlZmluZSBpbmxpbmVcbmZsb2F0IGNvbXB1dGVTaGFkb3dXaXRoUENTUzE2KHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LGZsb2F0IGRlcHRoTWV0cmljLHNhbXBsZXIyRCBkZXB0aFNhbXBsZXIsaGlnaHAgc2FtcGxlcjJEU2hhZG93IHNoYWRvd1NhbXBsZXIsZmxvYXQgc2hhZG93TWFwU2l6ZUludmVyc2UsZmxvYXQgbGlnaHRTaXplVVYsZmxvYXQgZGFya25lc3MsZmxvYXQgZnJ1c3R1bUVkZ2VGYWxsb2ZmKVxue3JldHVybiBjb21wdXRlU2hhZG93V2l0aFBDU1ModlBvc2l0aW9uRnJvbUxpZ2h0LGRlcHRoTWV0cmljLGRlcHRoU2FtcGxlcixzaGFkb3dTYW1wbGVyLHNoYWRvd01hcFNpemVJbnZlcnNlLGxpZ2h0U2l6ZVVWLGRhcmtuZXNzLGZydXN0dW1FZGdlRmFsbG9mZiwxNiwxNixQb2lzc29uU2FtcGxlcnMzMik7fVxuI2RlZmluZSBpbmxpbmVcbmZsb2F0IGNvbXB1dGVTaGFkb3dXaXRoUENTUzMyKHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LGZsb2F0IGRlcHRoTWV0cmljLHNhbXBsZXIyRCBkZXB0aFNhbXBsZXIsaGlnaHAgc2FtcGxlcjJEU2hhZG93IHNoYWRvd1NhbXBsZXIsZmxvYXQgc2hhZG93TWFwU2l6ZUludmVyc2UsZmxvYXQgbGlnaHRTaXplVVYsZmxvYXQgZGFya25lc3MsZmxvYXQgZnJ1c3R1bUVkZ2VGYWxsb2ZmKVxue3JldHVybiBjb21wdXRlU2hhZG93V2l0aFBDU1ModlBvc2l0aW9uRnJvbUxpZ2h0LGRlcHRoTWV0cmljLGRlcHRoU2FtcGxlcixzaGFkb3dTYW1wbGVyLHNoYWRvd01hcFNpemVJbnZlcnNlLGxpZ2h0U2l6ZVVWLGRhcmtuZXNzLGZydXN0dW1FZGdlRmFsbG9mZiwxNiwzMixQb2lzc29uU2FtcGxlcnMzMik7fVxuI2RlZmluZSBpbmxpbmVcbmZsb2F0IGNvbXB1dGVTaGFkb3dXaXRoUENTUzY0KHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LGZsb2F0IGRlcHRoTWV0cmljLHNhbXBsZXIyRCBkZXB0aFNhbXBsZXIsaGlnaHAgc2FtcGxlcjJEU2hhZG93IHNoYWRvd1NhbXBsZXIsZmxvYXQgc2hhZG93TWFwU2l6ZUludmVyc2UsZmxvYXQgbGlnaHRTaXplVVYsZmxvYXQgZGFya25lc3MsZmxvYXQgZnJ1c3R1bUVkZ2VGYWxsb2ZmKVxue3JldHVybiBjb21wdXRlU2hhZG93V2l0aFBDU1ModlBvc2l0aW9uRnJvbUxpZ2h0LGRlcHRoTWV0cmljLGRlcHRoU2FtcGxlcixzaGFkb3dTYW1wbGVyLHNoYWRvd01hcFNpemVJbnZlcnNlLGxpZ2h0U2l6ZVVWLGRhcmtuZXNzLGZydXN0dW1FZGdlRmFsbG9mZiwzMiw2NCxQb2lzc29uU2FtcGxlcnM2NCk7fVxuI2RlZmluZSBpbmxpbmVcbmZsb2F0IGNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUzE2KGZsb2F0IGxheWVyLHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LGZsb2F0IGRlcHRoTWV0cmljLGhpZ2hwIHNhbXBsZXIyREFycmF5IGRlcHRoU2FtcGxlcixoaWdocCBzYW1wbGVyMkRBcnJheVNoYWRvdyBzaGFkb3dTYW1wbGVyLGZsb2F0IHNoYWRvd01hcFNpemVJbnZlcnNlLGZsb2F0IGxpZ2h0U2l6ZVVWLGZsb2F0IGRhcmtuZXNzLGZsb2F0IGZydXN0dW1FZGdlRmFsbG9mZix2ZWMyIGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbixmbG9hdCBkZXB0aENvcnJlY3Rpb24sZmxvYXQgcGVudW1icmFEYXJrbmVzcylcbntyZXR1cm4gY29tcHV0ZVNoYWRvd1dpdGhDU01QQ1NTKGxheWVyLHZQb3NpdGlvbkZyb21MaWdodCxkZXB0aE1ldHJpYyxkZXB0aFNhbXBsZXIsc2hhZG93U2FtcGxlcixzaGFkb3dNYXBTaXplSW52ZXJzZSxsaWdodFNpemVVVixkYXJrbmVzcyxmcnVzdHVtRWRnZUZhbGxvZmYsMTYsMTYsUG9pc3NvblNhbXBsZXJzMzIsbGlnaHRTaXplVVZDb3JyZWN0aW9uLGRlcHRoQ29ycmVjdGlvbixwZW51bWJyYURhcmtuZXNzKTt9XG4jZGVmaW5lIGlubGluZVxuZmxvYXQgY29tcHV0ZVNoYWRvd1dpdGhDU01QQ1NTMzIoZmxvYXQgbGF5ZXIsdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsZmxvYXQgZGVwdGhNZXRyaWMsaGlnaHAgc2FtcGxlcjJEQXJyYXkgZGVwdGhTYW1wbGVyLGhpZ2hwIHNhbXBsZXIyREFycmF5U2hhZG93IHNoYWRvd1NhbXBsZXIsZmxvYXQgc2hhZG93TWFwU2l6ZUludmVyc2UsZmxvYXQgbGlnaHRTaXplVVYsZmxvYXQgZGFya25lc3MsZmxvYXQgZnJ1c3R1bUVkZ2VGYWxsb2ZmLHZlYzIgbGlnaHRTaXplVVZDb3JyZWN0aW9uLGZsb2F0IGRlcHRoQ29ycmVjdGlvbixmbG9hdCBwZW51bWJyYURhcmtuZXNzKVxue3JldHVybiBjb21wdXRlU2hhZG93V2l0aENTTVBDU1MobGF5ZXIsdlBvc2l0aW9uRnJvbUxpZ2h0LGRlcHRoTWV0cmljLGRlcHRoU2FtcGxlcixzaGFkb3dTYW1wbGVyLHNoYWRvd01hcFNpemVJbnZlcnNlLGxpZ2h0U2l6ZVVWLGRhcmtuZXNzLGZydXN0dW1FZGdlRmFsbG9mZiwxNiwzMixQb2lzc29uU2FtcGxlcnMzMixsaWdodFNpemVVVkNvcnJlY3Rpb24sZGVwdGhDb3JyZWN0aW9uLHBlbnVtYnJhRGFya25lc3MpO31cbiNkZWZpbmUgaW5saW5lXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aENTTVBDU1M2NChmbG9hdCBsYXllcix2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCxmbG9hdCBkZXB0aE1ldHJpYyxoaWdocCBzYW1wbGVyMkRBcnJheSBkZXB0aFNhbXBsZXIsaGlnaHAgc2FtcGxlcjJEQXJyYXlTaGFkb3cgc2hhZG93U2FtcGxlcixmbG9hdCBzaGFkb3dNYXBTaXplSW52ZXJzZSxmbG9hdCBsaWdodFNpemVVVixmbG9hdCBkYXJrbmVzcyxmbG9hdCBmcnVzdHVtRWRnZUZhbGxvZmYsdmVjMiBsaWdodFNpemVVVkNvcnJlY3Rpb24sZmxvYXQgZGVwdGhDb3JyZWN0aW9uLGZsb2F0IHBlbnVtYnJhRGFya25lc3MpXG57cmV0dXJuIGNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUyhsYXllcix2UG9zaXRpb25Gcm9tTGlnaHQsZGVwdGhNZXRyaWMsZGVwdGhTYW1wbGVyLHNoYWRvd1NhbXBsZXIsc2hhZG93TWFwU2l6ZUludmVyc2UsbGlnaHRTaXplVVYsZGFya25lc3MsZnJ1c3R1bUVkZ2VGYWxsb2ZmLDMyLDY0LFBvaXNzb25TYW1wbGVyczY0LGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbixkZXB0aENvcnJlY3Rpb24scGVudW1icmFEYXJrbmVzcyk7fVxuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBzaGFkb3dzRnJhZ21lbnRGdW5jdGlvbnMgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93c0ZyYWdtZW50RnVuY3Rpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==