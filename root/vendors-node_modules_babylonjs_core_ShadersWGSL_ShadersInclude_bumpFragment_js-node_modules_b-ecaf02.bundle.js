"use strict";
(self["webpackChunksample1"] = self["webpackChunksample1"] || []).push([["vendors-node_modules_babylonjs_core_ShadersWGSL_ShadersInclude_bumpFragment_js-node_modules_b-ecaf02"],{

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragment.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragment.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpFragmentWGSL: () => (/* binding */ bumpFragmentWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bumpFragment";
const shader = `var uvOffset: vec2f= vec2f(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
var normalScale: f32=1.0;
#elif defined(BUMP)
var normalScale: f32=uniforms.vBumpInfos.y;
#else
var normalScale: f32=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
var TBN: mat3x3f=mat3x3<f32>(input.vTBN0,input.vTBN1,input.vTBN2); 
#elif defined(BUMP)
var TBNUV: vec2f=select(-fragmentInputs.vBumpUV,fragmentInputs.vBumpUV,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW*normalScale,input.vPositionW,TBNUV,uniforms.vTangentSpaceParams);
#else
var TBNUV: vec2f=select(-vDetailUV,vDetailUV,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW*normalScale,input.vPositionW,TBNUV, vec2f(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
var TBN: mat3x3f=mat3x3<f32>(input.vTBN0,input.vTBN1,input.vTBN2); 
#else
var TBNUV: vec2f=select( -fragmentInputs.vMainUV1,fragmentInputs.vMainUV1,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW,input.vPositionW,TBNUV, vec2f(1.,1.));
#endif
#endif
#ifdef PARALLAX
var invTBN: mat3x3f=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,fragmentInputs.vBumpUV,uniforms.vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,uniforms.vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
var detailColor: vec4f=textureSample(detailSampler,detailSamplerSampler,vDetailUV+uvOffset);var detailNormalRG: vec2f=detailColor.wy*2.0-1.0;var detailNormalB: f32=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));var detailNormal: vec3f= vec3f(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3x3f(uniforms.normalMatrix[0].xyz,uniforms.normalMatrix[1].xyz,uniforms.normalMatrix[2].xyz)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV+uvOffset).xyz,uniforms.vBumpInfos.y);
#else
var bumpNormal: vec3f=textureSample(bumpSampler,bumpSamplerSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=uniforms.vDetailInfos.z;var blendedNormal: vec3f=normalize( vec3f(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=uniforms.vDetailInfos.z;bumpNormal+= vec3f(0.0,0.0,1.0);detailNormal*= vec3f(-1.0,-1.0,1.0);var blendedNormal: vec3f=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,uniforms.vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,uniforms.vDetailInfos.z);
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bumpFragmentWGSL = { name, shader };
//# sourceMappingURL=bumpFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragmentFunctions.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragmentFunctions.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpFragmentFunctionsWGSL: () => (/* binding */ bumpFragmentFunctionsWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
/* harmony import */ var _samplerFragmentDeclaration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./samplerFragmentDeclaration.js */ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerFragmentDeclaration.js");
// Do not edit.


const name = "bumpFragmentFunctions";
const shader = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const minSamples: f32=4.;const maxSamples: f32=15.;const iMaxSamples: i32=15;fn parallaxOcclusion(vViewDirCoT: vec3f,vNormalCoT: vec3f,texCoord: vec2f,parallaxScale: f32)->vec2f {var parallaxLimit: f32=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;var vOffsetDir: vec2f=normalize(vViewDirCoT.xy);var vMaxOffset: vec2f=vOffsetDir*parallaxLimit;var numSamples: f32=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));var stepSize: f32=1.0/numSamples;var currRayHeight: f32=1.0;var vCurrOffset: vec2f= vec2f(0,0);var vLastOffset: vec2f= vec2f(0,0);var lastSampledHeight: f32=1.0;var currSampledHeight: f32=1.0;var keepWorking: bool=true;for (var i: i32=0; i<iMaxSamples; i++)
{currSampledHeight=textureSample(bumpSampler,bumpSamplerSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{var delta1: f32=currSampledHeight-currRayHeight;var delta2: f32=(currRayHeight+stepSize)-lastSampledHeight;var ratio: f32=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
fn parallaxOffset(viewDir: vec3f,heightScale: f32)->vec2f
{var height: f32=textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV).w;var texCoordOffset: vec2f=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bumpFragmentFunctionsWGSL = { name, shader };
//# sourceMappingURL=bumpFragmentFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragmentMainFunctions.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragmentMainFunctions.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpFragmentMainFunctionsWGSL: () => (/* binding */ bumpFragmentMainFunctionsWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bumpFragmentMainFunctions";
const shader = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying vTBN0: vec3f;varying vTBN1: vec3f;varying vTBN2: vec3f;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform normalMatrix: mat4x4f;fn toNormalMatrix(m: mat4x4f)->mat4x4f
{var a00=m[0][0];var a01=m[0][1];var a02=m[0][2];var a03=m[0][3];var a10=m[1][0];var a11=m[1][1];var a12=m[1][2];var a13=m[1][3];var a20=m[2][0]; 
var a21=m[2][1];var a22=m[2][2];var a23=m[2][3];var a30=m[3][0]; 
var a31=m[3][1];var a32=m[3][2];var a33=m[3][3];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;var det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;var mi=mat4x4<f32>(
(a11*b11-a12*b10+a13*b09)/det,
(a02*b10-a01*b11-a03*b09)/det,
(a31*b05-a32*b04+a33*b03)/det,
(a22*b04-a21*b05-a23*b03)/det,
(a12*b08-a10*b11-a13*b07)/det,
(a00*b11-a02*b08+a03*b07)/det,
(a32*b02-a30*b05-a33*b01)/det,
(a20*b05-a22*b02+a23*b01)/det,
(a10*b10-a11*b08+a13*b06)/det,
(a01*b08-a00*b10-a03*b06)/det,
(a30*b04-a31*b02+a33*b00)/det,
(a21*b02-a20*b04-a23*b00)/det,
(a11*b07-a10*b09-a12*b06)/det,
(a00*b09-a01*b07+a02*b06)/det,
(a31*b01-a30*b03-a32*b00)/det,
(a20*b03-a21*b01+a22*b00)/det);return mat4x4<f32>(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
fn perturbNormalBase(cotangentFrame: mat3x3f,normal: vec3f,scale: f32)->vec3f
{var output=normal;
#ifdef NORMALXYSCALE
output=normalize(output* vec3f(scale,scale,1.0));
#endif
return normalize(cotangentFrame*output);}
fn perturbNormal(cotangentFrame: mat3x3f,textureSample: vec3f,scale: f32)->vec3f
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
fn cotangent_frame(normal: vec3f,p: vec3f,uv: vec2f,tangentSpaceParams: vec2f)->mat3x3f
{var dp1: vec3f=dpdx(p);var dp2: vec3f=dpdy(p);var duv1: vec2f=dpdx(uv);var duv2: vec2f=dpdy(uv);var dp2perp: vec3f=cross(dp2,normal);var dp1perp: vec3f=cross(normal,dp1);var tangent: vec3f=dp2perp*duv1.x+dp1perp*duv2.x;var bitangent: vec3f=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;var det: f32=max(dot(tangent,tangent),dot(bitangent,bitangent));var invmax: f32=select(inverseSqrt(det),0.0,det==0.0);return mat3x3f(tangent*invmax,bitangent*invmax,normal);}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bumpFragmentMainFunctionsWGSL = { name, shader };
//# sourceMappingURL=bumpFragmentMainFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragment.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragment.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clipPlaneFragmentWGSL: () => (/* binding */ clipPlaneFragmentWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "clipPlaneFragment";
const shader = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fragmentInputs.fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fragmentInputs.fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fragmentInputs.fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fragmentInputs.fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fragmentInputs.fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fragmentInputs.fClipDistance6>0.0)
{discard;}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const clipPlaneFragmentWGSL = { name, shader };
//# sourceMappingURL=clipPlaneFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clipPlaneFragmentDeclarationWGSL: () => (/* binding */ clipPlaneFragmentDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "clipPlaneFragmentDeclaration";
const shader = `#ifdef CLIPPLANE
varying fClipDistance: f32;
#endif
#ifdef CLIPPLANE2
varying fClipDistance2: f32;
#endif
#ifdef CLIPPLANE3
varying fClipDistance3: f32;
#endif
#ifdef CLIPPLANE4
varying fClipDistance4: f32;
#endif
#ifdef CLIPPLANE5
varying fClipDistance5: f32;
#endif
#ifdef CLIPPLANE6
varying fClipDistance6: f32;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const clipPlaneFragmentDeclarationWGSL = { name, shader };
//# sourceMappingURL=clipPlaneFragmentDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/decalFragment.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/decalFragment.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decalFragmentWGSL: () => (/* binding */ decalFragmentWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "decalFragment";
const shader = `#ifdef DECAL
var decalTempColor=decalColor.rgb;var decalTempAlpha=decalColor.a;
#ifdef GAMMADECAL
decalTempColor=toLinearSpaceVec3(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalTempAlpha=decalColor.a*decalColor.a;
#endif
surfaceAlbedo=mix(surfaceAlbedo.rgb,decalTempColor,decalTempAlpha);
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const decalFragmentWGSL = { name, shader };
//# sourceMappingURL=decalFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/depthPrePass.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/depthPrePass.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   depthPrePassWGSL: () => (/* binding */ depthPrePassWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "depthPrePass";
const shader = `#ifdef DEPTHPREPASS
gl_FragColor= vec4f(0.,0.,0.,1.0);return;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const depthPrePassWGSL = { name, shader };
//# sourceMappingURL=depthPrePass.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogFragment.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogFragment.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fogFragmentWGSL: () => (/* binding */ fogFragmentWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "fogFragment";
const shader = `#ifdef FOG
var fog: f32=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color= vec4f(mix(uniforms.vFogColor,color.rgb,fog),color.a);
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const fogFragmentWGSL = { name, shader };
//# sourceMappingURL=fogFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogFragmentDeclaration.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogFragmentDeclaration.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fogFragmentDeclarationWGSL: () => (/* binding */ fogFragmentDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "fogFragmentDeclaration";
const shader = `#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
const E=2.71828;uniform vFogInfos: vec4f;uniform vFogColor: vec3f;varying vFogDistance: vec3f;fn CalcFogFactor()->f32
{var fogCoeff: f32=1.0;var fogStart: f32=uniforms.vFogInfos.y;var fogEnd: f32=uniforms.vFogInfos.z;var fogDensity: f32=uniforms.vFogInfos.w;var fogDistance: f32=length(fragmentInputs.vFogDistance);if (FOGMODE_LINEAR==uniforms.vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==uniforms.vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==uniforms.vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const fogFragmentDeclarationWGSL = { name, shader };
//# sourceMappingURL=fogFragmentDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   helperFunctionsWGSL: () => (/* binding */ helperFunctionsWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "helperFunctions";
const shader = `const PI: f32=3.1415926535897932384626433832795;const RECIPROCAL_PI: f32=0.3183098861837907;const RECIPROCAL_PI2: f32=0.15915494309189535;const HALF_MIN: f32=5.96046448e-08; 
const LinearEncodePowerApprox: f32=2.2;const GammaEncodePowerApprox: f32=1.0/LinearEncodePowerApprox;const LuminanceEncodeApprox: vec3<f32>=vec3<f32> (0.2126,0.7152,0.0722);const Epsilon:f32=0.0000001;fn square(x: f32)->f32 {return x*x;}
fn saturate(x: f32)->f32 {return clamp(x,0.0,1.0);}
fn saturateVec3(x: vec3f)->vec3f {return clamp(x,vec3f(0.0),vec3f(1.0));}
fn saturateEps(x: f32)->f32 {return clamp(x,Epsilon,1.0);} 
fn maxEps(x: f32)->f32 {return max(x,Epsilon);}
fn maxEpsVec3(x: vec3f)->vec3f {return max(x,vec3f(Epsilon));}
fn absEps(x: f32)->f32 {return abs(x)+Epsilon;}
fn transposeMat3(inMatrix: mat3x3f)->mat3x3f {let i0: vec3<f32>=inMatrix[0];let i1: vec3<f32>=inMatrix[1];let i2: vec3<f32>=inMatrix[2];let outMatrix:mat3x3f=mat3x3f(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
fn inverseMat3(inMatrix: mat3x3f)->mat3x3f {let a00: f32=inMatrix[0][0];let a01: f32=inMatrix[0][1];let a02: f32=inMatrix[0][2];let a10: f32=inMatrix[1][0];let a11: f32=inMatrix[1][1];let a12: f32=inMatrix[1][2];let a20: f32=inMatrix[2][0];let a21: f32=inMatrix[2][1];let a22: f32=inMatrix[2][2];let b01: f32=a22*a11-a12*a21;let b11: f32=-a22*a10+a12*a20;let b21: f32=a21*a10-a11*a20;let det: f32=a00*b01+a01*b11+a02*b21;return mat3x3f(b01/det,(-a22*a01+a02*a21)/det,(a12*a01-a02*a11)/det,
b11/det,(a22*a00-a02*a20)/det,(-a12*a00+a02*a10)/det,
b21/det,(-a21*a00+a01*a20)/det,(a11*a00-a01*a10)/det);}
#if USE_EXACT_SRGB_CONVERSIONS
fn toLinearSpaceExact(color: vec3<f32>)->vec3<f32>
{let nearZeroSection: vec3<f32>=0.0773993808*color;let remainingSection: vec3<f32>=pow(0.947867299*(color+vec3<f32>(0.055)),vec3<f32>(2.4));return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3<f32>(0.04045)));}
fn toGammaSpaceExact(color: vec3<f32>)->vec3<f32>
{let nearZeroSection: vec3<f32>=12.92*color;let remainingSection: vec3<f32>=1.055*pow(color,vec3<f32>(0.41666))-vec3<f32>(0.055);return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3<f32>(0.0031308)));}
#endif
fn toLinearSpace(color: f32)->f32
{
#if USE_EXACT_SRGB_CONVERSIONS
var nearZeroSection=0.0773993808*color;var remainingSection=pow(0.947867299*(color+0.055),2.4);return select(remainingSection,nearZeroSection,color<=0.04045);
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
fn toLinearSpaceVec3(color: vec3<f32>)->vec3<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3<f32>(LinearEncodePowerApprox));
#endif
}
fn toLinearSpaceVec4(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4f(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4f(pow(color.rgb,vec3f(LinearEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpace(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4<f32>(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4<f32>(pow(color.rgb,vec3<f32>(GammaEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpaceVec3(color: vec3<f32>)->vec3<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3<f32>(GammaEncodePowerApprox));
#endif
}
fn squareVec3(value: vec3<f32>)->vec3<f32>
{return value*value;}
fn pow5(value: f32)->f32 {let sq: f32=value*value;return sq*sq*value;}
fn getLuminance(color: vec3<f32>)->f32
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
fn getRand(seed: vec2<f32>)->f32 {return fract(sin(dot(seed.xy ,vec2<f32>(12.9898,78.233)))*43758.5453);}
fn dither(seed: vec2<f32>,varianceAmount: f32)->f32 {let rand: f32=getRand(seed);let normVariance: f32=varianceAmount/255.0;let dither: f32=mix(-normVariance,normVariance,rand);return dither;}
const rgbdMaxRange: f32=255.0;fn toRGBD(color: vec3<f32>)->vec4<f32> {let maxRGB: f32=max(max(color.r,max(color.g,color.b)),Epsilon);var D: f32 =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);var rgb: vec3<f32> =color.rgb*D;rgb=toGammaSpaceVec3(rgb);return vec4<f32>(clamp(rgb,vec3<f32>(0.,0.,0.),vec3<f32>(1.,1.,1.)),D); }
fn fromRGBD(rgbd: vec4<f32>)->vec3<f32> {let rgb=toLinearSpaceVec3(rgbd.rgb);return rgb/rgbd.a;}
fn parallaxCorrectNormal(vertexPos: vec3<f32>,origVec: vec3<f32>,cubeSize: vec3<f32>,cubePos: vec3<f32>)->vec3<f32> {let invOrigVec: vec3<f32>=vec3<f32>(1.0,1.0,1.0)/origVec;let halfSize: vec3<f32>=cubeSize*0.5;let intersecAtMaxPlane: vec3<f32>=(cubePos+halfSize-vertexPos)*invOrigVec;let intersecAtMinPlane: vec3<f32>=(cubePos-halfSize-vertexPos)*invOrigVec;let largestIntersec: vec3<f32>=max(intersecAtMaxPlane,intersecAtMinPlane);let distance: f32=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);let intersectPositionWS: vec3<f32>=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const helperFunctionsWGSL = { name, shader };
//# sourceMappingURL=helperFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/imageProcessingDeclaration.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/imageProcessingDeclaration.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   imageProcessingDeclarationWGSL: () => (/* binding */ imageProcessingDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "imageProcessingDeclaration";
const shader = `#ifdef EXPOSURE
uniform exposureLinear: f32;
#endif
#ifdef CONTRAST
uniform contrast: f32;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vInverseScreenSize: vec2f;
#endif
#ifdef VIGNETTE
uniform vignetteSettings1: vec4f;uniform vignetteSettings2: vec4f;
#endif
#ifdef COLORCURVES
uniform vCameraColorCurveNegative: vec4f;uniform vCameraColorCurveNeutral: vec4f;uniform vCameraColorCurvePositive: vec4f;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
var txColorTransformSampler: sampler;var txColorTransform: texture_3d<f32>;
#else
var txColorTransformSampler: sampler;var txColorTransform: texture_2d<f32>;
#endif
uniform colorTransformSettings: vec4f;
#endif
#ifdef DITHER
uniform ditherIntensity: f32;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const imageProcessingDeclarationWGSL = { name, shader };
//# sourceMappingURL=imageProcessingDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/imageProcessingFunctions.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/imageProcessingFunctions.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   imageProcessingFunctionsWGSL: () => (/* binding */ imageProcessingFunctionsWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "imageProcessingFunctions";
const shader = `#if TONEMAPPING==3
const PBRNeutralStartCompression: f32=0.8-0.04;const PBRNeutralDesaturation: f32=0.15;fn PBRNeutralToneMapping( color: vec3f )->vec3f {var x: f32=min(color.r,min(color.g,color.b));var offset: f32=select(0.04,x-6.25*x*x,x<0.08);var result=color;result-=offset;var peak: f32=max(result.r,max(result.g,result.b));if (peak<PBRNeutralStartCompression) {return result;}
var d: f32=1.-PBRNeutralStartCompression;var newPeak: f32=1.-d*d/(peak+d-PBRNeutralStartCompression);result*=newPeak/peak;var g: f32=1.-1./(PBRNeutralDesaturation*(peak-newPeak)+1.);return mix(result,newPeak* vec3f(1,1,1),g);}
#endif
#if TONEMAPPING==2
const ACESInputMat: mat3x3f= mat3x3f(
vec3f(0.59719,0.07600,0.02840),
vec3f(0.35458,0.90834,0.13383),
vec3f(0.04823,0.01566,0.83777)
);const ACESOutputMat: mat3x3f= mat3x3f(
vec3f( 1.60475,-0.10208,-0.00327),
vec3f(-0.53108, 1.10813,-0.07276),
vec3f(-0.07367,-0.00605, 1.07602)
);fn RRTAndODTFit(v: vec3f)->vec3f
{var a: vec3f=v*(v+0.0245786)-0.000090537;var b: vec3f=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
fn ACESFitted(color: vec3f)->vec3f
{var output=ACESInputMat*color;output=RRTAndODTFit(output);output=ACESOutputMat*output;output=saturateVec3(output);return output;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
fn applyImageProcessing(result: vec4f)->vec4f {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
var rgb=result.rgb;;
#ifdef EXPOSURE
rgb*=uniforms.exposureLinear;
#endif
#ifdef VIGNETTE
var viewportXY: vec2f=fragmentInputs.position.xy*uniforms.vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;var vignetteXY1: vec3f= vec3f(viewportXY*uniforms.vignetteSettings1.xy+uniforms.vignetteSettings1.zw,1.0);var vignetteTerm: f32=dot(vignetteXY1,vignetteXY1);var vignette: f32=pow(vignetteTerm,uniforms.vignetteSettings2.w);var vignetteColor: vec3f=uniforms.vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
var vignetteColorMultiplier: vec3f=mix(vignetteColor, vec3f(1,1,1),vignette);rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
rgb=mix(vignetteColor,rgb,vignette);
#endif
#endif
#if TONEMAPPING==3
rgb=PBRNeutralToneMapping(rgb);
#elif TONEMAPPING==2
rgb=ACESFitted(rgb);
#elif TONEMAPPING==1
const tonemappingCalibration: f32=1.590579;rgb=1.0-exp2(-tonemappingCalibration*rgb);
#endif
rgb=toGammaSpaceVec3(rgb);rgb=saturateVec3(rgb);
#ifdef CONTRAST
var resultHighContrast: vec3f=rgb*rgb*(3.0-2.0*rgb);if (uniforms.contrast<1.0) {rgb=mix( vec3f(0.5,0.5,0.5),rgb,uniforms.contrast);} else {rgb=mix(rgb,resultHighContrast,uniforms.contrast-1.0);}
#endif
#ifdef COLORGRADING
var colorTransformInput: vec3f=rgb*uniforms.colorTransformSettings.xxx+uniforms.colorTransformSettings.yyy;
#ifdef COLORGRADING3D
var colorTransformOutput: vec3f=textureSample(txColorTransform,txColorTransformSampler,colorTransformInput).rgb;
#else
var colorTransformOutput: vec3f=textureSample(txColorTransform,txColorTransformSampler,colorTransformInput,uniforms.colorTransformSettings.yz).rgb;
#endif
rgb=mix(rgb,colorTransformOutput,uniforms.colorTransformSettings.www);
#endif
#ifdef COLORCURVES
var luma: f32=getLuminance(rgb);var curveMix: vec2f=clamp( vec2f(luma*3.0-1.5,luma*-3.0+1.5), vec2f(0.0), vec2f(1.0));var colorCurve: vec4f=uniforms.vCameraColorCurveNeutral+curveMix.x*uniforms.vCameraColorCurvePositive-curveMix.y*uniforms.vCameraColorCurveNegative;rgb*=colorCurve.rgb;rgb=mix( vec3f(luma),rgb,colorCurve.a);
#endif
#ifdef DITHER
var rand: f32=getRand(fragmentInputs.position.xy*uniforms.vInverseScreenSize);var dither: f32=mix(-uniforms.ditherIntensity,uniforms.ditherIntensity,rand);rgb=saturateVec3(rgb+ vec3f(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return vec4f(rgb,result.a);}`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const imageProcessingFunctionsWGSL = { name, shader };
//# sourceMappingURL=imageProcessingFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightFragment.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightFragment.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightFragmentWGSL: () => (/* binding */ lightFragmentWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "lightFragment";
const shader = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,input.vPositionW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,input.vPositionW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightTexture{X},projectionLightTexture{X}Sampler,uniforms.textureProjectionMatrix{X},input.vPositionW);
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSMDEBUG{X} 
var shadowDebug{X}: vec3f;
#endif
#ifdef SHADOWCSM{X}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
var index{X}: i32=-1;
#else
var index{X}: i32=SHADOWCSMNUM_CASCADES{X}-1;
#endif
var diff{X}: f32=0.;vPositionFromLight{X}[0]=fragmentInputs.vPositionFromLight{X}_0;vPositionFromLight{X}[1]=fragmentInputs.vPositionFromLight{X}_1;vPositionFromLight{X}[2]=fragmentInputs.vPositionFromLight{X}_2;vPositionFromLight{X}[3]=fragmentInputs.vPositionFromLight{X}_3;vDepthMetric{X}[0]=fragmentInputs.vDepthMetric{X}_0;vDepthMetric{X}[1]=fragmentInputs.vDepthMetric{X}_1;vDepthMetric{X}[2]=fragmentInputs.vDepthMetric{X}_2;vDepthMetric{X}[3]=fragmentInputs.vDepthMetric{X}_3;for (var i:i32=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=uniforms.viewFrustumZ{X}[i]+fragmentInputs.vPositionFromCamera{X}.z;
#else
diff{X}=uniforms.viewFrustumZ{X}[i]-fragmentInputs.vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3f(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
var frustumLength:f32=uniforms.frustumLengths{X}[index{X}];var diffRatio:f32=clamp(diff{X}/frustumLength,0.,1.)*uniforms.cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;var nextShadow: f32=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],,shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(input.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(input.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(input.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(input.vPositionW,light{X}.vLightData.xyz,shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const lightFragmentWGSL = { name, shader };
//# sourceMappingURL=lightFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightUboDeclaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightUboDeclaration.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightUboDeclarationWGSL: () => (/* binding */ lightUboDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "lightUboDeclaration";
const shader = `#ifdef LIGHT{X}
struct Light{X}
{vLightData: vec4f,
vLightDiffuse: vec4f,
vLightSpecular: vec4f,
#ifdef SPOTLIGHT{X}
vLightDirection: vec4f,
vLightFalloff: vec4f,
#elif defined(POINTLIGHT{X})
vLightFalloff: vec4f,
#elif defined(HEMILIGHT{X})
vLightGround: vec3f,
#endif
shadowsInfo: vec4f,
depthValues: vec2f} ;var<uniform> light{X} : Light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform textureProjectionMatrix{X}: mat4x4f;var projectionLightTexture{X}Sampler: sampler;var projectionLightTexture{X}: texture_2d<f32>;
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform lightMatrix{X}: array<mat4x4f,SHADOWCSMNUM_CASCADES{X}>;uniform viewFrustumZ{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform frustumLengths{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform cascadeBlendFactor{X}: f32;varying vPositionFromLight{X}_0: vec4f;varying vDepthMetric{X}_0: f32;varying vPositionFromLight{X}_1: vec4f;varying vDepthMetric{X}_1: f32;varying vPositionFromLight{X}_2: vec4f;varying vDepthMetric{X}_2: f32;varying vPositionFromLight{X}_3: vec4f;varying vDepthMetric{X}_3: f32;varying vPositionFromCamera{X}: vec4f;var<private> vPositionFromLight{X}: array<vec4f,4>;var<private> vDepthMetric{X} : array<f32,4>;
#if defined(SHADOWPCSS{X})
var shadowTexture{X}Sampler: sampler_comparison; 
var shadowTexture{X}: texture_depth_2d_array;var depthTexture{X}Sampler: sampler;var depthTexture{X}: texture_2d_array<f32>;uniform lightSizeUVCorrection{X}: array<vec2f,SHADOWCSMNUM_CASCADES{X}>;uniform depthCorrection{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform penumbraDarkness{X}: f32;
#elif defined(SHADOWPCF{X})
var shadowTexture{X}Sampler: sampler_comparison;var shadowTexture{X}: texture_depth_2d_array;
#else 
var shadowTexture{X}Sampler: sampler; 
var shadowTexture{X}: texture_2d_array<f32>;
#endif
#ifdef SHADOWCSMDEBUG{X}
const vCascadeColorsMultiplier{X}: array<vec3f,8>=array<vec3f,8>
(
vec3f ( 1.5,0.0,0.0 ),
vec3f ( 0.0,1.5,0.0 ),
vec3f ( 0.0,0.0,5.5 ),
vec3f ( 1.5,0.0,5.5 ),
vec3f ( 1.5,1.5,0.0 ),
vec3f ( 1.0,1.0,1.0 ),
vec3f ( 0.0,1.0,5.5 ),
vec3f ( 0.5,3.5,0.75 )
);
#endif
#elif defined(SHADOWCUBE{X})
var shadowTexture{X}Sampler: sampler;var shadowTexture{X}: texture_cube<f32>;
#else
varying vPositionFromLight{X}: vec4f;varying vDepthMetric{X}: f32;
#if defined(SHADOWPCSS{X})
var shadowTexture{X}Sampler: sampler_comparison; 
var shadowTexture{X}: texture_depth_2d;var depthTexture{X}Sampler: sampler; 
var depthTexture{X}: texture_2d<f32>;
#elif defined(SHADOWPCF{X})
var shadowTexture{X}Sampler: sampler_comparison;var shadowTexture{X}: texture_depth_2d;
#else
var shadowTexture{X}Sampler: sampler; 
var shadowTexture{X}: texture_2d<f32>;
#endif
uniform lightMatrix{X}: mat4x4f;
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const lightUboDeclarationWGSL = { name, shader };
//# sourceMappingURL=lightUboDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthDeclaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthDeclaration.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logDepthDeclarationWGSL: () => (/* binding */ logDepthDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "logDepthDeclaration";
const shader = `#ifdef LOGARITHMICDEPTH
uniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const logDepthDeclarationWGSL = { name, shader };
//# sourceMappingURL=logDepthDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthFragment.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthFragment.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logDepthFragmentWGSL: () => (/* binding */ logDepthFragmentWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "logDepthFragment";
const shader = `#ifdef LOGARITHMICDEPTH
fragmentOutputs.fragDepth=log2(fragmentInputs.vFragmentDepth)*uniforms.logarithmicDepthConstant*0.5;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const logDepthFragmentWGSL = { name, shader };
//# sourceMappingURL=logDepthFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/mainUVVaryingDeclaration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/mainUVVaryingDeclaration.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mainUVVaryingDeclarationWGSL: () => (/* binding */ mainUVVaryingDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "mainUVVaryingDeclaration";
const shader = `#ifdef MAINUV{X}
varying vMainUV{X}: vec2f;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const mainUVVaryingDeclarationWGSL = { name, shader };
//# sourceMappingURL=mainUVVaryingDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/meshUboDeclaration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/meshUboDeclaration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   meshUboDeclarationWGSL: () => (/* binding */ meshUboDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "meshUboDeclaration";
const shader = `struct Mesh {world : mat4x4<f32>,
visibility : f32,};var<uniform> mesh : Mesh;
#define WORLD_UBO
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const meshUboDeclarationWGSL = { name, shader };
//# sourceMappingURL=meshUboDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/oitDeclaration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/oitDeclaration.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   oitDeclarationWGSL: () => (/* binding */ oitDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "oitDeclaration";
const shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#define MAX_DEPTH 99999.0
var oitDepthSamplerSampler: sampler;var oitDepthSampler: texture_2d<f32>;var oitFrontColorSamplerSampler: sampler;var oitFrontColorSampler: texture_2d<f32>;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const oitDeclarationWGSL = { name, shader };
//# sourceMappingURL=oitDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/oitFragment.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/oitFragment.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   oitFragmentWGSL: () => (/* binding */ oitFragmentWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "oitFragment";
const shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
var fragDepth: f32=fragmentInputs.position.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uvar halfFloat: i32=packHalf2x16( vec2f(fragDepth));var full: vec2f=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
var fragCoord: vec2i=vec2i(fragmentInputs.position.xy);var lastDepth: vec2f=textureLoad(oitDepthSampler,fragCoord,0).rg;var lastFrontColor: vec4f=textureLoad(oitFrontColorSampler,fragCoord,0);fragmentOutputs.depth=vec2f(-MAX_DEPTH);fragmentOutputs.frontColor=lastFrontColor;fragmentOutputs.backColor= vec4f(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
var furthestDepth: f32=-lastDepth.x;var nearestDepth: f32=lastDepth.y;
#else
var nearestDepth: f32=-lastDepth.x;var furthestDepth: f32=lastDepth.y;
#endif
var alphaMultiplier: f32=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return fragmentOutputs;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
fragmentOutputs.depth=vec2f(-fragDepth,fragDepth);return fragmentOutputs;}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const oitFragmentWGSL = { name, shader };
//# sourceMappingURL=oitFragment.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassDeclaration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassDeclaration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prePassDeclarationWGSL: () => (/* binding */ prePassDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "prePassDeclaration";
const shader = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vViewPos: vec3f;
#endif
#ifdef PREPASS_VELOCITY
varying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const prePassDeclarationWGSL = { name, shader };
//# sourceMappingURL=prePassDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/reflectionFunction.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/reflectionFunction.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionFunctionWGSL: () => (/* binding */ reflectionFunctionWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "reflectionFunction";
const shader = `fn computeFixedEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,direction: vec3f)->vec3f
{var lon: f32=atan2(direction.z,direction.x);var lat: f32=acos(direction.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(s,t,0); }
fn computeMirroredFixedEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,direction: vec3f)->vec3f
{var lon: f32=atan2(direction.z,direction.x);var lat: f32=acos(direction.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(1.0-s,t,0); }
fn computeEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f
{var cameraToVertex: vec3f=normalize(worldPos.xyz-eyePosition);var r: vec3f=normalize(reflect(cameraToVertex,worldNormal));r= (reflectionMatrix* vec4f(r,0)).xyz;var lon: f32=atan2(r.z,r.x);var lat: f32=acos(r.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(s,t,0);}
fn computeSphericalCoords(worldPos: vec4f,worldNormal: vec3f,view: mat4x4f,reflectionMatrix: mat4x4f)->vec3f
{var viewDir: vec3f=normalize((view*worldPos).xyz);var viewNormal: vec3f=normalize((view* vec4f(worldNormal,0.0)).xyz);var r: vec3f=reflect(viewDir,viewNormal);r= (reflectionMatrix* vec4f(r,0)).xyz;r.z=r.z-1.0;var m: f32=2.0*length(r);return vec3f(r.x/m+0.5,1.0-r.y/m-0.5,0);}
fn computePlanarCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f
{var viewDir: vec3f=worldPos.xyz-eyePosition;var coords: vec3f=normalize(reflect(viewDir,worldNormal));return (reflectionMatrix* vec4f(coords,1)).xyz;}
fn computeCubicCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f
{var viewDir: vec3f=normalize(worldPos.xyz-eyePosition);var coords: vec3f=reflect(viewDir,worldNormal);coords= (reflectionMatrix* vec4f(coords,0)).xyz;
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
fn computeCubicLocalCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f,reflectionSize: vec3f,reflectionPosition: vec3f)->vec3f
{var viewDir: vec3f=normalize(worldPos.xyz-eyePosition);var coords: vec3f=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=(reflectionMatrix* vec4f(coords,0)).xyz;
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
fn computeProjectionCoords(worldPos: vec4f,view: mat4x4f,reflectionMatrix: mat4x4f)->vec3f
{return (reflectionMatrix*(view*worldPos)).xyz;}
fn computeSkyBoxCoords(positionW: vec3f,reflectionMatrix: mat4x4f)->vec3f
{return (reflectionMatrix* vec4f(positionW,1.)).xyz;}
#ifdef REFLECTION
fn computeReflectionCoords(worldPos: vec4f,worldNormal: vec3f)->vec3f
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
var direction: vec3f=normalize(fragmentInputs.vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
var direction: vec3f=normalize(fragmentInputs.vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,scene.view,uniforms.reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix,uniforms.vReflectionSize,uniforms.vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,scene.view,uniforms.reflectionMatrix);
#endif
#ifndef REFLECTIONMAP_CUBIC
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(fragmentInputs.vPositionUVW,uniforms.reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3f(0,0,0);
#endif
}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const reflectionFunctionWGSL = { name, shader };
//# sourceMappingURL=reflectionFunction.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerFragmentDeclaration.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerFragmentDeclaration.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   samplerFragmentDeclarationWGSL: () => (/* binding */ samplerFragmentDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "samplerFragmentDeclaration";
const shader = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying v_VARYINGNAME_UV: vec2f;
#endif
var _SAMPLERNAME_SamplerSampler: sampler;var _SAMPLERNAME_Sampler: texture_2d<f32>;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const samplerFragmentDeclarationWGSL = { name, shader };
//# sourceMappingURL=samplerFragmentDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/sceneUboDeclaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/sceneUboDeclaration.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sceneUboDeclarationWGSL: () => (/* binding */ sceneUboDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "sceneUboDeclaration";
const shader = `struct Scene {viewProjection : mat4x4<f32>,
#ifdef MULTIVIEW
viewProjectionR : mat4x4<f32>,
#endif 
view : mat4x4<f32>,
projection : mat4x4<f32>,
vEyePosition : vec4<f32>,};var<uniform> scene : Scene;
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const sceneUboDeclarationWGSL = { name, shader };
//# sourceMappingURL=sceneUboDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowsFragmentFunctions.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowsFragmentFunctions.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shadowsFragmentFunctionsWGSL: () => (/* binding */ shadowsFragmentFunctionsWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "shadowsFragmentFunctions";
const shader = `#ifdef SHADOWS
#ifndef SHADOWFLOAT
fn unpack(color: vec4f)->f32
{const bit_shift: vec4f= vec4f(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
fn computeFallOff(value: f32,clipSpace: vec2f,frustumEdgeFalloff: f32)->f32
{var mask: f32=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
fn computeShadowCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthValues: vec2f)->f32
{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
var shadow: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));
#else
var shadow: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;
#endif
return select(darkness,1.0,depth>shadow);}
fn computeShadowWithPoissonSamplingCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,mapSize: f32,darkness: f32,depthValues: vec2f)->f32
{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;var visibility: f32=1.;var poissonDisk: array<vec3f,4>;poissonDisk[0]= vec3f(-1.0,1.0,-1.0);poissonDisk[1]= vec3f(1.0,-1.0,-1.0);poissonDisk[2]= vec3f(-1.0,-1.0,-1.0);poissonDisk[3]= vec3f(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) {visibility-=0.25;};
#else
if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) {visibility-=0.25;};
#endif
return min(1.0,visibility+darkness);}
fn computeShadowWithESMCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,depthValues: vec2f)->f32
{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);var shadowPixelDepth: f32=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
var shadowMapSample: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));
#else
var shadowMapSample: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;
#endif
var esm: f32=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
fn computeShadowWithCloseESMCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,depthValues: vec2f)->f32
{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);var shadowPixelDepth: f32=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
var shadowMapSample: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));
#else
var shadowMapSample: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;
#endif
var esm: f32=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
fn computeShadowCSM(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d_array<f32>,shadowSampler: sampler,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
var shadow: f32=unpack(textureSample(shadowTexture,shadowSampler,uv,layer));
#else
var shadow: f32=textureSample(shadowTexture,shadowSampler,uv,layer).x;
#endif
return select(1.,computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff),shadowPixelDepth>shadow );}
fn computeShadow(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
var shadow: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));
#else
var shadow: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;
#endif
return select(1.,computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff),shadowPixelDepth>shadow );}}
fn computeShadowWithPoissonSampling(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,mapSize: f32,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);var visibility: f32=1.;var poissonDisk: array<vec2f,4>;poissonDisk[0]= vec2f(-0.94201624,-0.39906216);poissonDisk[1]= vec2f(0.94558609,-0.76890725);poissonDisk[2]= vec2f(-0.094184101,-0.92938870);poissonDisk[3]= vec2f(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}
if (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}
if (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}
if (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}
#else
if (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}
if (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}
if (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}
if (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
fn computeShadowWithESM(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
var shadowMapSample: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));
#else
var shadowMapSample: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;
#endif
var esm: f32=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
fn computeShadowWithCloseESM(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
var shadowMapSample: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));
#else
var shadowMapSample: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;
#endif
var esm: f32=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
fn getZInClip(clipSpace: vec3f,uvDepth: vec3f)->f32
{
#ifdef IS_NDC_HALF_ZRANGE
return clipSpace.z;
#else
return uvDepth.z;
#endif
}
const GREATEST_LESS_THAN_ONE: f32=0.99999994;
#define DISABLE_UNIFORMITY_ANALYSIS
fn computeShadowWithCSMPCF1(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var shadow: f32=textureSampleCompare(shadowTexture,shadowSampler,uvDepth.xy,layer,uvDepth.z);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
fn computeShadowWithCSMPCF3(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
var st: vec2f=fract(uv); 
var base_uv: vec2f=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
var uvw0: vec2f=3.-2.*st;var uvw1: vec2f=1.+2.*st;var u: vec2f= vec2f((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;var v: vec2f= vec2f((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),layer,uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),layer,uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),layer,uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),layer,uvDepth.z);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
fn computeShadowWithCSMPCF5(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
var st: vec2f=fract(uv); 
var base_uv: vec2f=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
var uvw0: vec2f=4.-3.*st;var uvw1: vec2f= vec2f(7.);var uvw2: vec2f=1.+3.*st;var u: vec3f= vec3f((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;var v: vec3f= vec3f((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),layer,uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),layer,uvDepth.z);shadow+=uvw2.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[0]),layer,uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),layer,uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),layer,uvDepth.z);shadow+=uvw2.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[1]),layer,uvDepth.z);shadow+=uvw0.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[2]),layer,uvDepth.z);shadow+=uvw1.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[2]),layer,uvDepth.z);shadow+=uvw2.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[2]),layer,uvDepth.z);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
fn computeShadowWithPCF1(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,darkness: f32,frustumEdgeFalloff: f32)->f32
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var shadow: f32=textureSampleCompareLevel(shadowTexture,shadowSampler,uvDepth.xy,uvDepth.z);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
fn computeShadowWithPCF3(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
var st: vec2f=fract(uv); 
var base_uv: vec2f=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
var uvw0: vec2f=3.-2.*st;var uvw1: vec2f=1.+2.*st;var u: vec2f= vec2f((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;var v: vec2f= vec2f((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),uvDepth.z);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
fn computeShadowWithPCF5(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
var st: vec2f=fract(uv); 
var base_uv: vec2f=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
var uvw0: vec2f=4.-3.*st;var uvw1: vec2f= vec2f(7.);var uvw2: vec2f=1.+3.*st;var u: vec3f= vec3f((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;var v: vec3f= vec3f((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),uvDepth.z);shadow+=uvw2.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[0]),uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),uvDepth.z);shadow+=uvw2.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[1]),uvDepth.z);shadow+=uvw0.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[2]),uvDepth.z);shadow+=uvw1.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[2]),uvDepth.z);shadow+=uvw2.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[2]),uvDepth.z);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const PoissonSamplers32: array<vec3f,64>=array<vec3f,64> (
vec3f(0.06407013,0.05409927,0.),
vec3f(0.7366577,0.5789394,0.),
vec3f(-0.6270542,-0.5320278,0.),
vec3f(-0.4096107,0.8411095,0.),
vec3f(0.6849564,-0.4990818,0.),
vec3f(-0.874181,-0.04579735,0.),
vec3f(0.9989998,0.0009880066,0.),
vec3f(-0.004920578,-0.9151649,0.),
vec3f(0.1805763,0.9747483,0.),
vec3f(-0.2138451,0.2635818,0.),
vec3f(0.109845,0.3884785,0.),
vec3f(0.06876755,-0.3581074,0.),
vec3f(0.374073,-0.7661266,0.),
vec3f(0.3079132,-0.1216763,0.),
vec3f(-0.3794335,-0.8271583,0.),
vec3f(-0.203878,-0.07715034,0.),
vec3f(0.5912697,0.1469799,0.),
vec3f(-0.88069,0.3031784,0.),
vec3f(0.5040108,0.8283722,0.),
vec3f(-0.5844124,0.5494877,0.),
vec3f(0.6017799,-0.1726654,0.),
vec3f(-0.5554981,0.1559997,0.),
vec3f(-0.3016369,-0.3900928,0.),
vec3f(-0.5550632,-0.1723762,0.),
vec3f(0.925029,0.2995041,0.),
vec3f(-0.2473137,0.5538505,0.),
vec3f(0.9183037,-0.2862392,0.),
vec3f(0.2469421,0.6718712,0.),
vec3f(0.3916397,-0.4328209,0.),
vec3f(-0.03576927,-0.6220032,0.),
vec3f(-0.04661255,0.7995201,0.),
vec3f(0.4402924,0.3640312,0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.)
);const PoissonSamplers64: array<vec3f,64>=array<vec3f,64> (
vec3f(-0.613392,0.617481,0.),
vec3f(0.170019,-0.040254,0.),
vec3f(-0.299417,0.791925,0.),
vec3f(0.645680,0.493210,0.),
vec3f(-0.651784,0.717887,0.),
vec3f(0.421003,0.027070,0.),
vec3f(-0.817194,-0.271096,0.),
vec3f(-0.705374,-0.668203,0.),
vec3f(0.977050,-0.108615,0.),
vec3f(0.063326,0.142369,0.),
vec3f(0.203528,0.214331,0.),
vec3f(-0.667531,0.326090,0.),
vec3f(-0.098422,-0.295755,0.),
vec3f(-0.885922,0.215369,0.),
vec3f(0.566637,0.605213,0.),
vec3f(0.039766,-0.396100,0.),
vec3f(0.751946,0.453352,0.),
vec3f(0.078707,-0.715323,0.),
vec3f(-0.075838,-0.529344,0.),
vec3f(0.724479,-0.580798,0.),
vec3f(0.222999,-0.215125,0.),
vec3f(-0.467574,-0.405438,0.),
vec3f(-0.248268,-0.814753,0.),
vec3f(0.354411,-0.887570,0.),
vec3f(0.175817,0.382366,0.),
vec3f(0.487472,-0.063082,0.),
vec3f(-0.084078,0.898312,0.),
vec3f(0.488876,-0.783441,0.),
vec3f(0.470016,0.217933,0.),
vec3f(-0.696890,-0.549791,0.),
vec3f(-0.149693,0.605762,0.),
vec3f(0.034211,0.979980,0.),
vec3f(0.503098,-0.308878,0.),
vec3f(-0.016205,-0.872921,0.),
vec3f(0.385784,-0.393902,0.),
vec3f(-0.146886,-0.859249,0.),
vec3f(0.643361,0.164098,0.),
vec3f(0.634388,-0.049471,0.),
vec3f(-0.688894,0.007843,0.),
vec3f(0.464034,-0.188818,0.),
vec3f(-0.440840,0.137486,0.),
vec3f(0.364483,0.511704,0.),
vec3f(0.034028,0.325968,0.),
vec3f(0.099094,-0.308023,0.),
vec3f(0.693960,-0.366253,0.),
vec3f(0.678884,-0.204688,0.),
vec3f(0.001801,0.780328,0.),
vec3f(0.145177,-0.898984,0.),
vec3f(0.062655,-0.611866,0.),
vec3f(0.315226,-0.604297,0.),
vec3f(-0.780145,0.486251,0.),
vec3f(-0.371868,0.882138,0.),
vec3f(0.200476,0.494430,0.),
vec3f(-0.494552,-0.711051,0.),
vec3f(0.612476,0.705252,0.),
vec3f(-0.578845,-0.768792,0.),
vec3f(-0.772454,-0.090976,0.),
vec3f(0.504440,0.372295,0.),
vec3f(0.155736,0.065157,0.),
vec3f(0.391522,0.849605,0.),
vec3f(-0.620106,-0.328104,0.),
vec3f(0.789239,-0.419965,0.),
vec3f(-0.545396,0.538133,0.),
vec3f(-0.178564,-0.596057,0.)
);fn computeShadowWithCSMPCSS(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,searchTapCount: i32,pcfTapCount: i32,poissonSamplers: array<vec3f,64>,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uvDepthLayer: vec4f= vec4f(uvDepth.x,uvDepth.y,f32(layer),uvDepth.z);var blockerDepth: f32=0.0;var sumBlockerDepth: f32=0.0;var numBlocker: f32=0.0;for (var i: i32=0; i<searchTapCount; i ++) {blockerDepth=textureSample(depthTexture,depthSampler, uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer).r;numBlocker+=select(0.,1.,blockerDepth<depthMetric);sumBlockerDepth+=select(0.,blockerDepth,blockerDepth<depthMetric);}
var avgBlockerDepth: f32=sumBlockerDepth/numBlocker;var AAOffset: f32=shadowMapSizeInverse*10.;var penumbraRatio: f32=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);var filterRadius: vec4f= vec4f(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);var random: f32=getRand(vPositionFromLight.xy);var rotationAngle: f32=random*3.1415926;var rotationVector: vec2f= vec2f(cos(rotationAngle),sin(rotationAngle));var shadow: f32=0.;for (var i: i32=0; i<pcfTapCount; i++) {var offset: vec4f= vec4f(poissonSamplers[i],0.);offset= vec4f(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);let coords=uvDepthLayer+offset*filterRadius;shadow+=textureSampleCompare(shadowTexture,shadowSampler,coords.xy,i32(coords.z),coords.w);}
shadow/= f32(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);return select(computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff),1.0,numBlocker<1.0);}
fn computeShadowWithPCSS(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,searchTapCount: i32,pcfTapCount: i32,poissonSamplers: array<vec3f,64>)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var blockerDepth: f32=0.0;var sumBlockerDepth: f32=0.0;var numBlocker: f32=0.0;var exitCondition: bool=depthMetric>1.0 || depthMetric<0.0;for (var i: i32=0; i<searchTapCount; i ++) {if (exitCondition) {break;}
blockerDepth=textureSampleLevel(depthTexture,depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0).r;numBlocker+=select(0.,1.,blockerDepth<depthMetric);sumBlockerDepth+=select(0.,blockerDepth,blockerDepth<depthMetric);}
exitCondition=exitCondition || numBlocker<1.0;var avgBlockerDepth: f32=sumBlockerDepth/numBlocker;var AAOffset: f32=shadowMapSizeInverse*10.;var penumbraRatio: f32=((depthMetric-avgBlockerDepth)+AAOffset);var filterRadius: f32=penumbraRatio*lightSizeUV*shadowMapSizeInverse;var random: f32=getRand(vPositionFromLight.xy);var rotationAngle: f32=random*3.1415926;var rotationVector: vec2f= vec2f(cos(rotationAngle),sin(rotationAngle));var shadow: f32=0.;for (var i: i32=0; i<pcfTapCount; i++) {if (exitCondition) {break;}
var offset: vec3f=poissonSamplers[i];offset= vec3f(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);let coords=uvDepth+offset*filterRadius;shadow+=textureSampleCompareLevel(shadowTexture,shadowSampler,coords.xy,coords.z);}
shadow/= f32(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return select(computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff),1.0,exitCondition);}
fn computeShadowWithPCSS16(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
fn computeShadowWithPCSS32(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
fn computeShadowWithPCSS64(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
fn computeShadowWithCSMPCSS16(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
fn computeShadowWithCSMPCSS32(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
fn computeShadowWithCSMPCSS64(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const shadowsFragmentFunctionsWGSL = { name, shader };
//# sourceMappingURL=shadowsFragmentFunctions.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfU2hhZGVyc1dHU0xfU2hhZGVyc0luY2x1ZGVfYnVtcEZyYWdtZW50X2pzLW5vZGVfbW9kdWxlc19iLWVjYWYwMi5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsaURBQWlELDZFQUE2RTtBQUMxTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EseUNBQXlDLGdDQUFnQyxvQ0FBb0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLDJCQUEyQjtBQUNsQzs7Ozs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUMyRDtBQUNsQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQiwwQkFBMEIsc0dBQXNHLDREQUE0RCw2QkFBNkIsZ0RBQWdELCtDQUErQyxxRkFBcUYsaUNBQWlDLDJCQUEyQixtQ0FBbUMsbUNBQW1DLCtCQUErQiwrQkFBK0IsMkJBQTJCLG1CQUFtQixlQUFlO0FBQzdyQixDQUFDLHVGQUF1RjtBQUN4RjtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0QsMkRBQTJELHNDQUFzQyx5REFBeUQ7QUFDM007QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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MEJBQTBCLDZCQUE2Qix3QkFBd0IsMkRBQTJELG1CQUFtQixrQkFBa0IsT0FBTyxvQkFBb0I7QUFDN1cscUlBQXFJLG1EQUFtRDtBQUN4TCw4Q0FBOEMsb0RBQW9ELDJDQUEyQyxnRUFBZ0UscUVBQXFFLCtDQUErQyx3Q0FBd0Msd0VBQXdFLG1CQUFtQixtQkFBbUIsZUFBZSxNQUFNLG9CQUFvQjtBQUNoZ0IscUNBQXFDLDBIQUEwSCx1Q0FBdUM7QUFDdE0sMEJBQTBCLGtEQUFrRCwrQkFBK0I7QUFDM0c7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLHVDQUF1QztBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2J1bXBGcmFnbWVudC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9idW1wRnJhZ21lbnRGdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvYnVtcEZyYWdtZW50TWFpbkZ1bmN0aW9ucy5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9jbGlwUGxhbmVGcmFnbWVudC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9jbGlwUGxhbmVGcmFnbWVudERlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2RlY2FsRnJhZ21lbnQuanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvZGVwdGhQcmVQYXNzLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2ZvZ0ZyYWdtZW50LmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2ZvZ0ZyYWdtZW50RGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvaGVscGVyRnVuY3Rpb25zLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2ltYWdlUHJvY2Vzc2luZ0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2ltYWdlUHJvY2Vzc2luZ0Z1bmN0aW9ucy5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9saWdodEZyYWdtZW50LmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2xpZ2h0VWJvRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvbG9nRGVwdGhEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9sb2dEZXB0aEZyYWdtZW50LmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL21haW5VVlZhcnlpbmdEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9tZXNoVWJvRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvb2l0RGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvb2l0RnJhZ21lbnQuanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvcHJlUGFzc0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL3JlZmxlY3Rpb25GdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9zYW1wbGVyRnJhZ21lbnREZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9zY2VuZVVib0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL3NoYWRvd3NGcmFnbWVudEZ1bmN0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImJ1bXBGcmFnbWVudFwiO1xuY29uc3Qgc2hhZGVyID0gYHZhciB1dk9mZnNldDogdmVjMmY9IHZlYzJmKDAuMCwwLjApO1xuI2lmIGRlZmluZWQoQlVNUCkgfHwgZGVmaW5lZChQQVJBTExBWCkgfHwgZGVmaW5lZChERVRBSUwpXG4jaWZkZWYgTk9STUFMWFlTQ0FMRVxudmFyIG5vcm1hbFNjYWxlOiBmMzI9MS4wO1xuI2VsaWYgZGVmaW5lZChCVU1QKVxudmFyIG5vcm1hbFNjYWxlOiBmMzI9dW5pZm9ybXMudkJ1bXBJbmZvcy55O1xuI2Vsc2VcbnZhciBub3JtYWxTY2FsZTogZjMyPTEuMDtcbiNlbmRpZlxuI2lmIGRlZmluZWQoVEFOR0VOVCkgJiYgZGVmaW5lZChOT1JNQUwpXG52YXIgVEJOOiBtYXQzeDNmPW1hdDN4MzxmMzI+KGlucHV0LnZUQk4wLGlucHV0LnZUQk4xLGlucHV0LnZUQk4yKTsgXG4jZWxpZiBkZWZpbmVkKEJVTVApXG52YXIgVEJOVVY6IHZlYzJmPXNlbGVjdCgtZnJhZ21lbnRJbnB1dHMudkJ1bXBVVixmcmFnbWVudElucHV0cy52QnVtcFVWLGZyYWdtZW50SW5wdXRzLmZyb250RmFjaW5nKTt2YXIgVEJOOiBtYXQzeDNmPWNvdGFuZ2VudF9mcmFtZShub3JtYWxXKm5vcm1hbFNjYWxlLGlucHV0LnZQb3NpdGlvblcsVEJOVVYsdW5pZm9ybXMudlRhbmdlbnRTcGFjZVBhcmFtcyk7XG4jZWxzZVxudmFyIFRCTlVWOiB2ZWMyZj1zZWxlY3QoLXZEZXRhaWxVVix2RGV0YWlsVVYsZnJhZ21lbnRJbnB1dHMuZnJvbnRGYWNpbmcpO3ZhciBUQk46IG1hdDN4M2Y9Y290YW5nZW50X2ZyYW1lKG5vcm1hbFcqbm9ybWFsU2NhbGUsaW5wdXQudlBvc2l0aW9uVyxUQk5VViwgdmVjMmYoMS4sMS4pKTtcbiNlbmRpZlxuI2VsaWYgZGVmaW5lZChBTklTT1RST1BJQylcbiNpZiBkZWZpbmVkKFRBTkdFTlQpICYmIGRlZmluZWQoTk9STUFMKVxudmFyIFRCTjogbWF0M3gzZj1tYXQzeDM8ZjMyPihpbnB1dC52VEJOMCxpbnB1dC52VEJOMSxpbnB1dC52VEJOMik7IFxuI2Vsc2VcbnZhciBUQk5VVjogdmVjMmY9c2VsZWN0KCAtZnJhZ21lbnRJbnB1dHMudk1haW5VVjEsZnJhZ21lbnRJbnB1dHMudk1haW5VVjEsZnJhZ21lbnRJbnB1dHMuZnJvbnRGYWNpbmcpO3ZhciBUQk46IG1hdDN4M2Y9Y290YW5nZW50X2ZyYW1lKG5vcm1hbFcsaW5wdXQudlBvc2l0aW9uVyxUQk5VViwgdmVjMmYoMS4sMS4pKTtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgUEFSQUxMQVhcbnZhciBpbnZUQk46IG1hdDN4M2Y9dHJhbnNwb3NlTWF0MyhUQk4pO1xuI2lmZGVmIFBBUkFMTEFYT0NDTFVTSU9OXG51dk9mZnNldD1wYXJhbGxheE9jY2x1c2lvbihpbnZUQk4qLXZpZXdEaXJlY3Rpb25XLGludlRCTipub3JtYWxXLGZyYWdtZW50SW5wdXRzLnZCdW1wVVYsdW5pZm9ybXMudkJ1bXBJbmZvcy56KTtcbiNlbHNlXG51dk9mZnNldD1wYXJhbGxheE9mZnNldChpbnZUQk4qdmlld0RpcmVjdGlvblcsdW5pZm9ybXMudkJ1bXBJbmZvcy56KTtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgREVUQUlMXG52YXIgZGV0YWlsQ29sb3I6IHZlYzRmPXRleHR1cmVTYW1wbGUoZGV0YWlsU2FtcGxlcixkZXRhaWxTYW1wbGVyU2FtcGxlcix2RGV0YWlsVVYrdXZPZmZzZXQpO3ZhciBkZXRhaWxOb3JtYWxSRzogdmVjMmY9ZGV0YWlsQ29sb3Iud3kqMi4wLTEuMDt2YXIgZGV0YWlsTm9ybWFsQjogZjMyPXNxcnQoMS4tc2F0dXJhdGUoZG90KGRldGFpbE5vcm1hbFJHLGRldGFpbE5vcm1hbFJHKSkpO3ZhciBkZXRhaWxOb3JtYWw6IHZlYzNmPSB2ZWMzZihkZXRhaWxOb3JtYWxSRyxkZXRhaWxOb3JtYWxCKTtcbiNlbmRpZlxuI2lmZGVmIEJVTVBcbiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcbiNkZWZpbmUgQ1VTVE9NX0ZSQUdNRU5UX0JVTVBfRlJBR01FTlRcbm5vcm1hbFc9bm9ybWFsaXplKHRleHR1cmVTYW1wbGUoYnVtcFNhbXBsZXIsYnVtcFNhbXBsZXJTYW1wbGVyLGZyYWdtZW50SW5wdXRzLnZCdW1wVVYpLnh5eiAqMi4wLTEuMCk7bm9ybWFsVz1ub3JtYWxpemUobWF0M3gzZih1bmlmb3Jtcy5ub3JtYWxNYXRyaXhbMF0ueHl6LHVuaWZvcm1zLm5vcm1hbE1hdHJpeFsxXS54eXosdW5pZm9ybXMubm9ybWFsTWF0cml4WzJdLnh5eikqbm9ybWFsVyk7XG4jZWxpZiAhZGVmaW5lZChERVRBSUwpXG5ub3JtYWxXPXBlcnR1cmJOb3JtYWwoVEJOLHRleHR1cmVTYW1wbGUoYnVtcFNhbXBsZXIsYnVtcFNhbXBsZXJTYW1wbGVyLGZyYWdtZW50SW5wdXRzLnZCdW1wVVYrdXZPZmZzZXQpLnh5eix1bmlmb3Jtcy52QnVtcEluZm9zLnkpO1xuI2Vsc2VcbnZhciBidW1wTm9ybWFsOiB2ZWMzZj10ZXh0dXJlU2FtcGxlKGJ1bXBTYW1wbGVyLGJ1bXBTYW1wbGVyU2FtcGxlcix2QnVtcFVWK3V2T2Zmc2V0KS54eXoqMi4wLTEuMDtcbiNpZiBERVRBSUxfTk9STUFMQkxFTkRNRVRIT0Q9PTAgXG5kZXRhaWxOb3JtYWwueHkqPXVuaWZvcm1zLnZEZXRhaWxJbmZvcy56O3ZhciBibGVuZGVkTm9ybWFsOiB2ZWMzZj1ub3JtYWxpemUoIHZlYzNmKGJ1bXBOb3JtYWwueHkrZGV0YWlsTm9ybWFsLnh5LGJ1bXBOb3JtYWwueipkZXRhaWxOb3JtYWwueikpO1xuI2VsaWYgREVUQUlMX05PUk1BTEJMRU5ETUVUSE9EPT0xIFxuZGV0YWlsTm9ybWFsLnh5Kj11bmlmb3Jtcy52RGV0YWlsSW5mb3MuejtidW1wTm9ybWFsKz0gdmVjM2YoMC4wLDAuMCwxLjApO2RldGFpbE5vcm1hbCo9IHZlYzNmKC0xLjAsLTEuMCwxLjApO3ZhciBibGVuZGVkTm9ybWFsOiB2ZWMzZj1idW1wTm9ybWFsKmRvdChidW1wTm9ybWFsLGRldGFpbE5vcm1hbCkvYnVtcE5vcm1hbC56LWRldGFpbE5vcm1hbDtcbiNlbmRpZlxubm9ybWFsVz1wZXJ0dXJiTm9ybWFsQmFzZShUQk4sYmxlbmRlZE5vcm1hbCx1bmlmb3Jtcy52QnVtcEluZm9zLnkpO1xuI2VuZGlmXG4jZWxpZiBkZWZpbmVkKERFVEFJTClcbmRldGFpbE5vcm1hbC54eSo9dkRldGFpbEluZm9zLno7bm9ybWFsVz1wZXJ0dXJiTm9ybWFsQmFzZShUQk4sZGV0YWlsTm9ybWFsLHVuaWZvcm1zLnZEZXRhaWxJbmZvcy56KTtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBidW1wRnJhZ21lbnRXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bXBGcmFnbWVudC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmltcG9ydCBcIi4vc2FtcGxlckZyYWdtZW50RGVjbGFyYXRpb24uanNcIjtcbmNvbnN0IG5hbWUgPSBcImJ1bXBGcmFnbWVudEZ1bmN0aW9uc1wiO1xuY29uc3Qgc2hhZGVyID0gYCNpZiBkZWZpbmVkKEJVTVApXG4jaW5jbHVkZTxzYW1wbGVyRnJhZ21lbnREZWNsYXJhdGlvbj4oX0RFRklORU5BTUVfLEJVTVAsX1ZBUllJTkdOQU1FXyxCdW1wLF9TQU1QTEVSTkFNRV8sYnVtcClcbiNlbmRpZlxuI2lmIGRlZmluZWQoREVUQUlMKVxuI2luY2x1ZGU8c2FtcGxlckZyYWdtZW50RGVjbGFyYXRpb24+KF9ERUZJTkVOQU1FXyxERVRBSUwsX1ZBUllJTkdOQU1FXyxEZXRhaWwsX1NBTVBMRVJOQU1FXyxkZXRhaWwpXG4jZW5kaWZcbiNpZiBkZWZpbmVkKEJVTVApICYmIGRlZmluZWQoUEFSQUxMQVgpXG5jb25zdCBtaW5TYW1wbGVzOiBmMzI9NC47Y29uc3QgbWF4U2FtcGxlczogZjMyPTE1Ljtjb25zdCBpTWF4U2FtcGxlczogaTMyPTE1O2ZuIHBhcmFsbGF4T2NjbHVzaW9uKHZWaWV3RGlyQ29UOiB2ZWMzZix2Tm9ybWFsQ29UOiB2ZWMzZix0ZXhDb29yZDogdmVjMmYscGFyYWxsYXhTY2FsZTogZjMyKS0+dmVjMmYge3ZhciBwYXJhbGxheExpbWl0OiBmMzI9bGVuZ3RoKHZWaWV3RGlyQ29ULnh5KS92Vmlld0RpckNvVC56O3BhcmFsbGF4TGltaXQqPXBhcmFsbGF4U2NhbGU7dmFyIHZPZmZzZXREaXI6IHZlYzJmPW5vcm1hbGl6ZSh2Vmlld0RpckNvVC54eSk7dmFyIHZNYXhPZmZzZXQ6IHZlYzJmPXZPZmZzZXREaXIqcGFyYWxsYXhMaW1pdDt2YXIgbnVtU2FtcGxlczogZjMyPW1heFNhbXBsZXMrKGRvdCh2Vmlld0RpckNvVCx2Tm9ybWFsQ29UKSoobWluU2FtcGxlcy1tYXhTYW1wbGVzKSk7dmFyIHN0ZXBTaXplOiBmMzI9MS4wL251bVNhbXBsZXM7dmFyIGN1cnJSYXlIZWlnaHQ6IGYzMj0xLjA7dmFyIHZDdXJyT2Zmc2V0OiB2ZWMyZj0gdmVjMmYoMCwwKTt2YXIgdkxhc3RPZmZzZXQ6IHZlYzJmPSB2ZWMyZigwLDApO3ZhciBsYXN0U2FtcGxlZEhlaWdodDogZjMyPTEuMDt2YXIgY3VyclNhbXBsZWRIZWlnaHQ6IGYzMj0xLjA7dmFyIGtlZXBXb3JraW5nOiBib29sPXRydWU7Zm9yICh2YXIgaTogaTMyPTA7IGk8aU1heFNhbXBsZXM7IGkrKylcbntjdXJyU2FtcGxlZEhlaWdodD10ZXh0dXJlU2FtcGxlKGJ1bXBTYW1wbGVyLGJ1bXBTYW1wbGVyU2FtcGxlcix0ZXhDb29yZCt2Q3Vyck9mZnNldCkudztpZiAoIWtlZXBXb3JraW5nKVxue31cbmVsc2UgaWYgKGN1cnJTYW1wbGVkSGVpZ2h0PmN1cnJSYXlIZWlnaHQpXG57dmFyIGRlbHRhMTogZjMyPWN1cnJTYW1wbGVkSGVpZ2h0LWN1cnJSYXlIZWlnaHQ7dmFyIGRlbHRhMjogZjMyPShjdXJyUmF5SGVpZ2h0K3N0ZXBTaXplKS1sYXN0U2FtcGxlZEhlaWdodDt2YXIgcmF0aW86IGYzMj1kZWx0YTEvKGRlbHRhMStkZWx0YTIpO3ZDdXJyT2Zmc2V0PShyYXRpbykqIHZMYXN0T2Zmc2V0KygxLjAtcmF0aW8pKnZDdXJyT2Zmc2V0O2tlZXBXb3JraW5nPWZhbHNlO31cbmVsc2VcbntjdXJyUmF5SGVpZ2h0LT1zdGVwU2l6ZTt2TGFzdE9mZnNldD12Q3Vyck9mZnNldDtcbiNpZmRlZiBQQVJBTExBWF9SSFNcbnZDdXJyT2Zmc2V0LT1zdGVwU2l6ZSp2TWF4T2Zmc2V0O1xuI2Vsc2VcbnZDdXJyT2Zmc2V0Kz1zdGVwU2l6ZSp2TWF4T2Zmc2V0O1xuI2VuZGlmXG5sYXN0U2FtcGxlZEhlaWdodD1jdXJyU2FtcGxlZEhlaWdodDt9fVxucmV0dXJuIHZDdXJyT2Zmc2V0O31cbmZuIHBhcmFsbGF4T2Zmc2V0KHZpZXdEaXI6IHZlYzNmLGhlaWdodFNjYWxlOiBmMzIpLT52ZWMyZlxue3ZhciBoZWlnaHQ6IGYzMj10ZXh0dXJlU2FtcGxlKGJ1bXBTYW1wbGVyLGJ1bXBTYW1wbGVyU2FtcGxlcixmcmFnbWVudElucHV0cy52QnVtcFVWKS53O3ZhciB0ZXhDb29yZE9mZnNldDogdmVjMmY9aGVpZ2h0U2NhbGUqdmlld0Rpci54eSpoZWlnaHQ7XG4jaWZkZWYgUEFSQUxMQVhfUkhTXG5yZXR1cm4gdGV4Q29vcmRPZmZzZXQ7XG4jZWxzZVxucmV0dXJuIC10ZXhDb29yZE9mZnNldDtcbiNlbmRpZlxufVxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGJ1bXBGcmFnbWVudEZ1bmN0aW9uc1dHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVtcEZyYWdtZW50RnVuY3Rpb25zLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiYnVtcEZyYWdtZW50TWFpbkZ1bmN0aW9uc1wiO1xuY29uc3Qgc2hhZGVyID0gYCNpZiBkZWZpbmVkKEJVTVApIHx8IGRlZmluZWQoQ0xFQVJDT0FUX0JVTVApIHx8IGRlZmluZWQoQU5JU09UUk9QSUMpIHx8IGRlZmluZWQoREVUQUlMKVxuI2lmIGRlZmluZWQoVEFOR0VOVCkgJiYgZGVmaW5lZChOT1JNQUwpIFxudmFyeWluZyB2VEJOMDogdmVjM2Y7dmFyeWluZyB2VEJOMTogdmVjM2Y7dmFyeWluZyB2VEJOMjogdmVjM2Y7XG4jZW5kaWZcbiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcbnVuaWZvcm0gbm9ybWFsTWF0cml4OiBtYXQ0eDRmO2ZuIHRvTm9ybWFsTWF0cml4KG06IG1hdDR4NGYpLT5tYXQ0eDRmXG57dmFyIGEwMD1tWzBdWzBdO3ZhciBhMDE9bVswXVsxXTt2YXIgYTAyPW1bMF1bMl07dmFyIGEwMz1tWzBdWzNdO3ZhciBhMTA9bVsxXVswXTt2YXIgYTExPW1bMV1bMV07dmFyIGExMj1tWzFdWzJdO3ZhciBhMTM9bVsxXVszXTt2YXIgYTIwPW1bMl1bMF07IFxudmFyIGEyMT1tWzJdWzFdO3ZhciBhMjI9bVsyXVsyXTt2YXIgYTIzPW1bMl1bM107dmFyIGEzMD1tWzNdWzBdOyBcbnZhciBhMzE9bVszXVsxXTt2YXIgYTMyPW1bM11bMl07dmFyIGEzMz1tWzNdWzNdO3ZhciBiMDA9YTAwKmExMS1hMDEqYTEwO3ZhciBiMDE9YTAwKmExMi1hMDIqYTEwO3ZhciBiMDI9YTAwKmExMy1hMDMqYTEwO3ZhciBiMDM9YTAxKmExMi1hMDIqYTExO3ZhciBiMDQ9YTAxKmExMy1hMDMqYTExO3ZhciBiMDU9YTAyKmExMy1hMDMqYTEyO3ZhciBiMDY9YTIwKmEzMS1hMjEqYTMwO3ZhciBiMDc9YTIwKmEzMi1hMjIqYTMwO3ZhciBiMDg9YTIwKmEzMy1hMjMqYTMwO3ZhciBiMDk9YTIxKmEzMi1hMjIqYTMxO3ZhciBiMTA9YTIxKmEzMy1hMjMqYTMxO3ZhciBiMTE9YTIyKmEzMy1hMjMqYTMyO3ZhciBkZXQ9YjAwKmIxMS1iMDEqYjEwK2IwMipiMDkrYjAzKmIwOC1iMDQqYjA3K2IwNSpiMDY7dmFyIG1pPW1hdDR4NDxmMzI+KFxuKGExMSpiMTEtYTEyKmIxMCthMTMqYjA5KS9kZXQsXG4oYTAyKmIxMC1hMDEqYjExLWEwMypiMDkpL2RldCxcbihhMzEqYjA1LWEzMipiMDQrYTMzKmIwMykvZGV0LFxuKGEyMipiMDQtYTIxKmIwNS1hMjMqYjAzKS9kZXQsXG4oYTEyKmIwOC1hMTAqYjExLWExMypiMDcpL2RldCxcbihhMDAqYjExLWEwMipiMDgrYTAzKmIwNykvZGV0LFxuKGEzMipiMDItYTMwKmIwNS1hMzMqYjAxKS9kZXQsXG4oYTIwKmIwNS1hMjIqYjAyK2EyMypiMDEpL2RldCxcbihhMTAqYjEwLWExMSpiMDgrYTEzKmIwNikvZGV0LFxuKGEwMSpiMDgtYTAwKmIxMC1hMDMqYjA2KS9kZXQsXG4oYTMwKmIwNC1hMzEqYjAyK2EzMypiMDApL2RldCxcbihhMjEqYjAyLWEyMCpiMDQtYTIzKmIwMCkvZGV0LFxuKGExMSpiMDctYTEwKmIwOS1hMTIqYjA2KS9kZXQsXG4oYTAwKmIwOS1hMDEqYjA3K2EwMipiMDYpL2RldCxcbihhMzEqYjAxLWEzMCpiMDMtYTMyKmIwMCkvZGV0LFxuKGEyMCpiMDMtYTIxKmIwMSthMjIqYjAwKS9kZXQpO3JldHVybiBtYXQ0eDQ8ZjMyPihtaVswXVswXSxtaVsxXVswXSxtaVsyXVswXSxtaVszXVswXSxcbm1pWzBdWzFdLG1pWzFdWzFdLG1pWzJdWzFdLG1pWzNdWzFdLFxubWlbMF1bMl0sbWlbMV1bMl0sbWlbMl1bMl0sbWlbM11bMl0sXG5taVswXVszXSxtaVsxXVszXSxtaVsyXVszXSxtaVszXVszXSk7fVxuI2VuZGlmXG5mbiBwZXJ0dXJiTm9ybWFsQmFzZShjb3RhbmdlbnRGcmFtZTogbWF0M3gzZixub3JtYWw6IHZlYzNmLHNjYWxlOiBmMzIpLT52ZWMzZlxue3ZhciBvdXRwdXQ9bm9ybWFsO1xuI2lmZGVmIE5PUk1BTFhZU0NBTEVcbm91dHB1dD1ub3JtYWxpemUob3V0cHV0KiB2ZWMzZihzY2FsZSxzY2FsZSwxLjApKTtcbiNlbmRpZlxucmV0dXJuIG5vcm1hbGl6ZShjb3RhbmdlbnRGcmFtZSpvdXRwdXQpO31cbmZuIHBlcnR1cmJOb3JtYWwoY290YW5nZW50RnJhbWU6IG1hdDN4M2YsdGV4dHVyZVNhbXBsZTogdmVjM2Ysc2NhbGU6IGYzMiktPnZlYzNmXG57cmV0dXJuIHBlcnR1cmJOb3JtYWxCYXNlKGNvdGFuZ2VudEZyYW1lLHRleHR1cmVTYW1wbGUqMi4wLTEuMCxzY2FsZSk7fVxuZm4gY290YW5nZW50X2ZyYW1lKG5vcm1hbDogdmVjM2YscDogdmVjM2YsdXY6IHZlYzJmLHRhbmdlbnRTcGFjZVBhcmFtczogdmVjMmYpLT5tYXQzeDNmXG57dmFyIGRwMTogdmVjM2Y9ZHBkeChwKTt2YXIgZHAyOiB2ZWMzZj1kcGR5KHApO3ZhciBkdXYxOiB2ZWMyZj1kcGR4KHV2KTt2YXIgZHV2MjogdmVjMmY9ZHBkeSh1dik7dmFyIGRwMnBlcnA6IHZlYzNmPWNyb3NzKGRwMixub3JtYWwpO3ZhciBkcDFwZXJwOiB2ZWMzZj1jcm9zcyhub3JtYWwsZHAxKTt2YXIgdGFuZ2VudDogdmVjM2Y9ZHAycGVycCpkdXYxLngrZHAxcGVycCpkdXYyLng7dmFyIGJpdGFuZ2VudDogdmVjM2Y9ZHAycGVycCpkdXYxLnkrZHAxcGVycCpkdXYyLnk7dGFuZ2VudCo9dGFuZ2VudFNwYWNlUGFyYW1zLng7Yml0YW5nZW50Kj10YW5nZW50U3BhY2VQYXJhbXMueTt2YXIgZGV0OiBmMzI9bWF4KGRvdCh0YW5nZW50LHRhbmdlbnQpLGRvdChiaXRhbmdlbnQsYml0YW5nZW50KSk7dmFyIGludm1heDogZjMyPXNlbGVjdChpbnZlcnNlU3FydChkZXQpLDAuMCxkZXQ9PTAuMCk7cmV0dXJuIG1hdDN4M2YodGFuZ2VudCppbnZtYXgsYml0YW5nZW50Kmludm1heCxub3JtYWwpO31cbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBidW1wRnJhZ21lbnRNYWluRnVuY3Rpb25zV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW1wRnJhZ21lbnRNYWluRnVuY3Rpb25zLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiY2xpcFBsYW5lRnJhZ21lbnRcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWYgZGVmaW5lZChDTElQUExBTkUpIHx8IGRlZmluZWQoQ0xJUFBMQU5FMikgfHwgZGVmaW5lZChDTElQUExBTkUzKSB8fCBkZWZpbmVkKENMSVBQTEFORTQpIHx8IGRlZmluZWQoQ0xJUFBMQU5FNSkgfHwgZGVmaW5lZChDTElQUExBTkU2KVxuaWYgKGZhbHNlKSB7fVxuI2VuZGlmXG4jaWZkZWYgQ0xJUFBMQU5FXG5lbHNlIGlmIChmcmFnbWVudElucHV0cy5mQ2xpcERpc3RhbmNlPjAuMClcbntkaXNjYXJkO31cbiNlbmRpZlxuI2lmZGVmIENMSVBQTEFORTJcbmVsc2UgaWYgKGZyYWdtZW50SW5wdXRzLmZDbGlwRGlzdGFuY2UyPjAuMClcbntkaXNjYXJkO31cbiNlbmRpZlxuI2lmZGVmIENMSVBQTEFORTNcbmVsc2UgaWYgKGZyYWdtZW50SW5wdXRzLmZDbGlwRGlzdGFuY2UzPjAuMClcbntkaXNjYXJkO31cbiNlbmRpZlxuI2lmZGVmIENMSVBQTEFORTRcbmVsc2UgaWYgKGZyYWdtZW50SW5wdXRzLmZDbGlwRGlzdGFuY2U0PjAuMClcbntkaXNjYXJkO31cbiNlbmRpZlxuI2lmZGVmIENMSVBQTEFORTVcbmVsc2UgaWYgKGZyYWdtZW50SW5wdXRzLmZDbGlwRGlzdGFuY2U1PjAuMClcbntkaXNjYXJkO31cbiNlbmRpZlxuI2lmZGVmIENMSVBQTEFORTZcbmVsc2UgaWYgKGZyYWdtZW50SW5wdXRzLmZDbGlwRGlzdGFuY2U2PjAuMClcbntkaXNjYXJkO31cbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBjbGlwUGxhbmVGcmFnbWVudFdHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpcFBsYW5lRnJhZ21lbnQuanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJjbGlwUGxhbmVGcmFnbWVudERlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIENMSVBQTEFORVxudmFyeWluZyBmQ2xpcERpc3RhbmNlOiBmMzI7XG4jZW5kaWZcbiNpZmRlZiBDTElQUExBTkUyXG52YXJ5aW5nIGZDbGlwRGlzdGFuY2UyOiBmMzI7XG4jZW5kaWZcbiNpZmRlZiBDTElQUExBTkUzXG52YXJ5aW5nIGZDbGlwRGlzdGFuY2UzOiBmMzI7XG4jZW5kaWZcbiNpZmRlZiBDTElQUExBTkU0XG52YXJ5aW5nIGZDbGlwRGlzdGFuY2U0OiBmMzI7XG4jZW5kaWZcbiNpZmRlZiBDTElQUExBTkU1XG52YXJ5aW5nIGZDbGlwRGlzdGFuY2U1OiBmMzI7XG4jZW5kaWZcbiNpZmRlZiBDTElQUExBTkU2XG52YXJ5aW5nIGZDbGlwRGlzdGFuY2U2OiBmMzI7XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgY2xpcFBsYW5lRnJhZ21lbnREZWNsYXJhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpcFBsYW5lRnJhZ21lbnREZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImRlY2FsRnJhZ21lbnRcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgREVDQUxcbnZhciBkZWNhbFRlbXBDb2xvcj1kZWNhbENvbG9yLnJnYjt2YXIgZGVjYWxUZW1wQWxwaGE9ZGVjYWxDb2xvci5hO1xuI2lmZGVmIEdBTU1BREVDQUxcbmRlY2FsVGVtcENvbG9yPXRvTGluZWFyU3BhY2VWZWMzKGRlY2FsQ29sb3IucmdiKTtcbiNlbmRpZlxuI2lmZGVmIERFQ0FMX1NNT09USEFMUEhBXG5kZWNhbFRlbXBBbHBoYT1kZWNhbENvbG9yLmEqZGVjYWxDb2xvci5hO1xuI2VuZGlmXG5zdXJmYWNlQWxiZWRvPW1peChzdXJmYWNlQWxiZWRvLnJnYixkZWNhbFRlbXBDb2xvcixkZWNhbFRlbXBBbHBoYSk7XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZGVjYWxGcmFnbWVudFdHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjYWxGcmFnbWVudC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImRlcHRoUHJlUGFzc1wiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBERVBUSFBSRVBBU1NcbmdsX0ZyYWdDb2xvcj0gdmVjNGYoMC4sMC4sMC4sMS4wKTtyZXR1cm47XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZGVwdGhQcmVQYXNzV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXB0aFByZVBhc3MuanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJmb2dGcmFnbWVudFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBGT0dcbnZhciBmb2c6IGYzMj1DYWxjRm9nRmFjdG9yKCk7XG4jaWZkZWYgUEJSXG5mb2c9dG9MaW5lYXJTcGFjZShmb2cpO1xuI2VuZGlmXG5jb2xvcj0gdmVjNGYobWl4KHVuaWZvcm1zLnZGb2dDb2xvcixjb2xvci5yZ2IsZm9nKSxjb2xvci5hKTtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBmb2dGcmFnbWVudFdHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9nRnJhZ21lbnQuanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJmb2dGcmFnbWVudERlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIEZPR1xuI2RlZmluZSBGT0dNT0RFX05PTkUgMC5cbiNkZWZpbmUgRk9HTU9ERV9FWFAgMS5cbiNkZWZpbmUgRk9HTU9ERV9FWFAyIDIuXG4jZGVmaW5lIEZPR01PREVfTElORUFSIDMuXG5jb25zdCBFPTIuNzE4Mjg7dW5pZm9ybSB2Rm9nSW5mb3M6IHZlYzRmO3VuaWZvcm0gdkZvZ0NvbG9yOiB2ZWMzZjt2YXJ5aW5nIHZGb2dEaXN0YW5jZTogdmVjM2Y7Zm4gQ2FsY0ZvZ0ZhY3RvcigpLT5mMzJcbnt2YXIgZm9nQ29lZmY6IGYzMj0xLjA7dmFyIGZvZ1N0YXJ0OiBmMzI9dW5pZm9ybXMudkZvZ0luZm9zLnk7dmFyIGZvZ0VuZDogZjMyPXVuaWZvcm1zLnZGb2dJbmZvcy56O3ZhciBmb2dEZW5zaXR5OiBmMzI9dW5pZm9ybXMudkZvZ0luZm9zLnc7dmFyIGZvZ0Rpc3RhbmNlOiBmMzI9bGVuZ3RoKGZyYWdtZW50SW5wdXRzLnZGb2dEaXN0YW5jZSk7aWYgKEZPR01PREVfTElORUFSPT11bmlmb3Jtcy52Rm9nSW5mb3MueClcbntmb2dDb2VmZj0oZm9nRW5kLWZvZ0Rpc3RhbmNlKS8oZm9nRW5kLWZvZ1N0YXJ0KTt9XG5lbHNlIGlmIChGT0dNT0RFX0VYUD09dW5pZm9ybXMudkZvZ0luZm9zLngpXG57Zm9nQ29lZmY9MS4wL3BvdyhFLGZvZ0Rpc3RhbmNlKmZvZ0RlbnNpdHkpO31cbmVsc2UgaWYgKEZPR01PREVfRVhQMj09dW5pZm9ybXMudkZvZ0luZm9zLngpXG57Zm9nQ29lZmY9MS4wL3BvdyhFLGZvZ0Rpc3RhbmNlKmZvZ0Rpc3RhbmNlKmZvZ0RlbnNpdHkqZm9nRGVuc2l0eSk7fVxucmV0dXJuIGNsYW1wKGZvZ0NvZWZmLDAuMCwxLjApO31cbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBmb2dGcmFnbWVudERlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2dGcmFnbWVudERlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiaGVscGVyRnVuY3Rpb25zXCI7XG5jb25zdCBzaGFkZXIgPSBgY29uc3QgUEk6IGYzMj0zLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTU7Y29uc3QgUkVDSVBST0NBTF9QSTogZjMyPTAuMzE4MzA5ODg2MTgzNzkwNztjb25zdCBSRUNJUFJPQ0FMX1BJMjogZjMyPTAuMTU5MTU0OTQzMDkxODk1MzU7Y29uc3QgSEFMRl9NSU46IGYzMj01Ljk2MDQ2NDQ4ZS0wODsgXG5jb25zdCBMaW5lYXJFbmNvZGVQb3dlckFwcHJveDogZjMyPTIuMjtjb25zdCBHYW1tYUVuY29kZVBvd2VyQXBwcm94OiBmMzI9MS4wL0xpbmVhckVuY29kZVBvd2VyQXBwcm94O2NvbnN0IEx1bWluYW5jZUVuY29kZUFwcHJveDogdmVjMzxmMzI+PXZlYzM8ZjMyPiAoMC4yMTI2LDAuNzE1MiwwLjA3MjIpO2NvbnN0IEVwc2lsb246ZjMyPTAuMDAwMDAwMTtmbiBzcXVhcmUoeDogZjMyKS0+ZjMyIHtyZXR1cm4geCp4O31cbmZuIHNhdHVyYXRlKHg6IGYzMiktPmYzMiB7cmV0dXJuIGNsYW1wKHgsMC4wLDEuMCk7fVxuZm4gc2F0dXJhdGVWZWMzKHg6IHZlYzNmKS0+dmVjM2Yge3JldHVybiBjbGFtcCh4LHZlYzNmKDAuMCksdmVjM2YoMS4wKSk7fVxuZm4gc2F0dXJhdGVFcHMoeDogZjMyKS0+ZjMyIHtyZXR1cm4gY2xhbXAoeCxFcHNpbG9uLDEuMCk7fSBcbmZuIG1heEVwcyh4OiBmMzIpLT5mMzIge3JldHVybiBtYXgoeCxFcHNpbG9uKTt9XG5mbiBtYXhFcHNWZWMzKHg6IHZlYzNmKS0+dmVjM2Yge3JldHVybiBtYXgoeCx2ZWMzZihFcHNpbG9uKSk7fVxuZm4gYWJzRXBzKHg6IGYzMiktPmYzMiB7cmV0dXJuIGFicyh4KStFcHNpbG9uO31cbmZuIHRyYW5zcG9zZU1hdDMoaW5NYXRyaXg6IG1hdDN4M2YpLT5tYXQzeDNmIHtsZXQgaTA6IHZlYzM8ZjMyPj1pbk1hdHJpeFswXTtsZXQgaTE6IHZlYzM8ZjMyPj1pbk1hdHJpeFsxXTtsZXQgaTI6IHZlYzM8ZjMyPj1pbk1hdHJpeFsyXTtsZXQgb3V0TWF0cml4Om1hdDN4M2Y9bWF0M3gzZihcbnZlYzMoaTAueCxpMS54LGkyLngpLFxudmVjMyhpMC55LGkxLnksaTIueSksXG52ZWMzKGkwLnosaTEueixpMi56KVxuKTtyZXR1cm4gb3V0TWF0cml4O31cbmZuIGludmVyc2VNYXQzKGluTWF0cml4OiBtYXQzeDNmKS0+bWF0M3gzZiB7bGV0IGEwMDogZjMyPWluTWF0cml4WzBdWzBdO2xldCBhMDE6IGYzMj1pbk1hdHJpeFswXVsxXTtsZXQgYTAyOiBmMzI9aW5NYXRyaXhbMF1bMl07bGV0IGExMDogZjMyPWluTWF0cml4WzFdWzBdO2xldCBhMTE6IGYzMj1pbk1hdHJpeFsxXVsxXTtsZXQgYTEyOiBmMzI9aW5NYXRyaXhbMV1bMl07bGV0IGEyMDogZjMyPWluTWF0cml4WzJdWzBdO2xldCBhMjE6IGYzMj1pbk1hdHJpeFsyXVsxXTtsZXQgYTIyOiBmMzI9aW5NYXRyaXhbMl1bMl07bGV0IGIwMTogZjMyPWEyMiphMTEtYTEyKmEyMTtsZXQgYjExOiBmMzI9LWEyMiphMTArYTEyKmEyMDtsZXQgYjIxOiBmMzI9YTIxKmExMC1hMTEqYTIwO2xldCBkZXQ6IGYzMj1hMDAqYjAxK2EwMSpiMTErYTAyKmIyMTtyZXR1cm4gbWF0M3gzZihiMDEvZGV0LCgtYTIyKmEwMSthMDIqYTIxKS9kZXQsKGExMiphMDEtYTAyKmExMSkvZGV0LFxuYjExL2RldCwoYTIyKmEwMC1hMDIqYTIwKS9kZXQsKC1hMTIqYTAwK2EwMiphMTApL2RldCxcbmIyMS9kZXQsKC1hMjEqYTAwK2EwMSphMjApL2RldCwoYTExKmEwMC1hMDEqYTEwKS9kZXQpO31cbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xuZm4gdG9MaW5lYXJTcGFjZUV4YWN0KGNvbG9yOiB2ZWMzPGYzMj4pLT52ZWMzPGYzMj5cbntsZXQgbmVhclplcm9TZWN0aW9uOiB2ZWMzPGYzMj49MC4wNzczOTkzODA4KmNvbG9yO2xldCByZW1haW5pbmdTZWN0aW9uOiB2ZWMzPGYzMj49cG93KDAuOTQ3ODY3Mjk5Kihjb2xvcit2ZWMzPGYzMj4oMC4wNTUpKSx2ZWMzPGYzMj4oMi40KSk7cmV0dXJuIG1peChyZW1haW5pbmdTZWN0aW9uLG5lYXJaZXJvU2VjdGlvbixsZXNzVGhhbkVxdWFsKGNvbG9yLHZlYzM8ZjMyPigwLjA0MDQ1KSkpO31cbmZuIHRvR2FtbWFTcGFjZUV4YWN0KGNvbG9yOiB2ZWMzPGYzMj4pLT52ZWMzPGYzMj5cbntsZXQgbmVhclplcm9TZWN0aW9uOiB2ZWMzPGYzMj49MTIuOTIqY29sb3I7bGV0IHJlbWFpbmluZ1NlY3Rpb246IHZlYzM8ZjMyPj0xLjA1NSpwb3coY29sb3IsdmVjMzxmMzI+KDAuNDE2NjYpKS12ZWMzPGYzMj4oMC4wNTUpO3JldHVybiBtaXgocmVtYWluaW5nU2VjdGlvbixuZWFyWmVyb1NlY3Rpb24sbGVzc1RoYW5FcXVhbChjb2xvcix2ZWMzPGYzMj4oMC4wMDMxMzA4KSkpO31cbiNlbmRpZlxuZm4gdG9MaW5lYXJTcGFjZShjb2xvcjogZjMyKS0+ZjMyXG57XG4jaWYgVVNFX0VYQUNUX1NSR0JfQ09OVkVSU0lPTlNcbnZhciBuZWFyWmVyb1NlY3Rpb249MC4wNzczOTkzODA4KmNvbG9yO3ZhciByZW1haW5pbmdTZWN0aW9uPXBvdygwLjk0Nzg2NzI5OSooY29sb3IrMC4wNTUpLDIuNCk7cmV0dXJuIHNlbGVjdChyZW1haW5pbmdTZWN0aW9uLG5lYXJaZXJvU2VjdGlvbixjb2xvcjw9MC4wNDA0NSk7XG4jZWxzZVxucmV0dXJuIHBvdyhjb2xvcixMaW5lYXJFbmNvZGVQb3dlckFwcHJveCk7XG4jZW5kaWZcbn1cbmZuIHRvTGluZWFyU3BhY2VWZWMzKGNvbG9yOiB2ZWMzPGYzMj4pLT52ZWMzPGYzMj5cbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xucmV0dXJuIHRvTGluZWFyU3BhY2VFeGFjdChjb2xvcik7XG4jZWxzZVxucmV0dXJuIHBvdyhjb2xvcix2ZWMzPGYzMj4oTGluZWFyRW5jb2RlUG93ZXJBcHByb3gpKTtcbiNlbmRpZlxufVxuZm4gdG9MaW5lYXJTcGFjZVZlYzQoY29sb3I6IHZlYzQ8ZjMyPiktPnZlYzQ8ZjMyPlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdmVjNGYodG9MaW5lYXJTcGFjZUV4YWN0KGNvbG9yLnJnYiksY29sb3IuYSk7XG4jZWxzZVxucmV0dXJuIHZlYzRmKHBvdyhjb2xvci5yZ2IsdmVjM2YoTGluZWFyRW5jb2RlUG93ZXJBcHByb3gpKSxjb2xvci5hKTtcbiNlbmRpZlxufVxuZm4gdG9HYW1tYVNwYWNlKGNvbG9yOiB2ZWM0PGYzMj4pLT52ZWM0PGYzMj5cbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xucmV0dXJuIHZlYzQ8ZjMyPih0b0dhbW1hU3BhY2VFeGFjdChjb2xvci5yZ2IpLGNvbG9yLmEpO1xuI2Vsc2VcbnJldHVybiB2ZWM0PGYzMj4ocG93KGNvbG9yLnJnYix2ZWMzPGYzMj4oR2FtbWFFbmNvZGVQb3dlckFwcHJveCkpLGNvbG9yLmEpO1xuI2VuZGlmXG59XG5mbiB0b0dhbW1hU3BhY2VWZWMzKGNvbG9yOiB2ZWMzPGYzMj4pLT52ZWMzPGYzMj5cbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xucmV0dXJuIHRvR2FtbWFTcGFjZUV4YWN0KGNvbG9yKTtcbiNlbHNlXG5yZXR1cm4gcG93KGNvbG9yLHZlYzM8ZjMyPihHYW1tYUVuY29kZVBvd2VyQXBwcm94KSk7XG4jZW5kaWZcbn1cbmZuIHNxdWFyZVZlYzModmFsdWU6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue3JldHVybiB2YWx1ZSp2YWx1ZTt9XG5mbiBwb3c1KHZhbHVlOiBmMzIpLT5mMzIge2xldCBzcTogZjMyPXZhbHVlKnZhbHVlO3JldHVybiBzcSpzcSp2YWx1ZTt9XG5mbiBnZXRMdW1pbmFuY2UoY29sb3I6IHZlYzM8ZjMyPiktPmYzMlxue3JldHVybiBjbGFtcChkb3QoY29sb3IsTHVtaW5hbmNlRW5jb2RlQXBwcm94KSwwLiwxLik7fVxuZm4gZ2V0UmFuZChzZWVkOiB2ZWMyPGYzMj4pLT5mMzIge3JldHVybiBmcmFjdChzaW4oZG90KHNlZWQueHkgLHZlYzI8ZjMyPigxMi45ODk4LDc4LjIzMykpKSo0Mzc1OC41NDUzKTt9XG5mbiBkaXRoZXIoc2VlZDogdmVjMjxmMzI+LHZhcmlhbmNlQW1vdW50OiBmMzIpLT5mMzIge2xldCByYW5kOiBmMzI9Z2V0UmFuZChzZWVkKTtsZXQgbm9ybVZhcmlhbmNlOiBmMzI9dmFyaWFuY2VBbW91bnQvMjU1LjA7bGV0IGRpdGhlcjogZjMyPW1peCgtbm9ybVZhcmlhbmNlLG5vcm1WYXJpYW5jZSxyYW5kKTtyZXR1cm4gZGl0aGVyO31cbmNvbnN0IHJnYmRNYXhSYW5nZTogZjMyPTI1NS4wO2ZuIHRvUkdCRChjb2xvcjogdmVjMzxmMzI+KS0+dmVjNDxmMzI+IHtsZXQgbWF4UkdCOiBmMzI9bWF4KG1heChjb2xvci5yLG1heChjb2xvci5nLGNvbG9yLmIpKSxFcHNpbG9uKTt2YXIgRDogZjMyID1tYXgocmdiZE1heFJhbmdlL21heFJHQiwxLik7RCA9Y2xhbXAoZmxvb3IoRCkvMjU1LjAsMC4sMS4pO3ZhciByZ2I6IHZlYzM8ZjMyPiA9Y29sb3IucmdiKkQ7cmdiPXRvR2FtbWFTcGFjZVZlYzMocmdiKTtyZXR1cm4gdmVjNDxmMzI+KGNsYW1wKHJnYix2ZWMzPGYzMj4oMC4sMC4sMC4pLHZlYzM8ZjMyPigxLiwxLiwxLikpLEQpOyB9XG5mbiBmcm9tUkdCRChyZ2JkOiB2ZWM0PGYzMj4pLT52ZWMzPGYzMj4ge2xldCByZ2I9dG9MaW5lYXJTcGFjZVZlYzMocmdiZC5yZ2IpO3JldHVybiByZ2IvcmdiZC5hO31cbmZuIHBhcmFsbGF4Q29ycmVjdE5vcm1hbCh2ZXJ0ZXhQb3M6IHZlYzM8ZjMyPixvcmlnVmVjOiB2ZWMzPGYzMj4sY3ViZVNpemU6IHZlYzM8ZjMyPixjdWJlUG9zOiB2ZWMzPGYzMj4pLT52ZWMzPGYzMj4ge2xldCBpbnZPcmlnVmVjOiB2ZWMzPGYzMj49dmVjMzxmMzI+KDEuMCwxLjAsMS4wKS9vcmlnVmVjO2xldCBoYWxmU2l6ZTogdmVjMzxmMzI+PWN1YmVTaXplKjAuNTtsZXQgaW50ZXJzZWNBdE1heFBsYW5lOiB2ZWMzPGYzMj49KGN1YmVQb3MraGFsZlNpemUtdmVydGV4UG9zKSppbnZPcmlnVmVjO2xldCBpbnRlcnNlY0F0TWluUGxhbmU6IHZlYzM8ZjMyPj0oY3ViZVBvcy1oYWxmU2l6ZS12ZXJ0ZXhQb3MpKmludk9yaWdWZWM7bGV0IGxhcmdlc3RJbnRlcnNlYzogdmVjMzxmMzI+PW1heChpbnRlcnNlY0F0TWF4UGxhbmUsaW50ZXJzZWNBdE1pblBsYW5lKTtsZXQgZGlzdGFuY2U6IGYzMj1taW4obWluKGxhcmdlc3RJbnRlcnNlYy54LGxhcmdlc3RJbnRlcnNlYy55KSxsYXJnZXN0SW50ZXJzZWMueik7bGV0IGludGVyc2VjdFBvc2l0aW9uV1M6IHZlYzM8ZjMyPj12ZXJ0ZXhQb3Mrb3JpZ1ZlYypkaXN0YW5jZTtyZXR1cm4gaW50ZXJzZWN0UG9zaXRpb25XUy1jdWJlUG9zO31cbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaGVscGVyRnVuY3Rpb25zV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJGdW5jdGlvbnMuanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJpbWFnZVByb2Nlc3NpbmdEZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBFWFBPU1VSRVxudW5pZm9ybSBleHBvc3VyZUxpbmVhcjogZjMyO1xuI2VuZGlmXG4jaWZkZWYgQ09OVFJBU1RcbnVuaWZvcm0gY29udHJhc3Q6IGYzMjtcbiNlbmRpZlxuI2lmIGRlZmluZWQoVklHTkVUVEUpIHx8IGRlZmluZWQoRElUSEVSKVxudW5pZm9ybSB2SW52ZXJzZVNjcmVlblNpemU6IHZlYzJmO1xuI2VuZGlmXG4jaWZkZWYgVklHTkVUVEVcbnVuaWZvcm0gdmlnbmV0dGVTZXR0aW5nczE6IHZlYzRmO3VuaWZvcm0gdmlnbmV0dGVTZXR0aW5nczI6IHZlYzRmO1xuI2VuZGlmXG4jaWZkZWYgQ09MT1JDVVJWRVNcbnVuaWZvcm0gdkNhbWVyYUNvbG9yQ3VydmVOZWdhdGl2ZTogdmVjNGY7dW5pZm9ybSB2Q2FtZXJhQ29sb3JDdXJ2ZU5ldXRyYWw6IHZlYzRmO3VuaWZvcm0gdkNhbWVyYUNvbG9yQ3VydmVQb3NpdGl2ZTogdmVjNGY7XG4jZW5kaWZcbiNpZmRlZiBDT0xPUkdSQURJTkdcbiNpZmRlZiBDT0xPUkdSQURJTkczRFxudmFyIHR4Q29sb3JUcmFuc2Zvcm1TYW1wbGVyOiBzYW1wbGVyO3ZhciB0eENvbG9yVHJhbnNmb3JtOiB0ZXh0dXJlXzNkPGYzMj47XG4jZWxzZVxudmFyIHR4Q29sb3JUcmFuc2Zvcm1TYW1wbGVyOiBzYW1wbGVyO3ZhciB0eENvbG9yVHJhbnNmb3JtOiB0ZXh0dXJlXzJkPGYzMj47XG4jZW5kaWZcbnVuaWZvcm0gY29sb3JUcmFuc2Zvcm1TZXR0aW5nczogdmVjNGY7XG4jZW5kaWZcbiNpZmRlZiBESVRIRVJcbnVuaWZvcm0gZGl0aGVySW50ZW5zaXR5OiBmMzI7XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaW1hZ2VQcm9jZXNzaW5nRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlUHJvY2Vzc2luZ0RlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiaW1hZ2VQcm9jZXNzaW5nRnVuY3Rpb25zXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmIFRPTkVNQVBQSU5HPT0zXG5jb25zdCBQQlJOZXV0cmFsU3RhcnRDb21wcmVzc2lvbjogZjMyPTAuOC0wLjA0O2NvbnN0IFBCUk5ldXRyYWxEZXNhdHVyYXRpb246IGYzMj0wLjE1O2ZuIFBCUk5ldXRyYWxUb25lTWFwcGluZyggY29sb3I6IHZlYzNmICktPnZlYzNmIHt2YXIgeDogZjMyPW1pbihjb2xvci5yLG1pbihjb2xvci5nLGNvbG9yLmIpKTt2YXIgb2Zmc2V0OiBmMzI9c2VsZWN0KDAuMDQseC02LjI1KngqeCx4PDAuMDgpO3ZhciByZXN1bHQ9Y29sb3I7cmVzdWx0LT1vZmZzZXQ7dmFyIHBlYWs6IGYzMj1tYXgocmVzdWx0LnIsbWF4KHJlc3VsdC5nLHJlc3VsdC5iKSk7aWYgKHBlYWs8UEJSTmV1dHJhbFN0YXJ0Q29tcHJlc3Npb24pIHtyZXR1cm4gcmVzdWx0O31cbnZhciBkOiBmMzI9MS4tUEJSTmV1dHJhbFN0YXJ0Q29tcHJlc3Npb247dmFyIG5ld1BlYWs6IGYzMj0xLi1kKmQvKHBlYWsrZC1QQlJOZXV0cmFsU3RhcnRDb21wcmVzc2lvbik7cmVzdWx0Kj1uZXdQZWFrL3BlYWs7dmFyIGc6IGYzMj0xLi0xLi8oUEJSTmV1dHJhbERlc2F0dXJhdGlvbioocGVhay1uZXdQZWFrKSsxLik7cmV0dXJuIG1peChyZXN1bHQsbmV3UGVhayogdmVjM2YoMSwxLDEpLGcpO31cbiNlbmRpZlxuI2lmIFRPTkVNQVBQSU5HPT0yXG5jb25zdCBBQ0VTSW5wdXRNYXQ6IG1hdDN4M2Y9IG1hdDN4M2YoXG52ZWMzZigwLjU5NzE5LDAuMDc2MDAsMC4wMjg0MCksXG52ZWMzZigwLjM1NDU4LDAuOTA4MzQsMC4xMzM4MyksXG52ZWMzZigwLjA0ODIzLDAuMDE1NjYsMC44Mzc3Nylcbik7Y29uc3QgQUNFU091dHB1dE1hdDogbWF0M3gzZj0gbWF0M3gzZihcbnZlYzNmKCAxLjYwNDc1LC0wLjEwMjA4LC0wLjAwMzI3KSxcbnZlYzNmKC0wLjUzMTA4LCAxLjEwODEzLC0wLjA3Mjc2KSxcbnZlYzNmKC0wLjA3MzY3LC0wLjAwNjA1LCAxLjA3NjAyKVxuKTtmbiBSUlRBbmRPRFRGaXQodjogdmVjM2YpLT52ZWMzZlxue3ZhciBhOiB2ZWMzZj12Kih2KzAuMDI0NTc4NiktMC4wMDAwOTA1Mzc7dmFyIGI6IHZlYzNmPXYqKDAuOTgzNzI5KnYrMC40MzI5NTEwKSswLjIzODA4MTtyZXR1cm4gYS9iO31cbmZuIEFDRVNGaXR0ZWQoY29sb3I6IHZlYzNmKS0+dmVjM2Zcbnt2YXIgb3V0cHV0PUFDRVNJbnB1dE1hdCpjb2xvcjtvdXRwdXQ9UlJUQW5kT0RURml0KG91dHB1dCk7b3V0cHV0PUFDRVNPdXRwdXRNYXQqb3V0cHV0O291dHB1dD1zYXR1cmF0ZVZlYzMob3V0cHV0KTtyZXR1cm4gb3V0cHV0O31cbiNlbmRpZlxuI2RlZmluZSBDVVNUT01fSU1BR0VQUk9DRVNTSU5HRlVOQ1RJT05TX0RFRklOSVRJT05TXG5mbiBhcHBseUltYWdlUHJvY2Vzc2luZyhyZXN1bHQ6IHZlYzRmKS0+dmVjNGYge1xuI2RlZmluZSBDVVNUT01fSU1BR0VQUk9DRVNTSU5HRlVOQ1RJT05TX1VQREFURVJFU1VMVF9BVFNUQVJUXG52YXIgcmdiPXJlc3VsdC5yZ2I7O1xuI2lmZGVmIEVYUE9TVVJFXG5yZ2IqPXVuaWZvcm1zLmV4cG9zdXJlTGluZWFyO1xuI2VuZGlmXG4jaWZkZWYgVklHTkVUVEVcbnZhciB2aWV3cG9ydFhZOiB2ZWMyZj1mcmFnbWVudElucHV0cy5wb3NpdGlvbi54eSp1bmlmb3Jtcy52SW52ZXJzZVNjcmVlblNpemU7dmlld3BvcnRYWT12aWV3cG9ydFhZKjIuMC0xLjA7dmFyIHZpZ25ldHRlWFkxOiB2ZWMzZj0gdmVjM2Yodmlld3BvcnRYWSp1bmlmb3Jtcy52aWduZXR0ZVNldHRpbmdzMS54eSt1bmlmb3Jtcy52aWduZXR0ZVNldHRpbmdzMS56dywxLjApO3ZhciB2aWduZXR0ZVRlcm06IGYzMj1kb3QodmlnbmV0dGVYWTEsdmlnbmV0dGVYWTEpO3ZhciB2aWduZXR0ZTogZjMyPXBvdyh2aWduZXR0ZVRlcm0sdW5pZm9ybXMudmlnbmV0dGVTZXR0aW5nczIudyk7dmFyIHZpZ25ldHRlQ29sb3I6IHZlYzNmPXVuaWZvcm1zLnZpZ25ldHRlU2V0dGluZ3MyLnJnYjtcbiNpZmRlZiBWSUdORVRURUJMRU5ETU9ERU1VTFRJUExZXG52YXIgdmlnbmV0dGVDb2xvck11bHRpcGxpZXI6IHZlYzNmPW1peCh2aWduZXR0ZUNvbG9yLCB2ZWMzZigxLDEsMSksdmlnbmV0dGUpO3JnYio9dmlnbmV0dGVDb2xvck11bHRpcGxpZXI7XG4jZW5kaWZcbiNpZmRlZiBWSUdORVRURUJMRU5ETU9ERU9QQVFVRVxucmdiPW1peCh2aWduZXR0ZUNvbG9yLHJnYix2aWduZXR0ZSk7XG4jZW5kaWZcbiNlbmRpZlxuI2lmIFRPTkVNQVBQSU5HPT0zXG5yZ2I9UEJSTmV1dHJhbFRvbmVNYXBwaW5nKHJnYik7XG4jZWxpZiBUT05FTUFQUElORz09MlxucmdiPUFDRVNGaXR0ZWQocmdiKTtcbiNlbGlmIFRPTkVNQVBQSU5HPT0xXG5jb25zdCB0b25lbWFwcGluZ0NhbGlicmF0aW9uOiBmMzI9MS41OTA1Nzk7cmdiPTEuMC1leHAyKC10b25lbWFwcGluZ0NhbGlicmF0aW9uKnJnYik7XG4jZW5kaWZcbnJnYj10b0dhbW1hU3BhY2VWZWMzKHJnYik7cmdiPXNhdHVyYXRlVmVjMyhyZ2IpO1xuI2lmZGVmIENPTlRSQVNUXG52YXIgcmVzdWx0SGlnaENvbnRyYXN0OiB2ZWMzZj1yZ2IqcmdiKigzLjAtMi4wKnJnYik7aWYgKHVuaWZvcm1zLmNvbnRyYXN0PDEuMCkge3JnYj1taXgoIHZlYzNmKDAuNSwwLjUsMC41KSxyZ2IsdW5pZm9ybXMuY29udHJhc3QpO30gZWxzZSB7cmdiPW1peChyZ2IscmVzdWx0SGlnaENvbnRyYXN0LHVuaWZvcm1zLmNvbnRyYXN0LTEuMCk7fVxuI2VuZGlmXG4jaWZkZWYgQ09MT1JHUkFESU5HXG52YXIgY29sb3JUcmFuc2Zvcm1JbnB1dDogdmVjM2Y9cmdiKnVuaWZvcm1zLmNvbG9yVHJhbnNmb3JtU2V0dGluZ3MueHh4K3VuaWZvcm1zLmNvbG9yVHJhbnNmb3JtU2V0dGluZ3MueXl5O1xuI2lmZGVmIENPTE9SR1JBRElORzNEXG52YXIgY29sb3JUcmFuc2Zvcm1PdXRwdXQ6IHZlYzNmPXRleHR1cmVTYW1wbGUodHhDb2xvclRyYW5zZm9ybSx0eENvbG9yVHJhbnNmb3JtU2FtcGxlcixjb2xvclRyYW5zZm9ybUlucHV0KS5yZ2I7XG4jZWxzZVxudmFyIGNvbG9yVHJhbnNmb3JtT3V0cHV0OiB2ZWMzZj10ZXh0dXJlU2FtcGxlKHR4Q29sb3JUcmFuc2Zvcm0sdHhDb2xvclRyYW5zZm9ybVNhbXBsZXIsY29sb3JUcmFuc2Zvcm1JbnB1dCx1bmlmb3Jtcy5jb2xvclRyYW5zZm9ybVNldHRpbmdzLnl6KS5yZ2I7XG4jZW5kaWZcbnJnYj1taXgocmdiLGNvbG9yVHJhbnNmb3JtT3V0cHV0LHVuaWZvcm1zLmNvbG9yVHJhbnNmb3JtU2V0dGluZ3Mud3d3KTtcbiNlbmRpZlxuI2lmZGVmIENPTE9SQ1VSVkVTXG52YXIgbHVtYTogZjMyPWdldEx1bWluYW5jZShyZ2IpO3ZhciBjdXJ2ZU1peDogdmVjMmY9Y2xhbXAoIHZlYzJmKGx1bWEqMy4wLTEuNSxsdW1hKi0zLjArMS41KSwgdmVjMmYoMC4wKSwgdmVjMmYoMS4wKSk7dmFyIGNvbG9yQ3VydmU6IHZlYzRmPXVuaWZvcm1zLnZDYW1lcmFDb2xvckN1cnZlTmV1dHJhbCtjdXJ2ZU1peC54KnVuaWZvcm1zLnZDYW1lcmFDb2xvckN1cnZlUG9zaXRpdmUtY3VydmVNaXgueSp1bmlmb3Jtcy52Q2FtZXJhQ29sb3JDdXJ2ZU5lZ2F0aXZlO3JnYio9Y29sb3JDdXJ2ZS5yZ2I7cmdiPW1peCggdmVjM2YobHVtYSkscmdiLGNvbG9yQ3VydmUuYSk7XG4jZW5kaWZcbiNpZmRlZiBESVRIRVJcbnZhciByYW5kOiBmMzI9Z2V0UmFuZChmcmFnbWVudElucHV0cy5wb3NpdGlvbi54eSp1bmlmb3Jtcy52SW52ZXJzZVNjcmVlblNpemUpO3ZhciBkaXRoZXI6IGYzMj1taXgoLXVuaWZvcm1zLmRpdGhlckludGVuc2l0eSx1bmlmb3Jtcy5kaXRoZXJJbnRlbnNpdHkscmFuZCk7cmdiPXNhdHVyYXRlVmVjMyhyZ2IrIHZlYzNmKGRpdGhlcikpO1xuI2VuZGlmXG4jZGVmaW5lIENVU1RPTV9JTUFHRVBST0NFU1NJTkdGVU5DVElPTlNfVVBEQVRFUkVTVUxUX0FURU5EXG5yZXR1cm4gdmVjNGYocmdiLHJlc3VsdC5hKTt9YDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpbWFnZVByb2Nlc3NpbmdGdW5jdGlvbnNXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlUHJvY2Vzc2luZ0Z1bmN0aW9ucy5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImxpZ2h0RnJhZ21lbnRcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTElHSFR7WH1cbiNpZiBkZWZpbmVkKFNIQURPV09OTFkpIHx8IGRlZmluZWQoTElHSFRNQVApICYmIGRlZmluZWQoTElHSFRNQVBFWENMVURFRHtYfSkgJiYgZGVmaW5lZChMSUdIVE1BUE5PU1BFQ1VMQVJ7WH0pXG4jZWxzZVxuI2lmZGVmIFBCUlxuI2lmZGVmIFNQT1RMSUdIVHtYfVxucHJlSW5mbz1jb21wdXRlUG9pbnRBbmRTcG90UHJlTGlnaHRpbmdJbmZvKGxpZ2h0e1h9LnZMaWdodERhdGEsdmlld0RpcmVjdGlvblcsbm9ybWFsVyxpbnB1dC52UG9zaXRpb25XKTtcbiNlbGlmIGRlZmluZWQoUE9JTlRMSUdIVHtYfSlcbnByZUluZm89Y29tcHV0ZVBvaW50QW5kU3BvdFByZUxpZ2h0aW5nSW5mbyhsaWdodHtYfS52TGlnaHREYXRhLHZpZXdEaXJlY3Rpb25XLG5vcm1hbFcsaW5wdXQudlBvc2l0aW9uVyk7XG4jZWxpZiBkZWZpbmVkKEhFTUlMSUdIVHtYfSlcbnByZUluZm89Y29tcHV0ZUhlbWlzcGhlcmljUHJlTGlnaHRpbmdJbmZvKGxpZ2h0e1h9LnZMaWdodERhdGEsdmlld0RpcmVjdGlvblcsbm9ybWFsVyk7XG4jZWxpZiBkZWZpbmVkKERJUkxJR0hUe1h9KVxucHJlSW5mbz1jb21wdXRlRGlyZWN0aW9uYWxQcmVMaWdodGluZ0luZm8obGlnaHR7WH0udkxpZ2h0RGF0YSx2aWV3RGlyZWN0aW9uVyxub3JtYWxXKTtcbiNlbmRpZlxucHJlSW5mby5OZG90Vj1OZG90VjtcbiNpZmRlZiBTUE9UTElHSFR7WH1cbiNpZmRlZiBMSUdIVF9GQUxMT0ZGX0dMVEZ7WH1cbnByZUluZm8uYXR0ZW51YXRpb249Y29tcHV0ZURpc3RhbmNlTGlnaHRGYWxsb2ZmX0dMVEYocHJlSW5mby5saWdodERpc3RhbmNlU3F1YXJlZCxsaWdodHtYfS52TGlnaHRGYWxsb2ZmLnkpO3ByZUluZm8uYXR0ZW51YXRpb24qPWNvbXB1dGVEaXJlY3Rpb25hbExpZ2h0RmFsbG9mZl9HTFRGKGxpZ2h0e1h9LnZMaWdodERpcmVjdGlvbi54eXoscHJlSW5mby5MLGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYueixsaWdodHtYfS52TGlnaHRGYWxsb2ZmLncpO1xuI2VsaWYgZGVmaW5lZChMSUdIVF9GQUxMT0ZGX1BIWVNJQ0FMe1h9KVxucHJlSW5mby5hdHRlbnVhdGlvbj1jb21wdXRlRGlzdGFuY2VMaWdodEZhbGxvZmZfUGh5c2ljYWwocHJlSW5mby5saWdodERpc3RhbmNlU3F1YXJlZCk7cHJlSW5mby5hdHRlbnVhdGlvbio9Y29tcHV0ZURpcmVjdGlvbmFsTGlnaHRGYWxsb2ZmX1BoeXNpY2FsKGxpZ2h0e1h9LnZMaWdodERpcmVjdGlvbi54eXoscHJlSW5mby5MLGxpZ2h0e1h9LnZMaWdodERpcmVjdGlvbi53KTtcbiNlbGlmIGRlZmluZWQoTElHSFRfRkFMTE9GRl9TVEFOREFSRHtYfSlcbnByZUluZm8uYXR0ZW51YXRpb249Y29tcHV0ZURpc3RhbmNlTGlnaHRGYWxsb2ZmX1N0YW5kYXJkKHByZUluZm8ubGlnaHRPZmZzZXQsbGlnaHR7WH0udkxpZ2h0RmFsbG9mZi54KTtwcmVJbmZvLmF0dGVudWF0aW9uKj1jb21wdXRlRGlyZWN0aW9uYWxMaWdodEZhbGxvZmZfU3RhbmRhcmQobGlnaHR7WH0udkxpZ2h0RGlyZWN0aW9uLnh5eixwcmVJbmZvLkwsbGlnaHR7WH0udkxpZ2h0RGlyZWN0aW9uLncsbGlnaHR7WH0udkxpZ2h0RGF0YS53KTtcbiNlbHNlXG5wcmVJbmZvLmF0dGVudWF0aW9uPWNvbXB1dGVEaXN0YW5jZUxpZ2h0RmFsbG9mZihwcmVJbmZvLmxpZ2h0T2Zmc2V0LHByZUluZm8ubGlnaHREaXN0YW5jZVNxdWFyZWQsbGlnaHR7WH0udkxpZ2h0RmFsbG9mZi54LGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYueSk7cHJlSW5mby5hdHRlbnVhdGlvbio9Y29tcHV0ZURpcmVjdGlvbmFsTGlnaHRGYWxsb2ZmKGxpZ2h0e1h9LnZMaWdodERpcmVjdGlvbi54eXoscHJlSW5mby5MLGxpZ2h0e1h9LnZMaWdodERpcmVjdGlvbi53LGxpZ2h0e1h9LnZMaWdodERhdGEudyxsaWdodHtYfS52TGlnaHRGYWxsb2ZmLnosbGlnaHR7WH0udkxpZ2h0RmFsbG9mZi53KTtcbiNlbmRpZlxuI2VsaWYgZGVmaW5lZChQT0lOVExJR0hUe1h9KVxuI2lmZGVmIExJR0hUX0ZBTExPRkZfR0xURntYfVxucHJlSW5mby5hdHRlbnVhdGlvbj1jb21wdXRlRGlzdGFuY2VMaWdodEZhbGxvZmZfR0xURihwcmVJbmZvLmxpZ2h0RGlzdGFuY2VTcXVhcmVkLGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYueSk7XG4jZWxpZiBkZWZpbmVkKExJR0hUX0ZBTExPRkZfUEhZU0lDQUx7WH0pXG5wcmVJbmZvLmF0dGVudWF0aW9uPWNvbXB1dGVEaXN0YW5jZUxpZ2h0RmFsbG9mZl9QaHlzaWNhbChwcmVJbmZvLmxpZ2h0RGlzdGFuY2VTcXVhcmVkKTtcbiNlbGlmIGRlZmluZWQoTElHSFRfRkFMTE9GRl9TVEFOREFSRHtYfSlcbnByZUluZm8uYXR0ZW51YXRpb249Y29tcHV0ZURpc3RhbmNlTGlnaHRGYWxsb2ZmX1N0YW5kYXJkKHByZUluZm8ubGlnaHRPZmZzZXQsbGlnaHR7WH0udkxpZ2h0RmFsbG9mZi54KTtcbiNlbHNlXG5wcmVJbmZvLmF0dGVudWF0aW9uPWNvbXB1dGVEaXN0YW5jZUxpZ2h0RmFsbG9mZihwcmVJbmZvLmxpZ2h0T2Zmc2V0LHByZUluZm8ubGlnaHREaXN0YW5jZVNxdWFyZWQsbGlnaHR7WH0udkxpZ2h0RmFsbG9mZi54LGxpZ2h0e1h9LnZMaWdodEZhbGxvZmYueSk7XG4jZW5kaWZcbiNlbHNlXG5wcmVJbmZvLmF0dGVudWF0aW9uPTEuMDtcbiNlbmRpZlxuI2lmZGVmIEhFTUlMSUdIVHtYfVxucHJlSW5mby5yb3VnaG5lc3M9cm91Z2huZXNzO1xuI2Vsc2VcbnByZUluZm8ucm91Z2huZXNzPWFkanVzdFJvdWdobmVzc0Zyb21MaWdodFByb3BlcnRpZXMocm91Z2huZXNzLGxpZ2h0e1h9LnZMaWdodFNwZWN1bGFyLmEscHJlSW5mby5saWdodERpc3RhbmNlKTtcbiNlbmRpZlxuI2lmZGVmIElSSURFU0NFTkNFXG5wcmVJbmZvLmlyaWRlc2NlbmNlSW50ZW5zaXR5PWlyaWRlc2NlbmNlSW50ZW5zaXR5O1xuI2VuZGlmXG4jaWZkZWYgSEVNSUxJR0hUe1h9XG5pbmZvLmRpZmZ1c2U9Y29tcHV0ZUhlbWlzcGhlcmljRGlmZnVzZUxpZ2h0aW5nKHByZUluZm8sbGlnaHR7WH0udkxpZ2h0RGlmZnVzZS5yZ2IsbGlnaHR7WH0udkxpZ2h0R3JvdW5kKTtcbiNlbGlmIGRlZmluZWQoU1NfVFJBTlNMVUNFTkNZKVxuaW5mby5kaWZmdXNlPWNvbXB1dGVEaWZmdXNlQW5kVHJhbnNtaXR0ZWRMaWdodGluZyhwcmVJbmZvLGxpZ2h0e1h9LnZMaWdodERpZmZ1c2UucmdiLHN1YlN1cmZhY2VPdXQudHJhbnNtaXR0YW5jZSk7XG4jZWxzZVxuaW5mby5kaWZmdXNlPWNvbXB1dGVEaWZmdXNlTGlnaHRpbmcocHJlSW5mbyxsaWdodHtYfS52TGlnaHREaWZmdXNlLnJnYik7XG4jZW5kaWZcbiNpZmRlZiBTUEVDVUxBUlRFUk1cbiNpZmRlZiBBTklTT1RST1BJQ1xuaW5mby5zcGVjdWxhcj1jb21wdXRlQW5pc290cm9waWNTcGVjdWxhckxpZ2h0aW5nKHByZUluZm8sdmlld0RpcmVjdGlvblcsbm9ybWFsVyxhbmlzb3Ryb3BpY091dC5hbmlzb3Ryb3BpY1RhbmdlbnQsYW5pc290cm9waWNPdXQuYW5pc290cm9waWNCaXRhbmdlbnQsYW5pc290cm9waWNPdXQuYW5pc290cm9weSxjbGVhcmNvYXRPdXQuc3BlY3VsYXJFbnZpcm9ubWVudFIwLHNwZWN1bGFyRW52aXJvbm1lbnRSOTAsQUFSb3VnaG5lc3NGYWN0b3JzLngsbGlnaHR7WH0udkxpZ2h0RGlmZnVzZS5yZ2IpO1xuI2Vsc2VcbmluZm8uc3BlY3VsYXI9Y29tcHV0ZVNwZWN1bGFyTGlnaHRpbmcocHJlSW5mbyxub3JtYWxXLGNsZWFyY29hdE91dC5zcGVjdWxhckVudmlyb25tZW50UjAsc3BlY3VsYXJFbnZpcm9ubWVudFI5MCxBQVJvdWdobmVzc0ZhY3RvcnMueCxsaWdodHtYfS52TGlnaHREaWZmdXNlLnJnYik7XG4jZW5kaWZcbiNlbmRpZlxuI2lmZGVmIFNIRUVOXG4jaWZkZWYgU0hFRU5fTElOS1dJVEhBTEJFRE9cbnByZUluZm8ucm91Z2huZXNzPXNoZWVuT3V0LnNoZWVuSW50ZW5zaXR5O1xuI2Vsc2VcbiNpZmRlZiBIRU1JTElHSFR7WH1cbnByZUluZm8ucm91Z2huZXNzPXNoZWVuT3V0LnNoZWVuUm91Z2huZXNzO1xuI2Vsc2VcbnByZUluZm8ucm91Z2huZXNzPWFkanVzdFJvdWdobmVzc0Zyb21MaWdodFByb3BlcnRpZXMoc2hlZW5PdXQuc2hlZW5Sb3VnaG5lc3MsbGlnaHR7WH0udkxpZ2h0U3BlY3VsYXIuYSxwcmVJbmZvLmxpZ2h0RGlzdGFuY2UpO1xuI2VuZGlmXG4jZW5kaWZcbmluZm8uc2hlZW49Y29tcHV0ZVNoZWVuTGlnaHRpbmcocHJlSW5mbyxub3JtYWxXLHNoZWVuT3V0LnNoZWVuQ29sb3Isc3BlY3VsYXJFbnZpcm9ubWVudFI5MCxBQVJvdWdobmVzc0ZhY3RvcnMueCxsaWdodHtYfS52TGlnaHREaWZmdXNlLnJnYik7XG4jZW5kaWZcbiNpZmRlZiBDTEVBUkNPQVRcbiNpZmRlZiBIRU1JTElHSFR7WH1cbnByZUluZm8ucm91Z2huZXNzPWNsZWFyY29hdE91dC5jbGVhckNvYXRSb3VnaG5lc3M7XG4jZWxzZVxucHJlSW5mby5yb3VnaG5lc3M9YWRqdXN0Um91Z2huZXNzRnJvbUxpZ2h0UHJvcGVydGllcyhjbGVhcmNvYXRPdXQuY2xlYXJDb2F0Um91Z2huZXNzLGxpZ2h0e1h9LnZMaWdodFNwZWN1bGFyLmEscHJlSW5mby5saWdodERpc3RhbmNlKTtcbiNlbmRpZlxuaW5mby5jbGVhckNvYXQ9Y29tcHV0ZUNsZWFyQ29hdExpZ2h0aW5nKHByZUluZm8sY2xlYXJjb2F0T3V0LmNsZWFyQ29hdE5vcm1hbFcsY2xlYXJjb2F0T3V0LmNsZWFyQ29hdEFBUm91Z2huZXNzRmFjdG9ycy54LGNsZWFyY29hdE91dC5jbGVhckNvYXRJbnRlbnNpdHksbGlnaHR7WH0udkxpZ2h0RGlmZnVzZS5yZ2IpO1xuI2lmZGVmIENMRUFSQ09BVF9USU5UXG5hYnNvcnB0aW9uPWNvbXB1dGVDbGVhckNvYXRMaWdodGluZ0Fic29ycHRpb24oY2xlYXJjb2F0T3V0LmNsZWFyQ29hdE5kb3RWUmVmcmFjdCxwcmVJbmZvLkwsY2xlYXJjb2F0T3V0LmNsZWFyQ29hdE5vcm1hbFcsY2xlYXJjb2F0T3V0LmNsZWFyQ29hdENvbG9yLGNsZWFyY29hdE91dC5jbGVhckNvYXRUaGlja25lc3MsY2xlYXJjb2F0T3V0LmNsZWFyQ29hdEludGVuc2l0eSk7aW5mby5kaWZmdXNlKj1hYnNvcnB0aW9uO1xuI2lmZGVmIFNQRUNVTEFSVEVSTVxuaW5mby5zcGVjdWxhcio9YWJzb3JwdGlvbjtcbiNlbmRpZlxuI2VuZGlmXG5pbmZvLmRpZmZ1c2UqPWluZm8uY2xlYXJDb2F0Lnc7XG4jaWZkZWYgU1BFQ1VMQVJURVJNXG5pbmZvLnNwZWN1bGFyKj1pbmZvLmNsZWFyQ29hdC53O1xuI2VuZGlmXG4jaWZkZWYgU0hFRU5cbmluZm8uc2hlZW4qPWluZm8uY2xlYXJDb2F0Lnc7XG4jZW5kaWZcbiNlbmRpZlxuI2Vsc2VcbiNpZmRlZiBTUE9UTElHSFR7WH1cbmluZm89Y29tcHV0ZVNwb3RMaWdodGluZyh2aWV3RGlyZWN0aW9uVyxub3JtYWxXLGxpZ2h0e1h9LnZMaWdodERhdGEsbGlnaHR7WH0udkxpZ2h0RGlyZWN0aW9uLGxpZ2h0e1h9LnZMaWdodERpZmZ1c2UucmdiLGxpZ2h0e1h9LnZMaWdodFNwZWN1bGFyLnJnYixsaWdodHtYfS52TGlnaHREaWZmdXNlLmEsZ2xvc3NpbmVzcyk7XG4jZWxpZiBkZWZpbmVkKEhFTUlMSUdIVHtYfSlcbmluZm89Y29tcHV0ZUhlbWlzcGhlcmljTGlnaHRpbmcodmlld0RpcmVjdGlvblcsbm9ybWFsVyxsaWdodHtYfS52TGlnaHREYXRhLGxpZ2h0e1h9LnZMaWdodERpZmZ1c2UucmdiLGxpZ2h0e1h9LnZMaWdodFNwZWN1bGFyLnJnYixsaWdodHtYfS52TGlnaHRHcm91bmQsZ2xvc3NpbmVzcyk7XG4jZWxpZiBkZWZpbmVkKFBPSU5UTElHSFR7WH0pIHx8IGRlZmluZWQoRElSTElHSFR7WH0pXG5pbmZvPWNvbXB1dGVMaWdodGluZyh2aWV3RGlyZWN0aW9uVyxub3JtYWxXLGxpZ2h0e1h9LnZMaWdodERhdGEsbGlnaHR7WH0udkxpZ2h0RGlmZnVzZS5yZ2IsbGlnaHR7WH0udkxpZ2h0U3BlY3VsYXIucmdiLGxpZ2h0e1h9LnZMaWdodERpZmZ1c2UuYSxnbG9zc2luZXNzKTtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgUFJPSkVDVEVETElHSFRURVhUVVJFe1h9XG5pbmZvLmRpZmZ1c2UqPWNvbXB1dGVQcm9qZWN0aW9uVGV4dHVyZURpZmZ1c2VMaWdodGluZyhwcm9qZWN0aW9uTGlnaHRUZXh0dXJle1h9LHByb2plY3Rpb25MaWdodFRleHR1cmV7WH1TYW1wbGVyLHVuaWZvcm1zLnRleHR1cmVQcm9qZWN0aW9uTWF0cml4e1h9LGlucHV0LnZQb3NpdGlvblcpO1xuI2VuZGlmXG4jZW5kaWZcbiNpZmRlZiBTSEFET1d7WH1cbiNpZmRlZiBTSEFET1dDU01ERUJVR3tYfSBcbnZhciBzaGFkb3dEZWJ1Z3tYfTogdmVjM2Y7XG4jZW5kaWZcbiNpZmRlZiBTSEFET1dDU017WH1cbiNpZmRlZiBTSEFET1dDU01VU0VTSEFET1dNQVhae1h9XG52YXIgaW5kZXh7WH06IGkzMj0tMTtcbiNlbHNlXG52YXIgaW5kZXh7WH06IGkzMj1TSEFET1dDU01OVU1fQ0FTQ0FERVN7WH0tMTtcbiNlbmRpZlxudmFyIGRpZmZ7WH06IGYzMj0wLjt2UG9zaXRpb25Gcm9tTGlnaHR7WH1bMF09ZnJhZ21lbnRJbnB1dHMudlBvc2l0aW9uRnJvbUxpZ2h0e1h9XzA7dlBvc2l0aW9uRnJvbUxpZ2h0e1h9WzFdPWZyYWdtZW50SW5wdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfV8xO3ZQb3NpdGlvbkZyb21MaWdodHtYfVsyXT1mcmFnbWVudElucHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH1fMjt2UG9zaXRpb25Gcm9tTGlnaHR7WH1bM109ZnJhZ21lbnRJbnB1dHMudlBvc2l0aW9uRnJvbUxpZ2h0e1h9XzM7dkRlcHRoTWV0cmlje1h9WzBdPWZyYWdtZW50SW5wdXRzLnZEZXB0aE1ldHJpY3tYfV8wO3ZEZXB0aE1ldHJpY3tYfVsxXT1mcmFnbWVudElucHV0cy52RGVwdGhNZXRyaWN7WH1fMTt2RGVwdGhNZXRyaWN7WH1bMl09ZnJhZ21lbnRJbnB1dHMudkRlcHRoTWV0cmlje1h9XzI7dkRlcHRoTWV0cmlje1h9WzNdPWZyYWdtZW50SW5wdXRzLnZEZXB0aE1ldHJpY3tYfV8zO2ZvciAodmFyIGk6aTMyPTA7IGk8U0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9OyBpKyspIFxue1xuI2lmZGVmIFNIQURPV0NTTV9SSUdIVEhBTkRFRHtYfVxuZGlmZntYfT11bmlmb3Jtcy52aWV3RnJ1c3R1bVp7WH1baV0rZnJhZ21lbnRJbnB1dHMudlBvc2l0aW9uRnJvbUNhbWVyYXtYfS56O1xuI2Vsc2VcbmRpZmZ7WH09dW5pZm9ybXMudmlld0ZydXN0dW1ae1h9W2ldLWZyYWdtZW50SW5wdXRzLnZQb3NpdGlvbkZyb21DYW1lcmF7WH0uejtcbiNlbmRpZlxuaWYgKGRpZmZ7WH0+PTAuKSB7aW5kZXh7WH09aTticmVhazt9fVxuI2lmZGVmIFNIQURPV0NTTVVTRVNIQURPV01BWFp7WH1cbmlmIChpbmRleHtYfT49MClcbiNlbmRpZlxue1xuI2lmIGRlZmluZWQoU0hBRE9XUENGe1h9KVxuI2lmIGRlZmluZWQoU0hBRE9XTE9XUVVBTElUWXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDRjEoaW5kZXh7WH0sdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2luZGV4e1h9XSx2RGVwdGhNZXRyaWN7WH1baW5kZXh7WH1dLHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbGlmIGRlZmluZWQoU0hBRE9XTUVESVVNUVVBTElUWXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDRjMoaW5kZXh7WH0sdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2luZGV4e1h9XSx2RGVwdGhNZXRyaWN7WH1baW5kZXh7WH1dLHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueXosbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbHNlXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhDU01QQ0Y1KGluZGV4e1h9LHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxzaGFkb3dUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyLGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnl6LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoU0hBRE9XUENTU3tYfSlcbiNpZiBkZWZpbmVkKFNIQURPV0xPV1FVQUxJVFl7WH0pXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhDU01QQ1NTMTYoaW5kZXh7WH0sdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2luZGV4e1h9XSx2RGVwdGhNZXRyaWN7WH1baW5kZXh7WH1dLGRlcHRoVGV4dHVyZXtYfSxkZXB0aFRleHR1cmV7WH1TYW1wbGVyLHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyx1bmlmb3Jtcy5saWdodFNpemVVVkNvcnJlY3Rpb257WH1baW5kZXh7WH1dLHVuaWZvcm1zLmRlcHRoQ29ycmVjdGlvbntYfVtpbmRleHtYfV0sdW5pZm9ybXMucGVudW1icmFEYXJrbmVzc3tYfSk7XG4jZWxpZiBkZWZpbmVkKFNIQURPV01FRElVTVFVQUxJVFl7WH0pXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhDU01QQ1NTMzIoaW5kZXh7WH0sdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2luZGV4e1h9XSx2RGVwdGhNZXRyaWN7WH1baW5kZXh7WH1dLGRlcHRoVGV4dHVyZXtYfSxkZXB0aFRleHR1cmV7WH1TYW1wbGVyLHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyx1bmlmb3Jtcy5saWdodFNpemVVVkNvcnJlY3Rpb257WH1baW5kZXh7WH1dLHVuaWZvcm1zLmRlcHRoQ29ycmVjdGlvbntYfVtpbmRleHtYfV0sdW5pZm9ybXMucGVudW1icmFEYXJrbmVzc3tYfSk7XG4jZWxzZVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUzY0KGluZGV4e1h9LHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxkZXB0aFRleHR1cmV7WH0sZGVwdGhUZXh0dXJle1h9U2FtcGxlcixzaGFkb3dUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyLGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnksbGlnaHR7WH0uc2hhZG93c0luZm8ueixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncsdW5pZm9ybXMubGlnaHRTaXplVVZDb3JyZWN0aW9ue1h9W2luZGV4e1h9XSx1bmlmb3Jtcy5kZXB0aENvcnJlY3Rpb257WH1baW5kZXh7WH1dLHVuaWZvcm1zLnBlbnVtYnJhRGFya25lc3N7WH0pO1xuI2VuZGlmXG4jZWxzZVxuc2hhZG93PWNvbXB1dGVTaGFkb3dDU00oaW5kZXh7WH0sdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2luZGV4e1h9XSx2RGVwdGhNZXRyaWN7WH1baW5kZXh7WH1dLHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbmRpZlxuI2lmZGVmIFNIQURPV0NTTURFQlVHe1h9XG5zaGFkb3dEZWJ1Z3tYfT12ZWMzZihzaGFkb3cpKnZDYXNjYWRlQ29sb3JzTXVsdGlwbGllcntYfVtpbmRleHtYfV07XG4jZW5kaWZcbiNpZm5kZWYgU0hBRE9XQ1NNTk9CTEVORHtYfVxudmFyIGZydXN0dW1MZW5ndGg6ZjMyPXVuaWZvcm1zLmZydXN0dW1MZW5ndGhze1h9W2luZGV4e1h9XTt2YXIgZGlmZlJhdGlvOmYzMj1jbGFtcChkaWZme1h9L2ZydXN0dW1MZW5ndGgsMC4sMS4pKnVuaWZvcm1zLmNhc2NhZGVCbGVuZEZhY3RvcntYfTtpZiAoaW5kZXh7WH08KFNIQURPV0NTTU5VTV9DQVNDQURFU3tYfS0xKSAmJiBkaWZmUmF0aW88MS4pXG57aW5kZXh7WH0rPTE7dmFyIG5leHRTaGFkb3c6IGYzMj0wLjtcbiNpZiBkZWZpbmVkKFNIQURPV1BDRntYfSlcbiNpZiBkZWZpbmVkKFNIQURPV0xPV1FVQUxJVFl7WH0pXG5uZXh0U2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoQ1NNUENGMShpbmRleHtYfSx2UG9zaXRpb25Gcm9tTGlnaHR7WH1baW5kZXh7WH1dLHZEZXB0aE1ldHJpY3tYfVtpbmRleHtYfV0sLHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyLGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZWxpZiBkZWZpbmVkKFNIQURPV01FRElVTVFVQUxJVFl7WH0pXG5uZXh0U2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoQ1NNUENGMyhpbmRleHtYfSx2UG9zaXRpb25Gcm9tTGlnaHR7WH1baW5kZXh7WH1dLHZEZXB0aE1ldHJpY3tYfVtpbmRleHtYfV0sc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby55eixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2Vsc2Vcbm5leHRTaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhDU01QQ0Y1KGluZGV4e1h9LHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxzaGFkb3dUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyLGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnl6LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoU0hBRE9XUENTU3tYfSlcbiNpZiBkZWZpbmVkKFNIQURPV0xPV1FVQUxJVFl7WH0pXG5uZXh0U2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUzE2KGluZGV4e1h9LHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxkZXB0aFRleHR1cmV7WH0sZGVwdGhUZXh0dXJle1h9U2FtcGxlcixzaGFkb3dUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyLGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnksbGlnaHR7WH0uc2hhZG93c0luZm8ueixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncsdW5pZm9ybXMubGlnaHRTaXplVVZDb3JyZWN0aW9ue1h9W2luZGV4e1h9XSx1bmlmb3Jtcy5kZXB0aENvcnJlY3Rpb257WH1baW5kZXh7WH1dLHVuaWZvcm1zLnBlbnVtYnJhRGFya25lc3N7WH0pO1xuI2VsaWYgZGVmaW5lZChTSEFET1dNRURJVU1RVUFMSVRZe1h9KVxubmV4dFNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENTTVBDU1MzMihpbmRleHtYfSx2UG9zaXRpb25Gcm9tTGlnaHR7WH1baW5kZXh7WH1dLHZEZXB0aE1ldHJpY3tYfVtpbmRleHtYfV0sZGVwdGhUZXh0dXJle1h9LGRlcHRoVGV4dHVyZXtYfVNhbXBsZXIsc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby55LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnosbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53LHVuaWZvcm1zLmxpZ2h0U2l6ZVVWQ29ycmVjdGlvbntYfVtpbmRleHtYfV0sdW5pZm9ybXMuZGVwdGhDb3JyZWN0aW9ue1h9W2luZGV4e1h9XSx1bmlmb3Jtcy5wZW51bWJyYURhcmtuZXNze1h9KTtcbiNlbHNlXG5uZXh0U2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUzY0KGluZGV4e1h9LHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxkZXB0aFRleHR1cmV7WH0sZGVwdGhUZXh0dXJle1h9U2FtcGxlcixzaGFkb3dUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyLGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnksbGlnaHR7WH0uc2hhZG93c0luZm8ueixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncsdW5pZm9ybXMubGlnaHRTaXplVVZDb3JyZWN0aW9ue1h9W2luZGV4e1h9XSx1bmlmb3Jtcy5kZXB0aENvcnJlY3Rpb257WH1baW5kZXh7WH1dLHVuaWZvcm1zLnBlbnVtYnJhRGFya25lc3N7WH0pO1xuI2VuZGlmXG4jZWxzZVxubmV4dFNoYWRvdz1jb21wdXRlU2hhZG93Q1NNKGluZGV4e1h9LHZQb3NpdGlvbkZyb21MaWdodHtYfVtpbmRleHtYfV0sdkRlcHRoTWV0cmlje1h9W2luZGV4e1h9XSxzaGFkb3dUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyLGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbnNoYWRvdz1taXgobmV4dFNoYWRvdyxzaGFkb3csZGlmZlJhdGlvKTtcbiNpZmRlZiBTSEFET1dDU01ERUJVR3tYfVxuc2hhZG93RGVidWd7WH09bWl4KHZlYzMobmV4dFNoYWRvdykqdkNhc2NhZGVDb2xvcnNNdWx0aXBsaWVye1h9W2luZGV4e1h9XSxzaGFkb3dEZWJ1Z3tYfSxkaWZmUmF0aW8pO1xuI2VuZGlmXG59XG4jZW5kaWZcbn1cbiNlbGlmIGRlZmluZWQoU0hBRE9XQ0xPU0VFU017WH0pXG4jaWYgZGVmaW5lZChTSEFET1dDVUJFe1h9KVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoQ2xvc2VFU01DdWJlKGlucHV0LnZQb3NpdGlvblcsbGlnaHR7WH0udkxpZ2h0RGF0YS54eXosc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnosbGlnaHR7WH0uZGVwdGhWYWx1ZXMpO1xuI2Vsc2VcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aENsb3NlRVNNKGZyYWdtZW50SW5wdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfSxmcmFnbWVudElucHV0cy52RGVwdGhNZXRyaWN7WH0sc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnosbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoU0hBRE9XRVNNe1h9KVxuI2lmIGRlZmluZWQoU0hBRE9XQ1VCRXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aEVTTUN1YmUoaW5wdXQudlBvc2l0aW9uVyxsaWdodHtYfS52TGlnaHREYXRhLnh5eixzaGFkb3dUZXh0dXJle1h9LHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyLGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8ueixsaWdodHtYfS5kZXB0aFZhbHVlcyk7XG4jZWxzZVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoRVNNKGZyYWdtZW50SW5wdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfSxmcmFnbWVudElucHV0cy52RGVwdGhNZXRyaWN7WH0sc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnosbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoU0hBRE9XUE9JU1NPTntYfSlcbiNpZiBkZWZpbmVkKFNIQURPV0NVQkV7WH0pXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhQb2lzc29uU2FtcGxpbmdDdWJlKGlucHV0LnZQb3NpdGlvblcsbGlnaHR7WH0udkxpZ2h0RGF0YS54eXosc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby55LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uZGVwdGhWYWx1ZXMpO1xuI2Vsc2VcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aFBvaXNzb25TYW1wbGluZyhmcmFnbWVudElucHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH0sZnJhZ21lbnRJbnB1dHMudkRlcHRoTWV0cmlje1h9LHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2VuZGlmXG4jZWxpZiBkZWZpbmVkKFNIQURPV1BDRntYfSlcbiNpZiBkZWZpbmVkKFNIQURPV0xPV1FVQUxJVFl7WH0pXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhQQ0YxKGZyYWdtZW50SW5wdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfSxmcmFnbWVudElucHV0cy52RGVwdGhNZXRyaWN7WH0sc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2VsaWYgZGVmaW5lZChTSEFET1dNRURJVU1RVUFMSVRZe1h9KVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoUENGMyhmcmFnbWVudElucHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH0sZnJhZ21lbnRJbnB1dHMudkRlcHRoTWV0cmlje1h9LHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueXosbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbHNlXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd1dpdGhQQ0Y1KGZyYWdtZW50SW5wdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfSxmcmFnbWVudElucHV0cy52RGVwdGhNZXRyaWN7WH0sc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby55eixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLncpO1xuI2VuZGlmXG4jZWxpZiBkZWZpbmVkKFNIQURPV1BDU1N7WH0pXG4jaWYgZGVmaW5lZChTSEFET1dMT1dRVUFMSVRZe1h9KVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoUENTUzE2KGZyYWdtZW50SW5wdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfSxmcmFnbWVudElucHV0cy52RGVwdGhNZXRyaWN7WH0sZGVwdGhUZXh0dXJle1h9LGRlcHRoVGV4dHVyZXtYfVNhbXBsZXIsc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby55LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnosbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbGlmIGRlZmluZWQoU0hBRE9XTUVESVVNUVVBTElUWXtYfSlcbnNoYWRvdz1jb21wdXRlU2hhZG93V2l0aFBDU1MzMihmcmFnbWVudElucHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH0sZnJhZ21lbnRJbnB1dHMudkRlcHRoTWV0cmlje1h9LGRlcHRoVGV4dHVyZXtYfSxkZXB0aFRleHR1cmV7WH1TYW1wbGVyLHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueSxsaWdodHtYfS5zaGFkb3dzSW5mby56LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLngsbGlnaHR7WH0uc2hhZG93c0luZm8udyk7XG4jZWxzZVxuc2hhZG93PWNvbXB1dGVTaGFkb3dXaXRoUENTUzY0KGZyYWdtZW50SW5wdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfSxmcmFnbWVudElucHV0cy52RGVwdGhNZXRyaWN7WH0sZGVwdGhUZXh0dXJle1h9LGRlcHRoVGV4dHVyZXtYfVNhbXBsZXIsc2hhZG93VGV4dHVyZXtYfSxzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby55LGxpZ2h0e1h9LnNoYWRvd3NJbmZvLnosbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbmRpZlxuI2Vsc2VcbiNpZiBkZWZpbmVkKFNIQURPV0NVQkV7WH0pXG5zaGFkb3c9Y29tcHV0ZVNoYWRvd0N1YmUoaW5wdXQudlBvc2l0aW9uVyxsaWdodHtYfS52TGlnaHREYXRhLnh5eixzaGFkb3dUZXh0dXJle1h9U2FtcGxlcixsaWdodHtYfS5zaGFkb3dzSW5mby54LGxpZ2h0e1h9LmRlcHRoVmFsdWVzKTtcbiNlbHNlXG5zaGFkb3c9Y29tcHV0ZVNoYWRvdyhmcmFnbWVudElucHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH0sZnJhZ21lbnRJbnB1dHMudkRlcHRoTWV0cmlje1h9LHNoYWRvd1RleHR1cmV7WH0sc2hhZG93VGV4dHVyZXtYfVNhbXBsZXIsbGlnaHR7WH0uc2hhZG93c0luZm8ueCxsaWdodHtYfS5zaGFkb3dzSW5mby53KTtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgU0hBRE9XT05MWVxuI2lmbmRlZiBTSEFET1dJTlVTRVxuI2RlZmluZSBTSEFET1dJTlVTRVxuI2VuZGlmXG5nbG9iYWxTaGFkb3crPXNoYWRvdztzaGFkb3dMaWdodENvdW50Kz0xLjA7XG4jZW5kaWZcbiNlbHNlXG5zaGFkb3c9MS47XG4jZW5kaWZcbmFnZ1NoYWRvdys9c2hhZG93O251bUxpZ2h0cys9MS4wO1xuI2lmbmRlZiBTSEFET1dPTkxZXG4jaWZkZWYgQ1VTVE9NVVNFUkxJR0hUSU5HXG5kaWZmdXNlQmFzZSs9Y29tcHV0ZUN1c3RvbURpZmZ1c2VMaWdodGluZyhpbmZvLGRpZmZ1c2VCYXNlLHNoYWRvdyk7XG4jaWZkZWYgU1BFQ1VMQVJURVJNXG5zcGVjdWxhckJhc2UrPWNvbXB1dGVDdXN0b21TcGVjdWxhckxpZ2h0aW5nKGluZm8sc3BlY3VsYXJCYXNlLHNoYWRvdyk7XG4jZW5kaWZcbiNlbGlmIGRlZmluZWQoTElHSFRNQVApICYmIGRlZmluZWQoTElHSFRNQVBFWENMVURFRHtYfSlcbmRpZmZ1c2VCYXNlKz1saWdodG1hcENvbG9yLnJnYipzaGFkb3c7XG4jaWZkZWYgU1BFQ1VMQVJURVJNXG4jaWZuZGVmIExJR0hUTUFQTk9TUEVDVUxBUntYfVxuc3BlY3VsYXJCYXNlKz1pbmZvLnNwZWN1bGFyKnNoYWRvdypsaWdodG1hcENvbG9yLnJnYjtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgQ0xFQVJDT0FUXG4jaWZuZGVmIExJR0hUTUFQTk9TUEVDVUxBUntYfVxuY2xlYXJDb2F0QmFzZSs9aW5mby5jbGVhckNvYXQucmdiKnNoYWRvdypsaWdodG1hcENvbG9yLnJnYjtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgU0hFRU5cbiNpZm5kZWYgTElHSFRNQVBOT1NQRUNVTEFSe1h9XG5zaGVlbkJhc2UrPWluZm8uc2hlZW4ucmdiKnNoYWRvdztcbiNlbmRpZlxuI2VuZGlmXG4jZWxzZVxuI2lmZGVmIFNIQURPV0NTTURFQlVHe1h9XG5kaWZmdXNlQmFzZSs9aW5mby5kaWZmdXNlKnNoYWRvd0RlYnVne1h9O1xuI2Vsc2UgXG5kaWZmdXNlQmFzZSs9aW5mby5kaWZmdXNlKnNoYWRvdztcbiNlbmRpZlxuI2lmZGVmIFNQRUNVTEFSVEVSTVxuc3BlY3VsYXJCYXNlKz1pbmZvLnNwZWN1bGFyKnNoYWRvdztcbiNlbmRpZlxuI2lmZGVmIENMRUFSQ09BVFxuY2xlYXJDb2F0QmFzZSs9aW5mby5jbGVhckNvYXQucmdiKnNoYWRvdztcbiNlbmRpZlxuI2lmZGVmIFNIRUVOXG5zaGVlbkJhc2UrPWluZm8uc2hlZW4ucmdiKnNoYWRvdztcbiNlbmRpZlxuI2VuZGlmXG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBsaWdodEZyYWdtZW50V0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWdodEZyYWdtZW50LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibGlnaHRVYm9EZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBMSUdIVHtYfVxuc3RydWN0IExpZ2h0e1h9XG57dkxpZ2h0RGF0YTogdmVjNGYsXG52TGlnaHREaWZmdXNlOiB2ZWM0ZixcbnZMaWdodFNwZWN1bGFyOiB2ZWM0ZixcbiNpZmRlZiBTUE9UTElHSFR7WH1cbnZMaWdodERpcmVjdGlvbjogdmVjNGYsXG52TGlnaHRGYWxsb2ZmOiB2ZWM0ZixcbiNlbGlmIGRlZmluZWQoUE9JTlRMSUdIVHtYfSlcbnZMaWdodEZhbGxvZmY6IHZlYzRmLFxuI2VsaWYgZGVmaW5lZChIRU1JTElHSFR7WH0pXG52TGlnaHRHcm91bmQ6IHZlYzNmLFxuI2VuZGlmXG5zaGFkb3dzSW5mbzogdmVjNGYsXG5kZXB0aFZhbHVlczogdmVjMmZ9IDt2YXI8dW5pZm9ybT4gbGlnaHR7WH0gOiBMaWdodHtYfTtcbiNpZmRlZiBQUk9KRUNURURMSUdIVFRFWFRVUkV7WH1cbnVuaWZvcm0gdGV4dHVyZVByb2plY3Rpb25NYXRyaXh7WH06IG1hdDR4NGY7dmFyIHByb2plY3Rpb25MaWdodFRleHR1cmV7WH1TYW1wbGVyOiBzYW1wbGVyO3ZhciBwcm9qZWN0aW9uTGlnaHRUZXh0dXJle1h9OiB0ZXh0dXJlXzJkPGYzMj47XG4jZW5kaWZcbiNpZmRlZiBTSEFET1d7WH1cbiNpZmRlZiBTSEFET1dDU017WH1cbnVuaWZvcm0gbGlnaHRNYXRyaXh7WH06IGFycmF5PG1hdDR4NGYsU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9Pjt1bmlmb3JtIHZpZXdGcnVzdHVtWntYfTogYXJyYXk8ZjMyLFNIQURPV0NTTU5VTV9DQVNDQURFU3tYfT47dW5pZm9ybSBmcnVzdHVtTGVuZ3Roc3tYfTogYXJyYXk8ZjMyLFNIQURPV0NTTU5VTV9DQVNDQURFU3tYfT47dW5pZm9ybSBjYXNjYWRlQmxlbmRGYWN0b3J7WH06IGYzMjt2YXJ5aW5nIHZQb3NpdGlvbkZyb21MaWdodHtYfV8wOiB2ZWM0Zjt2YXJ5aW5nIHZEZXB0aE1ldHJpY3tYfV8wOiBmMzI7dmFyeWluZyB2UG9zaXRpb25Gcm9tTGlnaHR7WH1fMTogdmVjNGY7dmFyeWluZyB2RGVwdGhNZXRyaWN7WH1fMTogZjMyO3ZhcnlpbmcgdlBvc2l0aW9uRnJvbUxpZ2h0e1h9XzI6IHZlYzRmO3ZhcnlpbmcgdkRlcHRoTWV0cmlje1h9XzI6IGYzMjt2YXJ5aW5nIHZQb3NpdGlvbkZyb21MaWdodHtYfV8zOiB2ZWM0Zjt2YXJ5aW5nIHZEZXB0aE1ldHJpY3tYfV8zOiBmMzI7dmFyeWluZyB2UG9zaXRpb25Gcm9tQ2FtZXJhe1h9OiB2ZWM0Zjt2YXI8cHJpdmF0ZT4gdlBvc2l0aW9uRnJvbUxpZ2h0e1h9OiBhcnJheTx2ZWM0Ziw0Pjt2YXI8cHJpdmF0ZT4gdkRlcHRoTWV0cmlje1h9IDogYXJyYXk8ZjMyLDQ+O1xuI2lmIGRlZmluZWQoU0hBRE9XUENTU3tYfSlcbnZhciBzaGFkb3dUZXh0dXJle1h9U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uOyBcbnZhciBzaGFkb3dUZXh0dXJle1h9OiB0ZXh0dXJlX2RlcHRoXzJkX2FycmF5O3ZhciBkZXB0aFRleHR1cmV7WH1TYW1wbGVyOiBzYW1wbGVyO3ZhciBkZXB0aFRleHR1cmV7WH06IHRleHR1cmVfMmRfYXJyYXk8ZjMyPjt1bmlmb3JtIGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbntYfTogYXJyYXk8dmVjMmYsU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9Pjt1bmlmb3JtIGRlcHRoQ29ycmVjdGlvbntYfTogYXJyYXk8ZjMyLFNIQURPV0NTTU5VTV9DQVNDQURFU3tYfT47dW5pZm9ybSBwZW51bWJyYURhcmtuZXNze1h9OiBmMzI7XG4jZWxpZiBkZWZpbmVkKFNIQURPV1BDRntYfSlcbnZhciBzaGFkb3dUZXh0dXJle1h9U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uO3ZhciBzaGFkb3dUZXh0dXJle1h9OiB0ZXh0dXJlX2RlcHRoXzJkX2FycmF5O1xuI2Vsc2UgXG52YXIgc2hhZG93VGV4dHVyZXtYfVNhbXBsZXI6IHNhbXBsZXI7IFxudmFyIHNoYWRvd1RleHR1cmV7WH06IHRleHR1cmVfMmRfYXJyYXk8ZjMyPjtcbiNlbmRpZlxuI2lmZGVmIFNIQURPV0NTTURFQlVHe1h9XG5jb25zdCB2Q2FzY2FkZUNvbG9yc011bHRpcGxpZXJ7WH06IGFycmF5PHZlYzNmLDg+PWFycmF5PHZlYzNmLDg+XG4oXG52ZWMzZiAoIDEuNSwwLjAsMC4wICksXG52ZWMzZiAoIDAuMCwxLjUsMC4wICksXG52ZWMzZiAoIDAuMCwwLjAsNS41ICksXG52ZWMzZiAoIDEuNSwwLjAsNS41ICksXG52ZWMzZiAoIDEuNSwxLjUsMC4wICksXG52ZWMzZiAoIDEuMCwxLjAsMS4wICksXG52ZWMzZiAoIDAuMCwxLjAsNS41ICksXG52ZWMzZiAoIDAuNSwzLjUsMC43NSApXG4pO1xuI2VuZGlmXG4jZWxpZiBkZWZpbmVkKFNIQURPV0NVQkV7WH0pXG52YXIgc2hhZG93VGV4dHVyZXtYfVNhbXBsZXI6IHNhbXBsZXI7dmFyIHNoYWRvd1RleHR1cmV7WH06IHRleHR1cmVfY3ViZTxmMzI+O1xuI2Vsc2VcbnZhcnlpbmcgdlBvc2l0aW9uRnJvbUxpZ2h0e1h9OiB2ZWM0Zjt2YXJ5aW5nIHZEZXB0aE1ldHJpY3tYfTogZjMyO1xuI2lmIGRlZmluZWQoU0hBRE9XUENTU3tYfSlcbnZhciBzaGFkb3dUZXh0dXJle1h9U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uOyBcbnZhciBzaGFkb3dUZXh0dXJle1h9OiB0ZXh0dXJlX2RlcHRoXzJkO3ZhciBkZXB0aFRleHR1cmV7WH1TYW1wbGVyOiBzYW1wbGVyOyBcbnZhciBkZXB0aFRleHR1cmV7WH06IHRleHR1cmVfMmQ8ZjMyPjtcbiNlbGlmIGRlZmluZWQoU0hBRE9XUENGe1h9KVxudmFyIHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyOiBzYW1wbGVyX2NvbXBhcmlzb247dmFyIHNoYWRvd1RleHR1cmV7WH06IHRleHR1cmVfZGVwdGhfMmQ7XG4jZWxzZVxudmFyIHNoYWRvd1RleHR1cmV7WH1TYW1wbGVyOiBzYW1wbGVyOyBcbnZhciBzaGFkb3dUZXh0dXJle1h9OiB0ZXh0dXJlXzJkPGYzMj47XG4jZW5kaWZcbnVuaWZvcm0gbGlnaHRNYXRyaXh7WH06IG1hdDR4NGY7XG4jZW5kaWZcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGxpZ2h0VWJvRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZ2h0VWJvRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJsb2dEZXB0aERlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIExPR0FSSVRITUlDREVQVEhcbnVuaWZvcm0gbG9nYXJpdGhtaWNEZXB0aENvbnN0YW50OiBmMzI7dmFyeWluZyB2RnJhZ21lbnREZXB0aDogZjMyO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGxvZ0RlcHRoRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ0RlcHRoRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJsb2dEZXB0aEZyYWdtZW50XCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIExPR0FSSVRITUlDREVQVEhcbmZyYWdtZW50T3V0cHV0cy5mcmFnRGVwdGg9bG9nMihmcmFnbWVudElucHV0cy52RnJhZ21lbnREZXB0aCkqdW5pZm9ybXMubG9nYXJpdGhtaWNEZXB0aENvbnN0YW50KjAuNTtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBsb2dEZXB0aEZyYWdtZW50V0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dEZXB0aEZyYWdtZW50LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibWFpblVWVmFyeWluZ0RlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIE1BSU5VVntYfVxudmFyeWluZyB2TWFpblVWe1h9OiB2ZWMyZjtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBtYWluVVZWYXJ5aW5nRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW5VVlZhcnlpbmdEZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcIm1lc2hVYm9EZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYHN0cnVjdCBNZXNoIHt3b3JsZCA6IG1hdDR4NDxmMzI+LFxudmlzaWJpbGl0eSA6IGYzMix9O3Zhcjx1bmlmb3JtPiBtZXNoIDogTWVzaDtcbiNkZWZpbmUgV09STERfVUJPXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG1lc2hVYm9EZWNsYXJhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzaFVib0RlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwib2l0RGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgT1JERVJfSU5ERVBFTkRFTlRfVFJBTlNQQVJFTkNZXG4jZGVmaW5lIE1BWF9ERVBUSCA5OTk5OS4wXG52YXIgb2l0RGVwdGhTYW1wbGVyU2FtcGxlcjogc2FtcGxlcjt2YXIgb2l0RGVwdGhTYW1wbGVyOiB0ZXh0dXJlXzJkPGYzMj47dmFyIG9pdEZyb250Q29sb3JTYW1wbGVyU2FtcGxlcjogc2FtcGxlcjt2YXIgb2l0RnJvbnRDb2xvclNhbXBsZXI6IHRleHR1cmVfMmQ8ZjMyPjtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBvaXREZWNsYXJhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2l0RGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJvaXRGcmFnbWVudFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBPUkRFUl9JTkRFUEVOREVOVF9UUkFOU1BBUkVOQ1lcbnZhciBmcmFnRGVwdGg6IGYzMj1mcmFnbWVudElucHV0cy5wb3NpdGlvbi56OyBcbiNpZmRlZiBPUkRFUl9JTkRFUEVOREVOVF9UUkFOU1BBUkVOQ1lfMTZCSVRTXG51dmFyIGhhbGZGbG9hdDogaTMyPXBhY2tIYWxmMngxNiggdmVjMmYoZnJhZ0RlcHRoKSk7dmFyIGZ1bGw6IHZlYzJmPXVucGFja0hhbGYyeDE2KGhhbGZGbG9hdCk7ZnJhZ0RlcHRoPWZ1bGwueDtcbiNlbmRpZlxudmFyIGZyYWdDb29yZDogdmVjMmk9dmVjMmkoZnJhZ21lbnRJbnB1dHMucG9zaXRpb24ueHkpO3ZhciBsYXN0RGVwdGg6IHZlYzJmPXRleHR1cmVMb2FkKG9pdERlcHRoU2FtcGxlcixmcmFnQ29vcmQsMCkucmc7dmFyIGxhc3RGcm9udENvbG9yOiB2ZWM0Zj10ZXh0dXJlTG9hZChvaXRGcm9udENvbG9yU2FtcGxlcixmcmFnQ29vcmQsMCk7ZnJhZ21lbnRPdXRwdXRzLmRlcHRoPXZlYzJmKC1NQVhfREVQVEgpO2ZyYWdtZW50T3V0cHV0cy5mcm9udENvbG9yPWxhc3RGcm9udENvbG9yO2ZyYWdtZW50T3V0cHV0cy5iYWNrQ29sb3I9IHZlYzRmKDAuMCk7XG4jaWZkZWYgVVNFX1JFVkVSU0VfREVQVEhCVUZGRVJcbnZhciBmdXJ0aGVzdERlcHRoOiBmMzI9LWxhc3REZXB0aC54O3ZhciBuZWFyZXN0RGVwdGg6IGYzMj1sYXN0RGVwdGgueTtcbiNlbHNlXG52YXIgbmVhcmVzdERlcHRoOiBmMzI9LWxhc3REZXB0aC54O3ZhciBmdXJ0aGVzdERlcHRoOiBmMzI9bGFzdERlcHRoLnk7XG4jZW5kaWZcbnZhciBhbHBoYU11bHRpcGxpZXI6IGYzMj0xLjAtbGFzdEZyb250Q29sb3IuYTtcbiNpZmRlZiBVU0VfUkVWRVJTRV9ERVBUSEJVRkZFUlxuaWYgKGZyYWdEZXB0aD5uZWFyZXN0RGVwdGggfHwgZnJhZ0RlcHRoPGZ1cnRoZXN0RGVwdGgpIHtcbiNlbHNlXG5pZiAoZnJhZ0RlcHRoPG5lYXJlc3REZXB0aCB8fCBmcmFnRGVwdGg+ZnVydGhlc3REZXB0aCkge1xuI2VuZGlmXG5yZXR1cm4gZnJhZ21lbnRPdXRwdXRzO31cbiNpZmRlZiBVU0VfUkVWRVJTRV9ERVBUSEJVRkZFUlxuaWYgKGZyYWdEZXB0aDxuZWFyZXN0RGVwdGggJiYgZnJhZ0RlcHRoPmZ1cnRoZXN0RGVwdGgpIHtcbiNlbHNlXG5pZiAoZnJhZ0RlcHRoPm5lYXJlc3REZXB0aCAmJiBmcmFnRGVwdGg8ZnVydGhlc3REZXB0aCkge1xuI2VuZGlmXG5mcmFnbWVudE91dHB1dHMuZGVwdGg9dmVjMmYoLWZyYWdEZXB0aCxmcmFnRGVwdGgpO3JldHVybiBmcmFnbWVudE91dHB1dHM7fVxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG9pdEZyYWdtZW50V0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vaXRGcmFnbWVudC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcInByZVBhc3NEZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBQUkVQQVNTXG4jaWZkZWYgUFJFUEFTU19ERVBUSFxudmFyeWluZyB2Vmlld1BvczogdmVjM2Y7XG4jZW5kaWZcbiNpZmRlZiBQUkVQQVNTX1ZFTE9DSVRZXG52YXJ5aW5nIHZDdXJyZW50UG9zaXRpb246IHZlYzRmO3ZhcnlpbmcgdlByZXZpb3VzUG9zaXRpb246IHZlYzRmO1xuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcHJlUGFzc0RlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVQYXNzRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJyZWZsZWN0aW9uRnVuY3Rpb25cIjtcbmNvbnN0IHNoYWRlciA9IGBmbiBjb21wdXRlRml4ZWRFcXVpcmVjdGFuZ3VsYXJDb29yZHMod29ybGRQb3M6IHZlYzRmLHdvcmxkTm9ybWFsOiB2ZWMzZixkaXJlY3Rpb246IHZlYzNmKS0+dmVjM2Zcbnt2YXIgbG9uOiBmMzI9YXRhbjIoZGlyZWN0aW9uLnosZGlyZWN0aW9uLngpO3ZhciBsYXQ6IGYzMj1hY29zKGRpcmVjdGlvbi55KTt2YXIgc3BoZXJlQ29vcmRzOiB2ZWMyZj0gdmVjMmYobG9uLGxhdCkqUkVDSVBST0NBTF9QSTIqMi4wO3ZhciBzOiBmMzI9c3BoZXJlQ29vcmRzLngqMC41KzAuNTt2YXIgdDogZjMyPXNwaGVyZUNvb3Jkcy55O3JldHVybiB2ZWMzZihzLHQsMCk7IH1cbmZuIGNvbXB1dGVNaXJyb3JlZEZpeGVkRXF1aXJlY3Rhbmd1bGFyQ29vcmRzKHdvcmxkUG9zOiB2ZWM0Zix3b3JsZE5vcm1hbDogdmVjM2YsZGlyZWN0aW9uOiB2ZWMzZiktPnZlYzNmXG57dmFyIGxvbjogZjMyPWF0YW4yKGRpcmVjdGlvbi56LGRpcmVjdGlvbi54KTt2YXIgbGF0OiBmMzI9YWNvcyhkaXJlY3Rpb24ueSk7dmFyIHNwaGVyZUNvb3JkczogdmVjMmY9IHZlYzJmKGxvbixsYXQpKlJFQ0lQUk9DQUxfUEkyKjIuMDt2YXIgczogZjMyPXNwaGVyZUNvb3Jkcy54KjAuNSswLjU7dmFyIHQ6IGYzMj1zcGhlcmVDb29yZHMueTtyZXR1cm4gdmVjM2YoMS4wLXMsdCwwKTsgfVxuZm4gY29tcHV0ZUVxdWlyZWN0YW5ndWxhckNvb3Jkcyh3b3JsZFBvczogdmVjNGYsd29ybGROb3JtYWw6IHZlYzNmLGV5ZVBvc2l0aW9uOiB2ZWMzZixyZWZsZWN0aW9uTWF0cml4OiBtYXQ0eDRmKS0+dmVjM2Zcbnt2YXIgY2FtZXJhVG9WZXJ0ZXg6IHZlYzNmPW5vcm1hbGl6ZSh3b3JsZFBvcy54eXotZXllUG9zaXRpb24pO3ZhciByOiB2ZWMzZj1ub3JtYWxpemUocmVmbGVjdChjYW1lcmFUb1ZlcnRleCx3b3JsZE5vcm1hbCkpO3I9IChyZWZsZWN0aW9uTWF0cml4KiB2ZWM0ZihyLDApKS54eXo7dmFyIGxvbjogZjMyPWF0YW4yKHIueixyLngpO3ZhciBsYXQ6IGYzMj1hY29zKHIueSk7dmFyIHNwaGVyZUNvb3JkczogdmVjMmY9IHZlYzJmKGxvbixsYXQpKlJFQ0lQUk9DQUxfUEkyKjIuMDt2YXIgczogZjMyPXNwaGVyZUNvb3Jkcy54KjAuNSswLjU7dmFyIHQ6IGYzMj1zcGhlcmVDb29yZHMueTtyZXR1cm4gdmVjM2Yocyx0LDApO31cbmZuIGNvbXB1dGVTcGhlcmljYWxDb29yZHMod29ybGRQb3M6IHZlYzRmLHdvcmxkTm9ybWFsOiB2ZWMzZix2aWV3OiBtYXQ0eDRmLHJlZmxlY3Rpb25NYXRyaXg6IG1hdDR4NGYpLT52ZWMzZlxue3ZhciB2aWV3RGlyOiB2ZWMzZj1ub3JtYWxpemUoKHZpZXcqd29ybGRQb3MpLnh5eik7dmFyIHZpZXdOb3JtYWw6IHZlYzNmPW5vcm1hbGl6ZSgodmlldyogdmVjNGYod29ybGROb3JtYWwsMC4wKSkueHl6KTt2YXIgcjogdmVjM2Y9cmVmbGVjdCh2aWV3RGlyLHZpZXdOb3JtYWwpO3I9IChyZWZsZWN0aW9uTWF0cml4KiB2ZWM0ZihyLDApKS54eXo7ci56PXIuei0xLjA7dmFyIG06IGYzMj0yLjAqbGVuZ3RoKHIpO3JldHVybiB2ZWMzZihyLngvbSswLjUsMS4wLXIueS9tLTAuNSwwKTt9XG5mbiBjb21wdXRlUGxhbmFyQ29vcmRzKHdvcmxkUG9zOiB2ZWM0Zix3b3JsZE5vcm1hbDogdmVjM2YsZXllUG9zaXRpb246IHZlYzNmLHJlZmxlY3Rpb25NYXRyaXg6IG1hdDR4NGYpLT52ZWMzZlxue3ZhciB2aWV3RGlyOiB2ZWMzZj13b3JsZFBvcy54eXotZXllUG9zaXRpb247dmFyIGNvb3JkczogdmVjM2Y9bm9ybWFsaXplKHJlZmxlY3Qodmlld0Rpcix3b3JsZE5vcm1hbCkpO3JldHVybiAocmVmbGVjdGlvbk1hdHJpeCogdmVjNGYoY29vcmRzLDEpKS54eXo7fVxuZm4gY29tcHV0ZUN1YmljQ29vcmRzKHdvcmxkUG9zOiB2ZWM0Zix3b3JsZE5vcm1hbDogdmVjM2YsZXllUG9zaXRpb246IHZlYzNmLHJlZmxlY3Rpb25NYXRyaXg6IG1hdDR4NGYpLT52ZWMzZlxue3ZhciB2aWV3RGlyOiB2ZWMzZj1ub3JtYWxpemUod29ybGRQb3MueHl6LWV5ZVBvc2l0aW9uKTt2YXIgY29vcmRzOiB2ZWMzZj1yZWZsZWN0KHZpZXdEaXIsd29ybGROb3JtYWwpO2Nvb3Jkcz0gKHJlZmxlY3Rpb25NYXRyaXgqIHZlYzRmKGNvb3JkcywwKSkueHl6O1xuI2lmZGVmIElOVkVSVENVQklDTUFQXG5jb29yZHMueSo9LTEuMDtcbiNlbmRpZlxucmV0dXJuIGNvb3Jkczt9XG5mbiBjb21wdXRlQ3ViaWNMb2NhbENvb3Jkcyh3b3JsZFBvczogdmVjNGYsd29ybGROb3JtYWw6IHZlYzNmLGV5ZVBvc2l0aW9uOiB2ZWMzZixyZWZsZWN0aW9uTWF0cml4OiBtYXQ0eDRmLHJlZmxlY3Rpb25TaXplOiB2ZWMzZixyZWZsZWN0aW9uUG9zaXRpb246IHZlYzNmKS0+dmVjM2Zcbnt2YXIgdmlld0RpcjogdmVjM2Y9bm9ybWFsaXplKHdvcmxkUG9zLnh5ei1leWVQb3NpdGlvbik7dmFyIGNvb3JkczogdmVjM2Y9cmVmbGVjdCh2aWV3RGlyLHdvcmxkTm9ybWFsKTtjb29yZHM9cGFyYWxsYXhDb3JyZWN0Tm9ybWFsKHdvcmxkUG9zLnh5eixjb29yZHMscmVmbGVjdGlvblNpemUscmVmbGVjdGlvblBvc2l0aW9uKTtjb29yZHM9KHJlZmxlY3Rpb25NYXRyaXgqIHZlYzRmKGNvb3JkcywwKSkueHl6O1xuI2lmZGVmIElOVkVSVENVQklDTUFQXG5jb29yZHMueSo9LTEuMDtcbiNlbmRpZlxucmV0dXJuIGNvb3Jkczt9XG5mbiBjb21wdXRlUHJvamVjdGlvbkNvb3Jkcyh3b3JsZFBvczogdmVjNGYsdmlldzogbWF0NHg0ZixyZWZsZWN0aW9uTWF0cml4OiBtYXQ0eDRmKS0+dmVjM2ZcbntyZXR1cm4gKHJlZmxlY3Rpb25NYXRyaXgqKHZpZXcqd29ybGRQb3MpKS54eXo7fVxuZm4gY29tcHV0ZVNreUJveENvb3Jkcyhwb3NpdGlvblc6IHZlYzNmLHJlZmxlY3Rpb25NYXRyaXg6IG1hdDR4NGYpLT52ZWMzZlxue3JldHVybiAocmVmbGVjdGlvbk1hdHJpeCogdmVjNGYocG9zaXRpb25XLDEuKSkueHl6O31cbiNpZmRlZiBSRUZMRUNUSU9OXG5mbiBjb21wdXRlUmVmbGVjdGlvbkNvb3Jkcyh3b3JsZFBvczogdmVjNGYsd29ybGROb3JtYWw6IHZlYzNmKS0+dmVjM2ZcbntcbiNpZmRlZiBSRUZMRUNUSU9OTUFQX01JUlJPUkVERVFVSVJFQ1RBTkdVTEFSX0ZJWEVEXG52YXIgZGlyZWN0aW9uOiB2ZWMzZj1ub3JtYWxpemUoZnJhZ21lbnRJbnB1dHMudkRpcmVjdGlvblcpO3JldHVybiBjb21wdXRlTWlycm9yZWRGaXhlZEVxdWlyZWN0YW5ndWxhckNvb3Jkcyh3b3JsZFBvcyx3b3JsZE5vcm1hbCxkaXJlY3Rpb24pO1xuI2VuZGlmXG4jaWZkZWYgUkVGTEVDVElPTk1BUF9FUVVJUkVDVEFOR1VMQVJfRklYRURcbnZhciBkaXJlY3Rpb246IHZlYzNmPW5vcm1hbGl6ZShmcmFnbWVudElucHV0cy52RGlyZWN0aW9uVyk7cmV0dXJuIGNvbXB1dGVGaXhlZEVxdWlyZWN0YW5ndWxhckNvb3Jkcyh3b3JsZFBvcyx3b3JsZE5vcm1hbCxkaXJlY3Rpb24pO1xuI2VuZGlmXG4jaWZkZWYgUkVGTEVDVElPTk1BUF9FUVVJUkVDVEFOR1VMQVJcbnJldHVybiBjb21wdXRlRXF1aXJlY3Rhbmd1bGFyQ29vcmRzKHdvcmxkUG9zLHdvcmxkTm9ybWFsLHNjZW5lLnZFeWVQb3NpdGlvbi54eXosdW5pZm9ybXMucmVmbGVjdGlvbk1hdHJpeCk7XG4jZW5kaWZcbiNpZmRlZiBSRUZMRUNUSU9OTUFQX1NQSEVSSUNBTFxucmV0dXJuIGNvbXB1dGVTcGhlcmljYWxDb29yZHMod29ybGRQb3Msd29ybGROb3JtYWwsc2NlbmUudmlldyx1bmlmb3Jtcy5yZWZsZWN0aW9uTWF0cml4KTtcbiNlbmRpZlxuI2lmZGVmIFJFRkxFQ1RJT05NQVBfUExBTkFSXG5yZXR1cm4gY29tcHV0ZVBsYW5hckNvb3Jkcyh3b3JsZFBvcyx3b3JsZE5vcm1hbCxzY2VuZS52RXllUG9zaXRpb24ueHl6LHVuaWZvcm1zLnJlZmxlY3Rpb25NYXRyaXgpO1xuI2VuZGlmXG4jaWZkZWYgUkVGTEVDVElPTk1BUF9DVUJJQ1xuI2lmZGVmIFVTRV9MT0NBTF9SRUZMRUNUSU9OTUFQX0NVQklDXG5yZXR1cm4gY29tcHV0ZUN1YmljTG9jYWxDb29yZHMod29ybGRQb3Msd29ybGROb3JtYWwsc2NlbmUudkV5ZVBvc2l0aW9uLnh5eix1bmlmb3Jtcy5yZWZsZWN0aW9uTWF0cml4LHVuaWZvcm1zLnZSZWZsZWN0aW9uU2l6ZSx1bmlmb3Jtcy52UmVmbGVjdGlvblBvc2l0aW9uKTtcbiNlbHNlXG5yZXR1cm4gY29tcHV0ZUN1YmljQ29vcmRzKHdvcmxkUG9zLHdvcmxkTm9ybWFsLHNjZW5lLnZFeWVQb3NpdGlvbi54eXosdW5pZm9ybXMucmVmbGVjdGlvbk1hdHJpeCk7XG4jZW5kaWZcbiNlbmRpZlxuI2lmZGVmIFJFRkxFQ1RJT05NQVBfUFJPSkVDVElPTlxucmV0dXJuIGNvbXB1dGVQcm9qZWN0aW9uQ29vcmRzKHdvcmxkUG9zLHNjZW5lLnZpZXcsdW5pZm9ybXMucmVmbGVjdGlvbk1hdHJpeCk7XG4jZW5kaWZcbiNpZm5kZWYgUkVGTEVDVElPTk1BUF9DVUJJQ1xuI2lmZGVmIFJFRkxFQ1RJT05NQVBfU0tZQk9YXG5yZXR1cm4gY29tcHV0ZVNreUJveENvb3JkcyhmcmFnbWVudElucHV0cy52UG9zaXRpb25VVlcsdW5pZm9ybXMucmVmbGVjdGlvbk1hdHJpeCk7XG4jZW5kaWZcbiNlbmRpZlxuI2lmZGVmIFJFRkxFQ1RJT05NQVBfRVhQTElDSVRcbnJldHVybiB2ZWMzZigwLDAsMCk7XG4jZW5kaWZcbn1cbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCByZWZsZWN0aW9uRnVuY3Rpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmxlY3Rpb25GdW5jdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcInNhbXBsZXJGcmFnbWVudERlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIF9ERUZJTkVOQU1FX1xuI2lmIF9ERUZJTkVOQU1FX0RJUkVDVFVWPT0xXG4jZGVmaW5lIHZfVkFSWUlOR05BTUVfVVYgdk1haW5VVjFcbiNlbGlmIF9ERUZJTkVOQU1FX0RJUkVDVFVWPT0yXG4jZGVmaW5lIHZfVkFSWUlOR05BTUVfVVYgdk1haW5VVjJcbiNlbGlmIF9ERUZJTkVOQU1FX0RJUkVDVFVWPT0zXG4jZGVmaW5lIHZfVkFSWUlOR05BTUVfVVYgdk1haW5VVjNcbiNlbGlmIF9ERUZJTkVOQU1FX0RJUkVDVFVWPT00XG4jZGVmaW5lIHZfVkFSWUlOR05BTUVfVVYgdk1haW5VVjRcbiNlbGlmIF9ERUZJTkVOQU1FX0RJUkVDVFVWPT01XG4jZGVmaW5lIHZfVkFSWUlOR05BTUVfVVYgdk1haW5VVjVcbiNlbGlmIF9ERUZJTkVOQU1FX0RJUkVDVFVWPT02XG4jZGVmaW5lIHZfVkFSWUlOR05BTUVfVVYgdk1haW5VVjZcbiNlbHNlXG52YXJ5aW5nIHZfVkFSWUlOR05BTUVfVVY6IHZlYzJmO1xuI2VuZGlmXG52YXIgX1NBTVBMRVJOQU1FX1NhbXBsZXJTYW1wbGVyOiBzYW1wbGVyO3ZhciBfU0FNUExFUk5BTUVfU2FtcGxlcjogdGV4dHVyZV8yZDxmMzI+O1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHNhbXBsZXJGcmFnbWVudERlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGVyRnJhZ21lbnREZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcInNjZW5lVWJvRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGBzdHJ1Y3QgU2NlbmUge3ZpZXdQcm9qZWN0aW9uIDogbWF0NHg0PGYzMj4sXG4jaWZkZWYgTVVMVElWSUVXXG52aWV3UHJvamVjdGlvblIgOiBtYXQ0eDQ8ZjMyPixcbiNlbmRpZiBcbnZpZXcgOiBtYXQ0eDQ8ZjMyPixcbnByb2plY3Rpb24gOiBtYXQ0eDQ8ZjMyPixcbnZFeWVQb3NpdGlvbiA6IHZlYzQ8ZjMyPix9O3Zhcjx1bmlmb3JtPiBzY2VuZSA6IFNjZW5lO1xuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBzY2VuZVVib0RlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2VuZVVib0RlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwic2hhZG93c0ZyYWdtZW50RnVuY3Rpb25zXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIFNIQURPV1NcbiNpZm5kZWYgU0hBRE9XRkxPQVRcbmZuIHVucGFjayhjb2xvcjogdmVjNGYpLT5mMzJcbntjb25zdCBiaXRfc2hpZnQ6IHZlYzRmPSB2ZWM0ZigxLjAvKDI1NS4wKjI1NS4wKjI1NS4wKSwxLjAvKDI1NS4wKjI1NS4wKSwxLjAvMjU1LjAsMS4wKTtyZXR1cm4gZG90KGNvbG9yLGJpdF9zaGlmdCk7fVxuI2VuZGlmXG5mbiBjb21wdXRlRmFsbE9mZih2YWx1ZTogZjMyLGNsaXBTcGFjZTogdmVjMmYsZnJ1c3R1bUVkZ2VGYWxsb2ZmOiBmMzIpLT5mMzJcbnt2YXIgbWFzazogZjMyPXNtb290aHN0ZXAoMS4wLWZydXN0dW1FZGdlRmFsbG9mZiwxLjAwMDAwMDEyLGNsYW1wKGRvdChjbGlwU3BhY2UsY2xpcFNwYWNlKSwwLiwxLikpO3JldHVybiBtaXgodmFsdWUsMS4wLG1hc2spO31cbmZuIGNvbXB1dGVTaGFkb3dDdWJlKHdvcmxkUG9zOiB2ZWMzZixsaWdodFBvc2l0aW9uOiB2ZWMzZixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlX2N1YmU8ZjMyPixzaGFkb3dTYW1wbGVyOiBzYW1wbGVyLGRhcmtuZXNzOiBmMzIsZGVwdGhWYWx1ZXM6IHZlYzJmKS0+ZjMyXG57dmFyIGRpcmVjdGlvblRvTGlnaHQ6IHZlYzNmPXdvcmxkUG9zLWxpZ2h0UG9zaXRpb247dmFyIGRlcHRoOiBmMzI9bGVuZ3RoKGRpcmVjdGlvblRvTGlnaHQpO2RlcHRoPShkZXB0aCtkZXB0aFZhbHVlcy54KS8oZGVwdGhWYWx1ZXMueSk7ZGVwdGg9Y2xhbXAoZGVwdGgsMC4sMS4wKTtkaXJlY3Rpb25Ub0xpZ2h0PW5vcm1hbGl6ZShkaXJlY3Rpb25Ub0xpZ2h0KTtkaXJlY3Rpb25Ub0xpZ2h0Lnk9LWRpcmVjdGlvblRvTGlnaHQueTtcbiNpZm5kZWYgU0hBRE9XRkxPQVRcbnZhciBzaGFkb3c6IGYzMj11bnBhY2sodGV4dHVyZVNhbXBsZShzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsZGlyZWN0aW9uVG9MaWdodCkpO1xuI2Vsc2VcbnZhciBzaGFkb3c6IGYzMj10ZXh0dXJlU2FtcGxlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0KS54O1xuI2VuZGlmXG5yZXR1cm4gc2VsZWN0KGRhcmtuZXNzLDEuMCxkZXB0aD5zaGFkb3cpO31cbmZuIGNvbXB1dGVTaGFkb3dXaXRoUG9pc3NvblNhbXBsaW5nQ3ViZSh3b3JsZFBvczogdmVjM2YsbGlnaHRQb3NpdGlvbjogdmVjM2Ysc2hhZG93VGV4dHVyZTogdGV4dHVyZV9jdWJlPGYzMj4sc2hhZG93U2FtcGxlcjogc2FtcGxlcixtYXBTaXplOiBmMzIsZGFya25lc3M6IGYzMixkZXB0aFZhbHVlczogdmVjMmYpLT5mMzJcbnt2YXIgZGlyZWN0aW9uVG9MaWdodDogdmVjM2Y9d29ybGRQb3MtbGlnaHRQb3NpdGlvbjt2YXIgZGVwdGg6IGYzMj1sZW5ndGgoZGlyZWN0aW9uVG9MaWdodCk7ZGVwdGg9KGRlcHRoK2RlcHRoVmFsdWVzLngpLyhkZXB0aFZhbHVlcy55KTtkZXB0aD1jbGFtcChkZXB0aCwwLiwxLjApO2RpcmVjdGlvblRvTGlnaHQ9bm9ybWFsaXplKGRpcmVjdGlvblRvTGlnaHQpO2RpcmVjdGlvblRvTGlnaHQueT0tZGlyZWN0aW9uVG9MaWdodC55O3ZhciB2aXNpYmlsaXR5OiBmMzI9MS47dmFyIHBvaXNzb25EaXNrOiBhcnJheTx2ZWMzZiw0Pjtwb2lzc29uRGlza1swXT0gdmVjM2YoLTEuMCwxLjAsLTEuMCk7cG9pc3NvbkRpc2tbMV09IHZlYzNmKDEuMCwtMS4wLC0xLjApO3BvaXNzb25EaXNrWzJdPSB2ZWMzZigtMS4wLC0xLjAsLTEuMCk7cG9pc3NvbkRpc2tbM109IHZlYzNmKDEuMCwtMS4wLDEuMCk7XG4jaWZuZGVmIFNIQURPV0ZMT0FUXG5pZiAodW5wYWNrKHRleHR1cmVTYW1wbGUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQrcG9pc3NvbkRpc2tbMF0qbWFwU2l6ZSkpPGRlcHRoKSB7dmlzaWJpbGl0eS09MC4yNTt9O2lmICh1bnBhY2sodGV4dHVyZVNhbXBsZShzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsZGlyZWN0aW9uVG9MaWdodCtwb2lzc29uRGlza1sxXSptYXBTaXplKSk8ZGVwdGgpIHt2aXNpYmlsaXR5LT0wLjI1O307aWYgKHVucGFjayh0ZXh0dXJlU2FtcGxlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0K3BvaXNzb25EaXNrWzJdKm1hcFNpemUpKTxkZXB0aCkge3Zpc2liaWxpdHktPTAuMjU7fTtpZiAodW5wYWNrKHRleHR1cmVTYW1wbGUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQrcG9pc3NvbkRpc2tbM10qbWFwU2l6ZSkpPGRlcHRoKSB7dmlzaWJpbGl0eS09MC4yNTt9O1xuI2Vsc2VcbmlmICh0ZXh0dXJlU2FtcGxlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0K3BvaXNzb25EaXNrWzBdKm1hcFNpemUpLng8ZGVwdGgpIHt2aXNpYmlsaXR5LT0wLjI1O307aWYgKHRleHR1cmVTYW1wbGUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQrcG9pc3NvbkRpc2tbMV0qbWFwU2l6ZSkueDxkZXB0aCkge3Zpc2liaWxpdHktPTAuMjU7fTtpZiAodGV4dHVyZVNhbXBsZShzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsZGlyZWN0aW9uVG9MaWdodCtwb2lzc29uRGlza1syXSptYXBTaXplKS54PGRlcHRoKSB7dmlzaWJpbGl0eS09MC4yNTt9O2lmICh0ZXh0dXJlU2FtcGxlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0K3BvaXNzb25EaXNrWzNdKm1hcFNpemUpLng8ZGVwdGgpIHt2aXNpYmlsaXR5LT0wLjI1O307XG4jZW5kaWZcbnJldHVybiBtaW4oMS4wLHZpc2liaWxpdHkrZGFya25lc3MpO31cbmZuIGNvbXB1dGVTaGFkb3dXaXRoRVNNQ3ViZSh3b3JsZFBvczogdmVjM2YsbGlnaHRQb3NpdGlvbjogdmVjM2Ysc2hhZG93VGV4dHVyZTogdGV4dHVyZV9jdWJlPGYzMj4sc2hhZG93U2FtcGxlcjogc2FtcGxlcixkYXJrbmVzczogZjMyLGRlcHRoU2NhbGU6IGYzMixkZXB0aFZhbHVlczogdmVjMmYpLT5mMzJcbnt2YXIgZGlyZWN0aW9uVG9MaWdodDogdmVjM2Y9d29ybGRQb3MtbGlnaHRQb3NpdGlvbjt2YXIgZGVwdGg6IGYzMj1sZW5ndGgoZGlyZWN0aW9uVG9MaWdodCk7ZGVwdGg9KGRlcHRoK2RlcHRoVmFsdWVzLngpLyhkZXB0aFZhbHVlcy55KTt2YXIgc2hhZG93UGl4ZWxEZXB0aDogZjMyPWNsYW1wKGRlcHRoLDAuLDEuMCk7ZGlyZWN0aW9uVG9MaWdodD1ub3JtYWxpemUoZGlyZWN0aW9uVG9MaWdodCk7ZGlyZWN0aW9uVG9MaWdodC55PS1kaXJlY3Rpb25Ub0xpZ2h0Lnk7XG4jaWZuZGVmIFNIQURPV0ZMT0FUXG52YXIgc2hhZG93TWFwU2FtcGxlOiBmMzI9dW5wYWNrKHRleHR1cmVTYW1wbGUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQpKTtcbiNlbHNlXG52YXIgc2hhZG93TWFwU2FtcGxlOiBmMzI9dGV4dHVyZVNhbXBsZShzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsZGlyZWN0aW9uVG9MaWdodCkueDtcbiNlbmRpZlxudmFyIGVzbTogZjMyPTEuMC1jbGFtcChleHAobWluKDg3LixkZXB0aFNjYWxlKnNoYWRvd1BpeGVsRGVwdGgpKSpzaGFkb3dNYXBTYW1wbGUsMC4sMS4tZGFya25lc3MpO3JldHVybiBlc207fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhDbG9zZUVTTUN1YmUod29ybGRQb3M6IHZlYzNmLGxpZ2h0UG9zaXRpb246IHZlYzNmLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfY3ViZTxmMzI+LHNoYWRvd1NhbXBsZXI6IHNhbXBsZXIsZGFya25lc3M6IGYzMixkZXB0aFNjYWxlOiBmMzIsZGVwdGhWYWx1ZXM6IHZlYzJmKS0+ZjMyXG57dmFyIGRpcmVjdGlvblRvTGlnaHQ6IHZlYzNmPXdvcmxkUG9zLWxpZ2h0UG9zaXRpb247dmFyIGRlcHRoOiBmMzI9bGVuZ3RoKGRpcmVjdGlvblRvTGlnaHQpO2RlcHRoPShkZXB0aCtkZXB0aFZhbHVlcy54KS8oZGVwdGhWYWx1ZXMueSk7dmFyIHNoYWRvd1BpeGVsRGVwdGg6IGYzMj1jbGFtcChkZXB0aCwwLiwxLjApO2RpcmVjdGlvblRvTGlnaHQ9bm9ybWFsaXplKGRpcmVjdGlvblRvTGlnaHQpO2RpcmVjdGlvblRvTGlnaHQueT0tZGlyZWN0aW9uVG9MaWdodC55O1xuI2lmbmRlZiBTSEFET1dGTE9BVFxudmFyIHNoYWRvd01hcFNhbXBsZTogZjMyPXVucGFjayh0ZXh0dXJlU2FtcGxlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcixkaXJlY3Rpb25Ub0xpZ2h0KSk7XG4jZWxzZVxudmFyIHNoYWRvd01hcFNhbXBsZTogZjMyPXRleHR1cmVTYW1wbGUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLGRpcmVjdGlvblRvTGlnaHQpLng7XG4jZW5kaWZcbnZhciBlc206IGYzMj1jbGFtcChleHAobWluKDg3LiwtZGVwdGhTY2FsZSooc2hhZG93UGl4ZWxEZXB0aC1zaGFkb3dNYXBTYW1wbGUpKSksZGFya25lc3MsMS4pO3JldHVybiBlc207fVxuZm4gY29tcHV0ZVNoYWRvd0NTTShsYXllcjogaTMyLHZQb3NpdGlvbkZyb21MaWdodDogdmVjNGYsZGVwdGhNZXRyaWM6IGYzMixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlXzJkX2FycmF5PGYzMj4sc2hhZG93U2FtcGxlcjogc2FtcGxlcixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyKS0+ZjMyXG57dmFyIGNsaXBTcGFjZTogdmVjM2Y9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2YXIgdXY6IHZlYzJmPTAuNSpjbGlwU3BhY2UueHkrIHZlYzJmKDAuNSk7dmFyIHNoYWRvd1BpeGVsRGVwdGg6IGYzMj1jbGFtcChkZXB0aE1ldHJpYywwLiwxLjApO1xuI2lmbmRlZiBTSEFET1dGTE9BVFxudmFyIHNoYWRvdzogZjMyPXVucGFjayh0ZXh0dXJlU2FtcGxlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcix1dixsYXllcikpO1xuI2Vsc2VcbnZhciBzaGFkb3c6IGYzMj10ZXh0dXJlU2FtcGxlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcix1dixsYXllcikueDtcbiNlbmRpZlxucmV0dXJuIHNlbGVjdCgxLixjb21wdXRlRmFsbE9mZihkYXJrbmVzcyxjbGlwU3BhY2UueHksZnJ1c3R1bUVkZ2VGYWxsb2ZmKSxzaGFkb3dQaXhlbERlcHRoPnNoYWRvdyApO31cbmZuIGNvbXB1dGVTaGFkb3codlBvc2l0aW9uRnJvbUxpZ2h0OiB2ZWM0ZixkZXB0aE1ldHJpYzogZjMyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPixzaGFkb3dTYW1wbGVyOiBzYW1wbGVyLGRhcmtuZXNzOiBmMzIsZnJ1c3R1bUVkZ2VGYWxsb2ZmOiBmMzIpLT5mMzJcbnt2YXIgY2xpcFNwYWNlOiB2ZWMzZj12UG9zaXRpb25Gcm9tTGlnaHQueHl6L3ZQb3NpdGlvbkZyb21MaWdodC53O3ZhciB1djogdmVjMmY9MC41KmNsaXBTcGFjZS54eSsgdmVjMmYoMC41KTtpZiAodXYueDwwLiB8fCB1di54PjEuMCB8fCB1di55PDAuIHx8IHV2Lnk+MS4wKVxue3JldHVybiAxLjA7fVxuZWxzZVxue3ZhciBzaGFkb3dQaXhlbERlcHRoOiBmMzI9Y2xhbXAoZGVwdGhNZXRyaWMsMC4sMS4wKTtcbiNpZm5kZWYgU0hBRE9XRkxPQVRcbnZhciBzaGFkb3c6IGYzMj11bnBhY2sodGV4dHVyZVNhbXBsZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcix1diwwLikpO1xuI2Vsc2VcbnZhciBzaGFkb3c6IGYzMj10ZXh0dXJlU2FtcGxlTGV2ZWwoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLHV2LDAuKS54O1xuI2VuZGlmXG5yZXR1cm4gc2VsZWN0KDEuLGNvbXB1dGVGYWxsT2ZmKGRhcmtuZXNzLGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpLHNoYWRvd1BpeGVsRGVwdGg+c2hhZG93ICk7fX1cbmZuIGNvbXB1dGVTaGFkb3dXaXRoUG9pc3NvblNhbXBsaW5nKHZQb3NpdGlvbkZyb21MaWdodDogdmVjNGYsZGVwdGhNZXRyaWM6IGYzMixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj4sc2hhZG93U2FtcGxlcjogc2FtcGxlcixtYXBTaXplOiBmMzIsZGFya25lc3M6IGYzMixmcnVzdHVtRWRnZUZhbGxvZmY6IGYzMiktPmYzMlxue3ZhciBjbGlwU3BhY2U6IHZlYzNmPXZQb3NpdGlvbkZyb21MaWdodC54eXovdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7dmFyIHV2OiB2ZWMyZj0wLjUqY2xpcFNwYWNlLnh5KyB2ZWMyZigwLjUpO2lmICh1di54PDAuIHx8IHV2Lng+MS4wIHx8IHV2Lnk8MC4gfHwgdXYueT4xLjApXG57cmV0dXJuIDEuMDt9XG5lbHNlXG57dmFyIHNoYWRvd1BpeGVsRGVwdGg6IGYzMj1jbGFtcChkZXB0aE1ldHJpYywwLiwxLjApO3ZhciB2aXNpYmlsaXR5OiBmMzI9MS47dmFyIHBvaXNzb25EaXNrOiBhcnJheTx2ZWMyZiw0Pjtwb2lzc29uRGlza1swXT0gdmVjMmYoLTAuOTQyMDE2MjQsLTAuMzk5MDYyMTYpO3BvaXNzb25EaXNrWzFdPSB2ZWMyZigwLjk0NTU4NjA5LC0wLjc2ODkwNzI1KTtwb2lzc29uRGlza1syXT0gdmVjMmYoLTAuMDk0MTg0MTAxLC0wLjkyOTM4ODcwKTtwb2lzc29uRGlza1szXT0gdmVjMmYoMC4zNDQ5NTkzOCwwLjI5Mzg3NzYwKTtcbiNpZm5kZWYgU0hBRE9XRkxPQVRcbmlmICh1bnBhY2sodGV4dHVyZVNhbXBsZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcix1ditwb2lzc29uRGlza1swXSptYXBTaXplLDAuKSk8c2hhZG93UGl4ZWxEZXB0aCkge3Zpc2liaWxpdHktPTAuMjU7fVxuaWYgKHVucGFjayh0ZXh0dXJlU2FtcGxlTGV2ZWwoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLHV2K3BvaXNzb25EaXNrWzFdKm1hcFNpemUsMC4pKTxzaGFkb3dQaXhlbERlcHRoKSB7dmlzaWJpbGl0eS09MC4yNTt9XG5pZiAodW5wYWNrKHRleHR1cmVTYW1wbGVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsdXYrcG9pc3NvbkRpc2tbMl0qbWFwU2l6ZSwwLikpPHNoYWRvd1BpeGVsRGVwdGgpIHt2aXNpYmlsaXR5LT0wLjI1O31cbmlmICh1bnBhY2sodGV4dHVyZVNhbXBsZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcix1ditwb2lzc29uRGlza1szXSptYXBTaXplLDAuKSk8c2hhZG93UGl4ZWxEZXB0aCkge3Zpc2liaWxpdHktPTAuMjU7fVxuI2Vsc2VcbmlmICh0ZXh0dXJlU2FtcGxlTGV2ZWwoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLHV2K3BvaXNzb25EaXNrWzBdKm1hcFNpemUsMC4pLng8c2hhZG93UGl4ZWxEZXB0aCkge3Zpc2liaWxpdHktPTAuMjU7fVxuaWYgKHRleHR1cmVTYW1wbGVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsdXYrcG9pc3NvbkRpc2tbMV0qbWFwU2l6ZSwwLikueDxzaGFkb3dQaXhlbERlcHRoKSB7dmlzaWJpbGl0eS09MC4yNTt9XG5pZiAodGV4dHVyZVNhbXBsZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcix1ditwb2lzc29uRGlza1syXSptYXBTaXplLDAuKS54PHNoYWRvd1BpeGVsRGVwdGgpIHt2aXNpYmlsaXR5LT0wLjI1O31cbmlmICh0ZXh0dXJlU2FtcGxlTGV2ZWwoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLHV2K3BvaXNzb25EaXNrWzNdKm1hcFNpemUsMC4pLng8c2hhZG93UGl4ZWxEZXB0aCkge3Zpc2liaWxpdHktPTAuMjU7fVxuI2VuZGlmXG5yZXR1cm4gY29tcHV0ZUZhbGxPZmYobWluKDEuMCx2aXNpYmlsaXR5K2RhcmtuZXNzKSxjbGlwU3BhY2UueHksZnJ1c3R1bUVkZ2VGYWxsb2ZmKTt9fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhFU00odlBvc2l0aW9uRnJvbUxpZ2h0OiB2ZWM0ZixkZXB0aE1ldHJpYzogZjMyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPixzaGFkb3dTYW1wbGVyOiBzYW1wbGVyLGRhcmtuZXNzOiBmMzIsZGVwdGhTY2FsZTogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyKS0+ZjMyXG57dmFyIGNsaXBTcGFjZTogdmVjM2Y9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2YXIgdXY6IHZlYzJmPTAuNSpjbGlwU3BhY2UueHkrIHZlYzJmKDAuNSk7aWYgKHV2Lng8MC4gfHwgdXYueD4xLjAgfHwgdXYueTwwLiB8fCB1di55PjEuMClcbntyZXR1cm4gMS4wO31cbmVsc2Vcbnt2YXIgc2hhZG93UGl4ZWxEZXB0aDogZjMyPWNsYW1wKGRlcHRoTWV0cmljLDAuLDEuMCk7XG4jaWZuZGVmIFNIQURPV0ZMT0FUXG52YXIgc2hhZG93TWFwU2FtcGxlOiBmMzI9dW5wYWNrKHRleHR1cmVTYW1wbGVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsdXYsMC4pKTtcbiNlbHNlXG52YXIgc2hhZG93TWFwU2FtcGxlOiBmMzI9dGV4dHVyZVNhbXBsZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcix1diwwLikueDtcbiNlbmRpZlxudmFyIGVzbTogZjMyPTEuMC1jbGFtcChleHAobWluKDg3LixkZXB0aFNjYWxlKnNoYWRvd1BpeGVsRGVwdGgpKSpzaGFkb3dNYXBTYW1wbGUsMC4sMS4tZGFya25lc3MpO3JldHVybiBjb21wdXRlRmFsbE9mZihlc20sY2xpcFNwYWNlLnh5LGZydXN0dW1FZGdlRmFsbG9mZik7fX1cbmZuIGNvbXB1dGVTaGFkb3dXaXRoQ2xvc2VFU00odlBvc2l0aW9uRnJvbUxpZ2h0OiB2ZWM0ZixkZXB0aE1ldHJpYzogZjMyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPixzaGFkb3dTYW1wbGVyOiBzYW1wbGVyLGRhcmtuZXNzOiBmMzIsZGVwdGhTY2FsZTogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyKS0+ZjMyXG57dmFyIGNsaXBTcGFjZTogdmVjM2Y9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2YXIgdXY6IHZlYzJmPTAuNSpjbGlwU3BhY2UueHkrIHZlYzJmKDAuNSk7aWYgKHV2Lng8MC4gfHwgdXYueD4xLjAgfHwgdXYueTwwLiB8fCB1di55PjEuMClcbntyZXR1cm4gMS4wO31cbmVsc2Vcbnt2YXIgc2hhZG93UGl4ZWxEZXB0aDogZjMyPWNsYW1wKGRlcHRoTWV0cmljLDAuLDEuMCk7IFxuI2lmbmRlZiBTSEFET1dGTE9BVFxudmFyIHNoYWRvd01hcFNhbXBsZTogZjMyPXVucGFjayh0ZXh0dXJlU2FtcGxlTGV2ZWwoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLHV2LDAuKSk7XG4jZWxzZVxudmFyIHNoYWRvd01hcFNhbXBsZTogZjMyPXRleHR1cmVTYW1wbGVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsdXYsMC4pLng7XG4jZW5kaWZcbnZhciBlc206IGYzMj1jbGFtcChleHAobWluKDg3LiwtZGVwdGhTY2FsZSooc2hhZG93UGl4ZWxEZXB0aC1zaGFkb3dNYXBTYW1wbGUpKSksZGFya25lc3MsMS4pO3JldHVybiBjb21wdXRlRmFsbE9mZihlc20sY2xpcFNwYWNlLnh5LGZydXN0dW1FZGdlRmFsbG9mZik7fX1cbmZuIGdldFpJbkNsaXAoY2xpcFNwYWNlOiB2ZWMzZix1dkRlcHRoOiB2ZWMzZiktPmYzMlxue1xuI2lmZGVmIElTX05EQ19IQUxGX1pSQU5HRVxucmV0dXJuIGNsaXBTcGFjZS56O1xuI2Vsc2VcbnJldHVybiB1dkRlcHRoLno7XG4jZW5kaWZcbn1cbmNvbnN0IEdSRUFURVNUX0xFU1NfVEhBTl9PTkU6IGYzMj0wLjk5OTk5OTk0O1xuI2RlZmluZSBESVNBQkxFX1VOSUZPUk1JVFlfQU5BTFlTSVNcbmZuIGNvbXB1dGVTaGFkb3dXaXRoQ1NNUENGMShsYXllcjogaTMyLHZQb3NpdGlvbkZyb21MaWdodDogdmVjNGYsZGVwdGhNZXRyaWM6IGYzMixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlX2RlcHRoXzJkX2FycmF5LHNoYWRvd1NhbXBsZXI6IHNhbXBsZXJfY29tcGFyaXNvbixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyKS0+ZjMyXG57dmFyIGNsaXBTcGFjZTogdmVjM2Y9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2YXIgdXZEZXB0aDogdmVjM2Y9IHZlYzNmKDAuNSpjbGlwU3BhY2UueHl6KyB2ZWMzZigwLjUpKTt1dkRlcHRoLno9Y2xhbXAoZ2V0WkluQ2xpcChjbGlwU3BhY2UsdXZEZXB0aCksMC4sR1JFQVRFU1RfTEVTU19USEFOX09ORSk7dmFyIHNoYWRvdzogZjMyPXRleHR1cmVTYW1wbGVDb21wYXJlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlcix1dkRlcHRoLnh5LGxheWVyLHV2RGVwdGgueik7c2hhZG93PW1peChkYXJrbmVzcywxLixzaGFkb3cpO3JldHVybiBjb21wdXRlRmFsbE9mZihzaGFkb3csY2xpcFNwYWNlLnh5LGZydXN0dW1FZGdlRmFsbG9mZik7fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhDU01QQ0YzKGxheWVyOiBpMzIsdlBvc2l0aW9uRnJvbUxpZ2h0OiB2ZWM0ZixkZXB0aE1ldHJpYzogZjMyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfZGVwdGhfMmRfYXJyYXksc2hhZG93U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uLHNoYWRvd01hcFNpemVBbmRJbnZlcnNlOiB2ZWMyZixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyKS0+ZjMyXG57dmFyIGNsaXBTcGFjZTogdmVjM2Y9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2YXIgdXZEZXB0aDogdmVjM2Y9IHZlYzNmKDAuNSpjbGlwU3BhY2UueHl6KyB2ZWMzZigwLjUpKTt1dkRlcHRoLno9Y2xhbXAoZ2V0WkluQ2xpcChjbGlwU3BhY2UsdXZEZXB0aCksMC4sR1JFQVRFU1RfTEVTU19USEFOX09ORSk7dmFyIHV2OiB2ZWMyZj11dkRlcHRoLnh5KnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLng7IFxudXYrPTAuNTsgXG52YXIgc3Q6IHZlYzJmPWZyYWN0KHV2KTsgXG52YXIgYmFzZV91djogdmVjMmY9Zmxvb3IodXYpLTAuNTsgXG5iYXNlX3V2Kj1zaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55OyBcbnZhciB1dncwOiB2ZWMyZj0zLi0yLipzdDt2YXIgdXZ3MTogdmVjMmY9MS4rMi4qc3Q7dmFyIHU6IHZlYzJmPSB2ZWMyZigoMi4tc3QueCkvdXZ3MC54LTEuLHN0LngvdXZ3MS54KzEuKSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55O3ZhciB2OiB2ZWMyZj0gdmVjMmYoKDIuLXN0LnkpL3V2dzAueS0xLixzdC55L3V2dzEueSsxLikqc2hhZG93TWFwU2l6ZUFuZEludmVyc2UueTt2YXIgc2hhZG93OiBmMzI9MC47c2hhZG93Kz11dncwLngqdXZ3MC55KnRleHR1cmVTYW1wbGVDb21wYXJlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVswXSx2WzBdKSxsYXllcix1dkRlcHRoLnopO3NoYWRvdys9dXZ3MS54KnV2dzAueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZShzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsIGJhc2VfdXYueHkrIHZlYzJmKHVbMV0sdlswXSksbGF5ZXIsdXZEZXB0aC56KTtzaGFkb3crPXV2dzAueCp1dncxLnkqdGV4dHVyZVNhbXBsZUNvbXBhcmUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLCBiYXNlX3V2Lnh5KyB2ZWMyZih1WzBdLHZbMV0pLGxheWVyLHV2RGVwdGgueik7c2hhZG93Kz11dncxLngqdXZ3MS55KnRleHR1cmVTYW1wbGVDb21wYXJlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsxXSx2WzFdKSxsYXllcix1dkRlcHRoLnopO3NoYWRvdz1zaGFkb3cvMTYuO3NoYWRvdz1taXgoZGFya25lc3MsMS4sc2hhZG93KTtyZXR1cm4gY29tcHV0ZUZhbGxPZmYoc2hhZG93LGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpO31cbmZuIGNvbXB1dGVTaGFkb3dXaXRoQ1NNUENGNShsYXllcjogaTMyLHZQb3NpdGlvbkZyb21MaWdodDogdmVjNGYsZGVwdGhNZXRyaWM6IGYzMixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlX2RlcHRoXzJkX2FycmF5LHNoYWRvd1NhbXBsZXI6IHNhbXBsZXJfY29tcGFyaXNvbixzaGFkb3dNYXBTaXplQW5kSW52ZXJzZTogdmVjMmYsZGFya25lc3M6IGYzMixmcnVzdHVtRWRnZUZhbGxvZmY6IGYzMiktPmYzMlxue3ZhciBjbGlwU3BhY2U6IHZlYzNmPXZQb3NpdGlvbkZyb21MaWdodC54eXovdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7dmFyIHV2RGVwdGg6IHZlYzNmPSB2ZWMzZigwLjUqY2xpcFNwYWNlLnh5eisgdmVjM2YoMC41KSk7dXZEZXB0aC56PWNsYW1wKGdldFpJbkNsaXAoY2xpcFNwYWNlLHV2RGVwdGgpLDAuLEdSRUFURVNUX0xFU1NfVEhBTl9PTkUpO3ZhciB1djogdmVjMmY9dXZEZXB0aC54eSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS54OyBcbnV2Kz0wLjU7IFxudmFyIHN0OiB2ZWMyZj1mcmFjdCh1dik7IFxudmFyIGJhc2VfdXY6IHZlYzJmPWZsb29yKHV2KS0wLjU7IFxuYmFzZV91dio9c2hhZG93TWFwU2l6ZUFuZEludmVyc2UueTsgXG52YXIgdXZ3MDogdmVjMmY9NC4tMy4qc3Q7dmFyIHV2dzE6IHZlYzJmPSB2ZWMyZig3Lik7dmFyIHV2dzI6IHZlYzJmPTEuKzMuKnN0O3ZhciB1OiB2ZWMzZj0gdmVjM2YoKDMuLTIuKnN0LngpL3V2dzAueC0yLiwoMy4rc3QueCkvdXZ3MS54LHN0LngvdXZ3Mi54KzIuKSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55O3ZhciB2OiB2ZWMzZj0gdmVjM2YoKDMuLTIuKnN0LnkpL3V2dzAueS0yLiwoMy4rc3QueSkvdXZ3MS55LHN0LnkvdXZ3Mi55KzIuKSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55O3ZhciBzaGFkb3c6IGYzMj0wLjtzaGFkb3crPXV2dzAueCp1dncwLnkqdGV4dHVyZVNhbXBsZUNvbXBhcmUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLCBiYXNlX3V2Lnh5KyB2ZWMyZih1WzBdLHZbMF0pLGxheWVyLHV2RGVwdGgueik7c2hhZG93Kz11dncxLngqdXZ3MC55KnRleHR1cmVTYW1wbGVDb21wYXJlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsxXSx2WzBdKSxsYXllcix1dkRlcHRoLnopO3NoYWRvdys9dXZ3Mi54KnV2dzAueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZShzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsIGJhc2VfdXYueHkrIHZlYzJmKHVbMl0sdlswXSksbGF5ZXIsdXZEZXB0aC56KTtzaGFkb3crPXV2dzAueCp1dncxLnkqdGV4dHVyZVNhbXBsZUNvbXBhcmUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLCBiYXNlX3V2Lnh5KyB2ZWMyZih1WzBdLHZbMV0pLGxheWVyLHV2RGVwdGgueik7c2hhZG93Kz11dncxLngqdXZ3MS55KnRleHR1cmVTYW1wbGVDb21wYXJlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsxXSx2WzFdKSxsYXllcix1dkRlcHRoLnopO3NoYWRvdys9dXZ3Mi54KnV2dzEueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZShzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsIGJhc2VfdXYueHkrIHZlYzJmKHVbMl0sdlsxXSksbGF5ZXIsdXZEZXB0aC56KTtzaGFkb3crPXV2dzAueCp1dncyLnkqdGV4dHVyZVNhbXBsZUNvbXBhcmUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLCBiYXNlX3V2Lnh5KyB2ZWMyZih1WzBdLHZbMl0pLGxheWVyLHV2RGVwdGgueik7c2hhZG93Kz11dncxLngqdXZ3Mi55KnRleHR1cmVTYW1wbGVDb21wYXJlKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsxXSx2WzJdKSxsYXllcix1dkRlcHRoLnopO3NoYWRvdys9dXZ3Mi54KnV2dzIueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZShzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsIGJhc2VfdXYueHkrIHZlYzJmKHVbMl0sdlsyXSksbGF5ZXIsdXZEZXB0aC56KTtzaGFkb3c9c2hhZG93LzE0NC47c2hhZG93PW1peChkYXJrbmVzcywxLixzaGFkb3cpO3JldHVybiBjb21wdXRlRmFsbE9mZihzaGFkb3csY2xpcFNwYWNlLnh5LGZydXN0dW1FZGdlRmFsbG9mZik7fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhQQ0YxKHZQb3NpdGlvbkZyb21MaWdodDogdmVjNGYsZGVwdGhNZXRyaWM6IGYzMixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlX2RlcHRoXzJkLHNoYWRvd1NhbXBsZXI6IHNhbXBsZXJfY29tcGFyaXNvbixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyKS0+ZjMyXG57aWYgKGRlcHRoTWV0cmljPjEuMCB8fCBkZXB0aE1ldHJpYzwwLjApIHtyZXR1cm4gMS4wO31cbmVsc2Vcbnt2YXIgY2xpcFNwYWNlOiB2ZWMzZj12UG9zaXRpb25Gcm9tTGlnaHQueHl6L3ZQb3NpdGlvbkZyb21MaWdodC53O3ZhciB1dkRlcHRoOiB2ZWMzZj0gdmVjM2YoMC41KmNsaXBTcGFjZS54eXorIHZlYzNmKDAuNSkpO3V2RGVwdGguej1nZXRaSW5DbGlwKGNsaXBTcGFjZSx1dkRlcHRoKTt2YXIgc2hhZG93OiBmMzI9dGV4dHVyZVNhbXBsZUNvbXBhcmVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsdXZEZXB0aC54eSx1dkRlcHRoLnopO3NoYWRvdz1taXgoZGFya25lc3MsMS4sc2hhZG93KTtyZXR1cm4gY29tcHV0ZUZhbGxPZmYoc2hhZG93LGNsaXBTcGFjZS54eSxmcnVzdHVtRWRnZUZhbGxvZmYpO319XG5mbiBjb21wdXRlU2hhZG93V2l0aFBDRjModlBvc2l0aW9uRnJvbUxpZ2h0OiB2ZWM0ZixkZXB0aE1ldHJpYzogZjMyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfZGVwdGhfMmQsc2hhZG93U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uLHNoYWRvd01hcFNpemVBbmRJbnZlcnNlOiB2ZWMyZixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyKS0+ZjMyXG57aWYgKGRlcHRoTWV0cmljPjEuMCB8fCBkZXB0aE1ldHJpYzwwLjApIHtyZXR1cm4gMS4wO31cbmVsc2Vcbnt2YXIgY2xpcFNwYWNlOiB2ZWMzZj12UG9zaXRpb25Gcm9tTGlnaHQueHl6L3ZQb3NpdGlvbkZyb21MaWdodC53O3ZhciB1dkRlcHRoOiB2ZWMzZj0gdmVjM2YoMC41KmNsaXBTcGFjZS54eXorIHZlYzNmKDAuNSkpO3V2RGVwdGguej1nZXRaSW5DbGlwKGNsaXBTcGFjZSx1dkRlcHRoKTt2YXIgdXY6IHZlYzJmPXV2RGVwdGgueHkqc2hhZG93TWFwU2l6ZUFuZEludmVyc2UueDsgXG51dis9MC41OyBcbnZhciBzdDogdmVjMmY9ZnJhY3QodXYpOyBcbnZhciBiYXNlX3V2OiB2ZWMyZj1mbG9vcih1diktMC41OyBcbmJhc2VfdXYqPXNoYWRvd01hcFNpemVBbmRJbnZlcnNlLnk7IFxudmFyIHV2dzA6IHZlYzJmPTMuLTIuKnN0O3ZhciB1dncxOiB2ZWMyZj0xLisyLipzdDt2YXIgdTogdmVjMmY9IHZlYzJmKCgyLi1zdC54KS91dncwLngtMS4sc3QueC91dncxLngrMS4pKnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLnk7dmFyIHY6IHZlYzJmPSB2ZWMyZigoMi4tc3QueSkvdXZ3MC55LTEuLHN0LnkvdXZ3MS55KzEuKSpzaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55O3ZhciBzaGFkb3c6IGYzMj0wLjtzaGFkb3crPXV2dzAueCp1dncwLnkqdGV4dHVyZVNhbXBsZUNvbXBhcmVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsIGJhc2VfdXYueHkrIHZlYzJmKHVbMF0sdlswXSksdXZEZXB0aC56KTtzaGFkb3crPXV2dzEueCp1dncwLnkqdGV4dHVyZVNhbXBsZUNvbXBhcmVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsIGJhc2VfdXYueHkrIHZlYzJmKHVbMV0sdlswXSksdXZEZXB0aC56KTtzaGFkb3crPXV2dzAueCp1dncxLnkqdGV4dHVyZVNhbXBsZUNvbXBhcmVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsIGJhc2VfdXYueHkrIHZlYzJmKHVbMF0sdlsxXSksdXZEZXB0aC56KTtzaGFkb3crPXV2dzEueCp1dncxLnkqdGV4dHVyZVNhbXBsZUNvbXBhcmVMZXZlbChzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsIGJhc2VfdXYueHkrIHZlYzJmKHVbMV0sdlsxXSksdXZEZXB0aC56KTtzaGFkb3c9c2hhZG93LzE2LjtzaGFkb3c9bWl4KGRhcmtuZXNzLDEuLHNoYWRvdyk7cmV0dXJuIGNvbXB1dGVGYWxsT2ZmKHNoYWRvdyxjbGlwU3BhY2UueHksZnJ1c3R1bUVkZ2VGYWxsb2ZmKTt9fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhQQ0Y1KHZQb3NpdGlvbkZyb21MaWdodDogdmVjNGYsZGVwdGhNZXRyaWM6IGYzMixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlX2RlcHRoXzJkLHNoYWRvd1NhbXBsZXI6IHNhbXBsZXJfY29tcGFyaXNvbixzaGFkb3dNYXBTaXplQW5kSW52ZXJzZTogdmVjMmYsZGFya25lc3M6IGYzMixmcnVzdHVtRWRnZUZhbGxvZmY6IGYzMiktPmYzMlxue2lmIChkZXB0aE1ldHJpYz4xLjAgfHwgZGVwdGhNZXRyaWM8MC4wKSB7cmV0dXJuIDEuMDt9XG5lbHNlXG57dmFyIGNsaXBTcGFjZTogdmVjM2Y9dlBvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92UG9zaXRpb25Gcm9tTGlnaHQudzt2YXIgdXZEZXB0aDogdmVjM2Y9IHZlYzNmKDAuNSpjbGlwU3BhY2UueHl6KyB2ZWMzZigwLjUpKTt1dkRlcHRoLno9Z2V0WkluQ2xpcChjbGlwU3BhY2UsdXZEZXB0aCk7dmFyIHV2OiB2ZWMyZj11dkRlcHRoLnh5KnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLng7IFxudXYrPTAuNTsgXG52YXIgc3Q6IHZlYzJmPWZyYWN0KHV2KTsgXG52YXIgYmFzZV91djogdmVjMmY9Zmxvb3IodXYpLTAuNTsgXG5iYXNlX3V2Kj1zaGFkb3dNYXBTaXplQW5kSW52ZXJzZS55OyBcbnZhciB1dncwOiB2ZWMyZj00Li0zLipzdDt2YXIgdXZ3MTogdmVjMmY9IHZlYzJmKDcuKTt2YXIgdXZ3MjogdmVjMmY9MS4rMy4qc3Q7dmFyIHU6IHZlYzNmPSB2ZWMzZigoMy4tMi4qc3QueCkvdXZ3MC54LTIuLCgzLitzdC54KS91dncxLngsc3QueC91dncyLngrMi4pKnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLnk7dmFyIHY6IHZlYzNmPSB2ZWMzZigoMy4tMi4qc3QueSkvdXZ3MC55LTIuLCgzLitzdC55KS91dncxLnksc3QueS91dncyLnkrMi4pKnNoYWRvd01hcFNpemVBbmRJbnZlcnNlLnk7dmFyIHNoYWRvdzogZjMyPTAuO3NoYWRvdys9dXZ3MC54KnV2dzAueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVswXSx2WzBdKSx1dkRlcHRoLnopO3NoYWRvdys9dXZ3MS54KnV2dzAueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsxXSx2WzBdKSx1dkRlcHRoLnopO3NoYWRvdys9dXZ3Mi54KnV2dzAueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsyXSx2WzBdKSx1dkRlcHRoLnopO3NoYWRvdys9dXZ3MC54KnV2dzEueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVswXSx2WzFdKSx1dkRlcHRoLnopO3NoYWRvdys9dXZ3MS54KnV2dzEueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsxXSx2WzFdKSx1dkRlcHRoLnopO3NoYWRvdys9dXZ3Mi54KnV2dzEueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsyXSx2WzFdKSx1dkRlcHRoLnopO3NoYWRvdys9dXZ3MC54KnV2dzIueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVswXSx2WzJdKSx1dkRlcHRoLnopO3NoYWRvdys9dXZ3MS54KnV2dzIueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsxXSx2WzJdKSx1dkRlcHRoLnopO3NoYWRvdys9dXZ3Mi54KnV2dzIueSp0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd1RleHR1cmUsc2hhZG93U2FtcGxlciwgYmFzZV91di54eSsgdmVjMmYodVsyXSx2WzJdKSx1dkRlcHRoLnopO3NoYWRvdz1zaGFkb3cvMTQ0LjtzaGFkb3c9bWl4KGRhcmtuZXNzLDEuLHNoYWRvdyk7cmV0dXJuIGNvbXB1dGVGYWxsT2ZmKHNoYWRvdyxjbGlwU3BhY2UueHksZnJ1c3R1bUVkZ2VGYWxsb2ZmKTt9fVxuY29uc3QgUG9pc3NvblNhbXBsZXJzMzI6IGFycmF5PHZlYzNmLDY0Pj1hcnJheTx2ZWMzZiw2ND4gKFxudmVjM2YoMC4wNjQwNzAxMywwLjA1NDA5OTI3LDAuKSxcbnZlYzNmKDAuNzM2NjU3NywwLjU3ODkzOTQsMC4pLFxudmVjM2YoLTAuNjI3MDU0MiwtMC41MzIwMjc4LDAuKSxcbnZlYzNmKC0wLjQwOTYxMDcsMC44NDExMDk1LDAuKSxcbnZlYzNmKDAuNjg0OTU2NCwtMC40OTkwODE4LDAuKSxcbnZlYzNmKC0wLjg3NDE4MSwtMC4wNDU3OTczNSwwLiksXG52ZWMzZigwLjk5ODk5OTgsMC4wMDA5ODgwMDY2LDAuKSxcbnZlYzNmKC0wLjAwNDkyMDU3OCwtMC45MTUxNjQ5LDAuKSxcbnZlYzNmKDAuMTgwNTc2MywwLjk3NDc0ODMsMC4pLFxudmVjM2YoLTAuMjEzODQ1MSwwLjI2MzU4MTgsMC4pLFxudmVjM2YoMC4xMDk4NDUsMC4zODg0Nzg1LDAuKSxcbnZlYzNmKDAuMDY4NzY3NTUsLTAuMzU4MTA3NCwwLiksXG52ZWMzZigwLjM3NDA3MywtMC43NjYxMjY2LDAuKSxcbnZlYzNmKDAuMzA3OTEzMiwtMC4xMjE2NzYzLDAuKSxcbnZlYzNmKC0wLjM3OTQzMzUsLTAuODI3MTU4MywwLiksXG52ZWMzZigtMC4yMDM4NzgsLTAuMDc3MTUwMzQsMC4pLFxudmVjM2YoMC41OTEyNjk3LDAuMTQ2OTc5OSwwLiksXG52ZWMzZigtMC44ODA2OSwwLjMwMzE3ODQsMC4pLFxudmVjM2YoMC41MDQwMTA4LDAuODI4MzcyMiwwLiksXG52ZWMzZigtMC41ODQ0MTI0LDAuNTQ5NDg3NywwLiksXG52ZWMzZigwLjYwMTc3OTksLTAuMTcyNjY1NCwwLiksXG52ZWMzZigtMC41NTU0OTgxLDAuMTU1OTk5NywwLiksXG52ZWMzZigtMC4zMDE2MzY5LC0wLjM5MDA5MjgsMC4pLFxudmVjM2YoLTAuNTU1MDYzMiwtMC4xNzIzNzYyLDAuKSxcbnZlYzNmKDAuOTI1MDI5LDAuMjk5NTA0MSwwLiksXG52ZWMzZigtMC4yNDczMTM3LDAuNTUzODUwNSwwLiksXG52ZWMzZigwLjkxODMwMzcsLTAuMjg2MjM5MiwwLiksXG52ZWMzZigwLjI0Njk0MjEsMC42NzE4NzEyLDAuKSxcbnZlYzNmKDAuMzkxNjM5NywtMC40MzI4MjA5LDAuKSxcbnZlYzNmKC0wLjAzNTc2OTI3LC0wLjYyMjAwMzIsMC4pLFxudmVjM2YoLTAuMDQ2NjEyNTUsMC43OTk1MjAxLDAuKSxcbnZlYzNmKDAuNDQwMjkyNCwwLjM2NDAzMTIsMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pLFxudmVjM2YoMC4pXG4pO2NvbnN0IFBvaXNzb25TYW1wbGVyczY0OiBhcnJheTx2ZWMzZiw2ND49YXJyYXk8dmVjM2YsNjQ+IChcbnZlYzNmKC0wLjYxMzM5MiwwLjYxNzQ4MSwwLiksXG52ZWMzZigwLjE3MDAxOSwtMC4wNDAyNTQsMC4pLFxudmVjM2YoLTAuMjk5NDE3LDAuNzkxOTI1LDAuKSxcbnZlYzNmKDAuNjQ1NjgwLDAuNDkzMjEwLDAuKSxcbnZlYzNmKC0wLjY1MTc4NCwwLjcxNzg4NywwLiksXG52ZWMzZigwLjQyMTAwMywwLjAyNzA3MCwwLiksXG52ZWMzZigtMC44MTcxOTQsLTAuMjcxMDk2LDAuKSxcbnZlYzNmKC0wLjcwNTM3NCwtMC42NjgyMDMsMC4pLFxudmVjM2YoMC45NzcwNTAsLTAuMTA4NjE1LDAuKSxcbnZlYzNmKDAuMDYzMzI2LDAuMTQyMzY5LDAuKSxcbnZlYzNmKDAuMjAzNTI4LDAuMjE0MzMxLDAuKSxcbnZlYzNmKC0wLjY2NzUzMSwwLjMyNjA5MCwwLiksXG52ZWMzZigtMC4wOTg0MjIsLTAuMjk1NzU1LDAuKSxcbnZlYzNmKC0wLjg4NTkyMiwwLjIxNTM2OSwwLiksXG52ZWMzZigwLjU2NjYzNywwLjYwNTIxMywwLiksXG52ZWMzZigwLjAzOTc2NiwtMC4zOTYxMDAsMC4pLFxudmVjM2YoMC43NTE5NDYsMC40NTMzNTIsMC4pLFxudmVjM2YoMC4wNzg3MDcsLTAuNzE1MzIzLDAuKSxcbnZlYzNmKC0wLjA3NTgzOCwtMC41MjkzNDQsMC4pLFxudmVjM2YoMC43MjQ0NzksLTAuNTgwNzk4LDAuKSxcbnZlYzNmKDAuMjIyOTk5LC0wLjIxNTEyNSwwLiksXG52ZWMzZigtMC40Njc1NzQsLTAuNDA1NDM4LDAuKSxcbnZlYzNmKC0wLjI0ODI2OCwtMC44MTQ3NTMsMC4pLFxudmVjM2YoMC4zNTQ0MTEsLTAuODg3NTcwLDAuKSxcbnZlYzNmKDAuMTc1ODE3LDAuMzgyMzY2LDAuKSxcbnZlYzNmKDAuNDg3NDcyLC0wLjA2MzA4MiwwLiksXG52ZWMzZigtMC4wODQwNzgsMC44OTgzMTIsMC4pLFxudmVjM2YoMC40ODg4NzYsLTAuNzgzNDQxLDAuKSxcbnZlYzNmKDAuNDcwMDE2LDAuMjE3OTMzLDAuKSxcbnZlYzNmKC0wLjY5Njg5MCwtMC41NDk3OTEsMC4pLFxudmVjM2YoLTAuMTQ5NjkzLDAuNjA1NzYyLDAuKSxcbnZlYzNmKDAuMDM0MjExLDAuOTc5OTgwLDAuKSxcbnZlYzNmKDAuNTAzMDk4LC0wLjMwODg3OCwwLiksXG52ZWMzZigtMC4wMTYyMDUsLTAuODcyOTIxLDAuKSxcbnZlYzNmKDAuMzg1Nzg0LC0wLjM5MzkwMiwwLiksXG52ZWMzZigtMC4xNDY4ODYsLTAuODU5MjQ5LDAuKSxcbnZlYzNmKDAuNjQzMzYxLDAuMTY0MDk4LDAuKSxcbnZlYzNmKDAuNjM0Mzg4LC0wLjA0OTQ3MSwwLiksXG52ZWMzZigtMC42ODg4OTQsMC4wMDc4NDMsMC4pLFxudmVjM2YoMC40NjQwMzQsLTAuMTg4ODE4LDAuKSxcbnZlYzNmKC0wLjQ0MDg0MCwwLjEzNzQ4NiwwLiksXG52ZWMzZigwLjM2NDQ4MywwLjUxMTcwNCwwLiksXG52ZWMzZigwLjAzNDAyOCwwLjMyNTk2OCwwLiksXG52ZWMzZigwLjA5OTA5NCwtMC4zMDgwMjMsMC4pLFxudmVjM2YoMC42OTM5NjAsLTAuMzY2MjUzLDAuKSxcbnZlYzNmKDAuNjc4ODg0LC0wLjIwNDY4OCwwLiksXG52ZWMzZigwLjAwMTgwMSwwLjc4MDMyOCwwLiksXG52ZWMzZigwLjE0NTE3NywtMC44OTg5ODQsMC4pLFxudmVjM2YoMC4wNjI2NTUsLTAuNjExODY2LDAuKSxcbnZlYzNmKDAuMzE1MjI2LC0wLjYwNDI5NywwLiksXG52ZWMzZigtMC43ODAxNDUsMC40ODYyNTEsMC4pLFxudmVjM2YoLTAuMzcxODY4LDAuODgyMTM4LDAuKSxcbnZlYzNmKDAuMjAwNDc2LDAuNDk0NDMwLDAuKSxcbnZlYzNmKC0wLjQ5NDU1MiwtMC43MTEwNTEsMC4pLFxudmVjM2YoMC42MTI0NzYsMC43MDUyNTIsMC4pLFxudmVjM2YoLTAuNTc4ODQ1LC0wLjc2ODc5MiwwLiksXG52ZWMzZigtMC43NzI0NTQsLTAuMDkwOTc2LDAuKSxcbnZlYzNmKDAuNTA0NDQwLDAuMzcyMjk1LDAuKSxcbnZlYzNmKDAuMTU1NzM2LDAuMDY1MTU3LDAuKSxcbnZlYzNmKDAuMzkxNTIyLDAuODQ5NjA1LDAuKSxcbnZlYzNmKC0wLjYyMDEwNiwtMC4zMjgxMDQsMC4pLFxudmVjM2YoMC43ODkyMzksLTAuNDE5OTY1LDAuKSxcbnZlYzNmKC0wLjU0NTM5NiwwLjUzODEzMywwLiksXG52ZWMzZigtMC4xNzg1NjQsLTAuNTk2MDU3LDAuKVxuKTtmbiBjb21wdXRlU2hhZG93V2l0aENTTVBDU1MobGF5ZXI6IGkzMix2UG9zaXRpb25Gcm9tTGlnaHQ6IHZlYzRmLGRlcHRoTWV0cmljOiBmMzIsZGVwdGhUZXh0dXJlOiB0ZXh0dXJlXzJkX2FycmF5PGYzMj4sZGVwdGhTYW1wbGVyOiBzYW1wbGVyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfZGVwdGhfMmRfYXJyYXksc2hhZG93U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uLHNoYWRvd01hcFNpemVJbnZlcnNlOiBmMzIsbGlnaHRTaXplVVY6IGYzMixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyLHNlYXJjaFRhcENvdW50OiBpMzIscGNmVGFwQ291bnQ6IGkzMixwb2lzc29uU2FtcGxlcnM6IGFycmF5PHZlYzNmLDY0PixsaWdodFNpemVVVkNvcnJlY3Rpb246IHZlYzJmLGRlcHRoQ29ycmVjdGlvbjogZjMyLHBlbnVtYnJhRGFya25lc3M6IGYzMiktPmYzMlxue3ZhciBjbGlwU3BhY2U6IHZlYzNmPXZQb3NpdGlvbkZyb21MaWdodC54eXovdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7dmFyIHV2RGVwdGg6IHZlYzNmPSB2ZWMzZigwLjUqY2xpcFNwYWNlLnh5eisgdmVjM2YoMC41KSk7dXZEZXB0aC56PWNsYW1wKGdldFpJbkNsaXAoY2xpcFNwYWNlLHV2RGVwdGgpLDAuLEdSRUFURVNUX0xFU1NfVEhBTl9PTkUpO3ZhciB1dkRlcHRoTGF5ZXI6IHZlYzRmPSB2ZWM0Zih1dkRlcHRoLngsdXZEZXB0aC55LGYzMihsYXllciksdXZEZXB0aC56KTt2YXIgYmxvY2tlckRlcHRoOiBmMzI9MC4wO3ZhciBzdW1CbG9ja2VyRGVwdGg6IGYzMj0wLjA7dmFyIG51bUJsb2NrZXI6IGYzMj0wLjA7Zm9yICh2YXIgaTogaTMyPTA7IGk8c2VhcmNoVGFwQ291bnQ7IGkgKyspIHtibG9ja2VyRGVwdGg9dGV4dHVyZVNhbXBsZShkZXB0aFRleHR1cmUsZGVwdGhTYW1wbGVyLCB1dkRlcHRoLnh5KyhsaWdodFNpemVVVipsaWdodFNpemVVVkNvcnJlY3Rpb24qc2hhZG93TWFwU2l6ZUludmVyc2UqUG9pc3NvblNhbXBsZXJzMzJbaV0ueHkpLGxheWVyKS5yO251bUJsb2NrZXIrPXNlbGVjdCgwLiwxLixibG9ja2VyRGVwdGg8ZGVwdGhNZXRyaWMpO3N1bUJsb2NrZXJEZXB0aCs9c2VsZWN0KDAuLGJsb2NrZXJEZXB0aCxibG9ja2VyRGVwdGg8ZGVwdGhNZXRyaWMpO31cbnZhciBhdmdCbG9ja2VyRGVwdGg6IGYzMj1zdW1CbG9ja2VyRGVwdGgvbnVtQmxvY2tlcjt2YXIgQUFPZmZzZXQ6IGYzMj1zaGFkb3dNYXBTaXplSW52ZXJzZSoxMC47dmFyIHBlbnVtYnJhUmF0aW86IGYzMj0oKGRlcHRoTWV0cmljLWF2Z0Jsb2NrZXJEZXB0aCkqZGVwdGhDb3JyZWN0aW9uK0FBT2Zmc2V0KTt2YXIgZmlsdGVyUmFkaXVzOiB2ZWM0Zj0gdmVjNGYocGVudW1icmFSYXRpbypsaWdodFNpemVVVipsaWdodFNpemVVVkNvcnJlY3Rpb24qc2hhZG93TWFwU2l6ZUludmVyc2UsMC4sMC4pO3ZhciByYW5kb206IGYzMj1nZXRSYW5kKHZQb3NpdGlvbkZyb21MaWdodC54eSk7dmFyIHJvdGF0aW9uQW5nbGU6IGYzMj1yYW5kb20qMy4xNDE1OTI2O3ZhciByb3RhdGlvblZlY3RvcjogdmVjMmY9IHZlYzJmKGNvcyhyb3RhdGlvbkFuZ2xlKSxzaW4ocm90YXRpb25BbmdsZSkpO3ZhciBzaGFkb3c6IGYzMj0wLjtmb3IgKHZhciBpOiBpMzI9MDsgaTxwY2ZUYXBDb3VudDsgaSsrKSB7dmFyIG9mZnNldDogdmVjNGY9IHZlYzRmKHBvaXNzb25TYW1wbGVyc1tpXSwwLik7b2Zmc2V0PSB2ZWM0ZihvZmZzZXQueCpyb3RhdGlvblZlY3Rvci54LW9mZnNldC55KnJvdGF0aW9uVmVjdG9yLnksb2Zmc2V0Lnkqcm90YXRpb25WZWN0b3IueCtvZmZzZXQueCpyb3RhdGlvblZlY3Rvci55LDAuLDAuKTtsZXQgY29vcmRzPXV2RGVwdGhMYXllcitvZmZzZXQqZmlsdGVyUmFkaXVzO3NoYWRvdys9dGV4dHVyZVNhbXBsZUNvbXBhcmUoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLGNvb3Jkcy54eSxpMzIoY29vcmRzLnopLGNvb3Jkcy53KTt9XG5zaGFkb3cvPSBmMzIocGNmVGFwQ291bnQpO3NoYWRvdz1taXgoc2hhZG93LDEuLG1pbigoZGVwdGhNZXRyaWMtYXZnQmxvY2tlckRlcHRoKSpkZXB0aENvcnJlY3Rpb24qcGVudW1icmFEYXJrbmVzcywxLikpO3NoYWRvdz1taXgoZGFya25lc3MsMS4sc2hhZG93KTtyZXR1cm4gc2VsZWN0KGNvbXB1dGVGYWxsT2ZmKHNoYWRvdyxjbGlwU3BhY2UueHksZnJ1c3R1bUVkZ2VGYWxsb2ZmKSwxLjAsbnVtQmxvY2tlcjwxLjApO31cbmZuIGNvbXB1dGVTaGFkb3dXaXRoUENTUyh2UG9zaXRpb25Gcm9tTGlnaHQ6IHZlYzRmLGRlcHRoTWV0cmljOiBmMzIsZGVwdGhUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj4sZGVwdGhTYW1wbGVyOiBzYW1wbGVyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfZGVwdGhfMmQsc2hhZG93U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uLHNoYWRvd01hcFNpemVJbnZlcnNlOiBmMzIsbGlnaHRTaXplVVY6IGYzMixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyLHNlYXJjaFRhcENvdW50OiBpMzIscGNmVGFwQ291bnQ6IGkzMixwb2lzc29uU2FtcGxlcnM6IGFycmF5PHZlYzNmLDY0PiktPmYzMlxue3ZhciBjbGlwU3BhY2U6IHZlYzNmPXZQb3NpdGlvbkZyb21MaWdodC54eXovdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7dmFyIHV2RGVwdGg6IHZlYzNmPSB2ZWMzZigwLjUqY2xpcFNwYWNlLnh5eisgdmVjM2YoMC41KSk7dXZEZXB0aC56PWdldFpJbkNsaXAoY2xpcFNwYWNlLHV2RGVwdGgpO3ZhciBibG9ja2VyRGVwdGg6IGYzMj0wLjA7dmFyIHN1bUJsb2NrZXJEZXB0aDogZjMyPTAuMDt2YXIgbnVtQmxvY2tlcjogZjMyPTAuMDt2YXIgZXhpdENvbmRpdGlvbjogYm9vbD1kZXB0aE1ldHJpYz4xLjAgfHwgZGVwdGhNZXRyaWM8MC4wO2ZvciAodmFyIGk6IGkzMj0wOyBpPHNlYXJjaFRhcENvdW50OyBpICsrKSB7aWYgKGV4aXRDb25kaXRpb24pIHticmVhazt9XG5ibG9ja2VyRGVwdGg9dGV4dHVyZVNhbXBsZUxldmVsKGRlcHRoVGV4dHVyZSxkZXB0aFNhbXBsZXIsdXZEZXB0aC54eSsobGlnaHRTaXplVVYqc2hhZG93TWFwU2l6ZUludmVyc2UqUG9pc3NvblNhbXBsZXJzMzJbaV0ueHkpLDApLnI7bnVtQmxvY2tlcis9c2VsZWN0KDAuLDEuLGJsb2NrZXJEZXB0aDxkZXB0aE1ldHJpYyk7c3VtQmxvY2tlckRlcHRoKz1zZWxlY3QoMC4sYmxvY2tlckRlcHRoLGJsb2NrZXJEZXB0aDxkZXB0aE1ldHJpYyk7fVxuZXhpdENvbmRpdGlvbj1leGl0Q29uZGl0aW9uIHx8IG51bUJsb2NrZXI8MS4wO3ZhciBhdmdCbG9ja2VyRGVwdGg6IGYzMj1zdW1CbG9ja2VyRGVwdGgvbnVtQmxvY2tlcjt2YXIgQUFPZmZzZXQ6IGYzMj1zaGFkb3dNYXBTaXplSW52ZXJzZSoxMC47dmFyIHBlbnVtYnJhUmF0aW86IGYzMj0oKGRlcHRoTWV0cmljLWF2Z0Jsb2NrZXJEZXB0aCkrQUFPZmZzZXQpO3ZhciBmaWx0ZXJSYWRpdXM6IGYzMj1wZW51bWJyYVJhdGlvKmxpZ2h0U2l6ZVVWKnNoYWRvd01hcFNpemVJbnZlcnNlO3ZhciByYW5kb206IGYzMj1nZXRSYW5kKHZQb3NpdGlvbkZyb21MaWdodC54eSk7dmFyIHJvdGF0aW9uQW5nbGU6IGYzMj1yYW5kb20qMy4xNDE1OTI2O3ZhciByb3RhdGlvblZlY3RvcjogdmVjMmY9IHZlYzJmKGNvcyhyb3RhdGlvbkFuZ2xlKSxzaW4ocm90YXRpb25BbmdsZSkpO3ZhciBzaGFkb3c6IGYzMj0wLjtmb3IgKHZhciBpOiBpMzI9MDsgaTxwY2ZUYXBDb3VudDsgaSsrKSB7aWYgKGV4aXRDb25kaXRpb24pIHticmVhazt9XG52YXIgb2Zmc2V0OiB2ZWMzZj1wb2lzc29uU2FtcGxlcnNbaV07b2Zmc2V0PSB2ZWMzZihvZmZzZXQueCpyb3RhdGlvblZlY3Rvci54LW9mZnNldC55KnJvdGF0aW9uVmVjdG9yLnksb2Zmc2V0Lnkqcm90YXRpb25WZWN0b3IueCtvZmZzZXQueCpyb3RhdGlvblZlY3Rvci55LDAuKTtsZXQgY29vcmRzPXV2RGVwdGgrb2Zmc2V0KmZpbHRlclJhZGl1cztzaGFkb3crPXRleHR1cmVTYW1wbGVDb21wYXJlTGV2ZWwoc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLGNvb3Jkcy54eSxjb29yZHMueik7fVxuc2hhZG93Lz0gZjMyKHBjZlRhcENvdW50KTtzaGFkb3c9bWl4KHNoYWRvdywxLixkZXB0aE1ldHJpYy1hdmdCbG9ja2VyRGVwdGgpO3NoYWRvdz1taXgoZGFya25lc3MsMS4sc2hhZG93KTtyZXR1cm4gc2VsZWN0KGNvbXB1dGVGYWxsT2ZmKHNoYWRvdyxjbGlwU3BhY2UueHksZnJ1c3R1bUVkZ2VGYWxsb2ZmKSwxLjAsZXhpdENvbmRpdGlvbik7fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhQQ1NTMTYodlBvc2l0aW9uRnJvbUxpZ2h0OiB2ZWM0ZixkZXB0aE1ldHJpYzogZjMyLGRlcHRoVGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+LGRlcHRoU2FtcGxlcjogc2FtcGxlcixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlX2RlcHRoXzJkLHNoYWRvd1NhbXBsZXI6IHNhbXBsZXJfY29tcGFyaXNvbixzaGFkb3dNYXBTaXplSW52ZXJzZTogZjMyLGxpZ2h0U2l6ZVVWOiBmMzIsZGFya25lc3M6IGYzMixmcnVzdHVtRWRnZUZhbGxvZmY6IGYzMiktPmYzMlxue3JldHVybiBjb21wdXRlU2hhZG93V2l0aFBDU1ModlBvc2l0aW9uRnJvbUxpZ2h0LGRlcHRoTWV0cmljLGRlcHRoVGV4dHVyZSxkZXB0aFNhbXBsZXIsc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLHNoYWRvd01hcFNpemVJbnZlcnNlLGxpZ2h0U2l6ZVVWLGRhcmtuZXNzLGZydXN0dW1FZGdlRmFsbG9mZiwxNiwxNixQb2lzc29uU2FtcGxlcnMzMik7fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhQQ1NTMzIodlBvc2l0aW9uRnJvbUxpZ2h0OiB2ZWM0ZixkZXB0aE1ldHJpYzogZjMyLGRlcHRoVGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+LGRlcHRoU2FtcGxlcjogc2FtcGxlcixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlX2RlcHRoXzJkLHNoYWRvd1NhbXBsZXI6IHNhbXBsZXJfY29tcGFyaXNvbixzaGFkb3dNYXBTaXplSW52ZXJzZTogZjMyLGxpZ2h0U2l6ZVVWOiBmMzIsZGFya25lc3M6IGYzMixmcnVzdHVtRWRnZUZhbGxvZmY6IGYzMiktPmYzMlxue3JldHVybiBjb21wdXRlU2hhZG93V2l0aFBDU1ModlBvc2l0aW9uRnJvbUxpZ2h0LGRlcHRoTWV0cmljLGRlcHRoVGV4dHVyZSxkZXB0aFNhbXBsZXIsc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLHNoYWRvd01hcFNpemVJbnZlcnNlLGxpZ2h0U2l6ZVVWLGRhcmtuZXNzLGZydXN0dW1FZGdlRmFsbG9mZiwxNiwzMixQb2lzc29uU2FtcGxlcnMzMik7fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhQQ1NTNjQodlBvc2l0aW9uRnJvbUxpZ2h0OiB2ZWM0ZixkZXB0aE1ldHJpYzogZjMyLGRlcHRoVGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+LGRlcHRoU2FtcGxlcjogc2FtcGxlcixzaGFkb3dUZXh0dXJlOiB0ZXh0dXJlX2RlcHRoXzJkLHNoYWRvd1NhbXBsZXI6IHNhbXBsZXJfY29tcGFyaXNvbixzaGFkb3dNYXBTaXplSW52ZXJzZTogZjMyLGxpZ2h0U2l6ZVVWOiBmMzIsZGFya25lc3M6IGYzMixmcnVzdHVtRWRnZUZhbGxvZmY6IGYzMiktPmYzMlxue3JldHVybiBjb21wdXRlU2hhZG93V2l0aFBDU1ModlBvc2l0aW9uRnJvbUxpZ2h0LGRlcHRoTWV0cmljLGRlcHRoVGV4dHVyZSxkZXB0aFNhbXBsZXIsc2hhZG93VGV4dHVyZSxzaGFkb3dTYW1wbGVyLHNoYWRvd01hcFNpemVJbnZlcnNlLGxpZ2h0U2l6ZVVWLGRhcmtuZXNzLGZydXN0dW1FZGdlRmFsbG9mZiwzMiw2NCxQb2lzc29uU2FtcGxlcnM2NCk7fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhDU01QQ1NTMTYobGF5ZXI6IGkzMix2UG9zaXRpb25Gcm9tTGlnaHQ6IHZlYzRmLGRlcHRoTWV0cmljOiBmMzIsZGVwdGhUZXh0dXJlOiB0ZXh0dXJlXzJkX2FycmF5PGYzMj4sZGVwdGhTYW1wbGVyOiBzYW1wbGVyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfZGVwdGhfMmRfYXJyYXksc2hhZG93U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uLHNoYWRvd01hcFNpemVJbnZlcnNlOiBmMzIsbGlnaHRTaXplVVY6IGYzMixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyLGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbjogdmVjMmYsZGVwdGhDb3JyZWN0aW9uOiBmMzIscGVudW1icmFEYXJrbmVzczogZjMyKS0+ZjMyXG57cmV0dXJuIGNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUyhsYXllcix2UG9zaXRpb25Gcm9tTGlnaHQsZGVwdGhNZXRyaWMsZGVwdGhUZXh0dXJlLGRlcHRoU2FtcGxlcixzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsc2hhZG93TWFwU2l6ZUludmVyc2UsbGlnaHRTaXplVVYsZGFya25lc3MsZnJ1c3R1bUVkZ2VGYWxsb2ZmLDE2LDE2LFBvaXNzb25TYW1wbGVyczMyLGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbixkZXB0aENvcnJlY3Rpb24scGVudW1icmFEYXJrbmVzcyk7fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhDU01QQ1NTMzIobGF5ZXI6IGkzMix2UG9zaXRpb25Gcm9tTGlnaHQ6IHZlYzRmLGRlcHRoTWV0cmljOiBmMzIsZGVwdGhUZXh0dXJlOiB0ZXh0dXJlXzJkX2FycmF5PGYzMj4sZGVwdGhTYW1wbGVyOiBzYW1wbGVyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfZGVwdGhfMmRfYXJyYXksc2hhZG93U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uLHNoYWRvd01hcFNpemVJbnZlcnNlOiBmMzIsbGlnaHRTaXplVVY6IGYzMixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyLGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbjogdmVjMmYsZGVwdGhDb3JyZWN0aW9uOiBmMzIscGVudW1icmFEYXJrbmVzczogZjMyKS0+ZjMyXG57cmV0dXJuIGNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUyhsYXllcix2UG9zaXRpb25Gcm9tTGlnaHQsZGVwdGhNZXRyaWMsZGVwdGhUZXh0dXJlLGRlcHRoU2FtcGxlcixzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsc2hhZG93TWFwU2l6ZUludmVyc2UsbGlnaHRTaXplVVYsZGFya25lc3MsZnJ1c3R1bUVkZ2VGYWxsb2ZmLDE2LDMyLFBvaXNzb25TYW1wbGVyczMyLGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbixkZXB0aENvcnJlY3Rpb24scGVudW1icmFEYXJrbmVzcyk7fVxuZm4gY29tcHV0ZVNoYWRvd1dpdGhDU01QQ1NTNjQobGF5ZXI6IGkzMix2UG9zaXRpb25Gcm9tTGlnaHQ6IHZlYzRmLGRlcHRoTWV0cmljOiBmMzIsZGVwdGhUZXh0dXJlOiB0ZXh0dXJlXzJkX2FycmF5PGYzMj4sZGVwdGhTYW1wbGVyOiBzYW1wbGVyLHNoYWRvd1RleHR1cmU6IHRleHR1cmVfZGVwdGhfMmRfYXJyYXksc2hhZG93U2FtcGxlcjogc2FtcGxlcl9jb21wYXJpc29uLHNoYWRvd01hcFNpemVJbnZlcnNlOiBmMzIsbGlnaHRTaXplVVY6IGYzMixkYXJrbmVzczogZjMyLGZydXN0dW1FZGdlRmFsbG9mZjogZjMyLGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbjogdmVjMmYsZGVwdGhDb3JyZWN0aW9uOiBmMzIscGVudW1icmFEYXJrbmVzczogZjMyKS0+ZjMyXG57cmV0dXJuIGNvbXB1dGVTaGFkb3dXaXRoQ1NNUENTUyhsYXllcix2UG9zaXRpb25Gcm9tTGlnaHQsZGVwdGhNZXRyaWMsZGVwdGhUZXh0dXJlLGRlcHRoU2FtcGxlcixzaGFkb3dUZXh0dXJlLHNoYWRvd1NhbXBsZXIsc2hhZG93TWFwU2l6ZUludmVyc2UsbGlnaHRTaXplVVYsZGFya25lc3MsZnJ1c3R1bUVkZ2VGYWxsb2ZmLDMyLDY0LFBvaXNzb25TYW1wbGVyczY0LGxpZ2h0U2l6ZVVWQ29ycmVjdGlvbixkZXB0aENvcnJlY3Rpb24scGVudW1icmFEYXJrbmVzcyk7fVxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHNoYWRvd3NGcmFnbWVudEZ1bmN0aW9uc1dHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93c0ZyYWdtZW50RnVuY3Rpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==