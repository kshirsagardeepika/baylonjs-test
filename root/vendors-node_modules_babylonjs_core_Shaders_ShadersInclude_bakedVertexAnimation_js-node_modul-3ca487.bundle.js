"use strict";
(self["webpackChunksample1"] = self["webpackChunksample1"] || []).push([["vendors-node_modules_babylonjs_core_Shaders_ShadersInclude_bakedVertexAnimation_js-node_modul-3ca487"],{

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bakedVertexAnimation: () => (/* binding */ bakedVertexAnimation)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bakedVertexAnimation";
const shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bakedVertexAnimation = { name, shader };
//# sourceMappingURL=bakedVertexAnimation.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bakedVertexAnimationDeclaration: () => (/* binding */ bakedVertexAnimationDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bakedVertexAnimationDeclaration";
const shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bakedVertexAnimationDeclaration = { name, shader };
//# sourceMappingURL=bakedVertexAnimationDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bonesDeclaration: () => (/* binding */ bonesDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bonesDeclaration";
const shader = `#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform highp sampler2D boneSampler;uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#endif
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bonesDeclaration = { name, shader };
//# sourceMappingURL=bonesDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bonesVertex: () => (/* binding */ bonesVertex)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bonesVertex";
const shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bonesVertex = { name, shader };
//# sourceMappingURL=bonesVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpVertex: () => (/* binding */ bumpVertex)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bumpVertex";
const shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bumpVertex = { name, shader };
//# sourceMappingURL=bumpVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpVertexDeclaration: () => (/* binding */ bumpVertexDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bumpVertexDeclaration";
const shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const bumpVertexDeclaration = { name, shader };
//# sourceMappingURL=bumpVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/decalVertexDeclaration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/decalVertexDeclaration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decalVertexDeclaration: () => (/* binding */ decalVertexDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "decalVertexDeclaration";
const shader = `#ifdef DECAL
uniform vec4 vDecalInfos;uniform mat4 decalMatrix;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const decalVertexDeclaration = { name, shader };
//# sourceMappingURL=decalVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   instancesDeclaration: () => (/* binding */ instancesDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "instancesDeclaration";
const shader = `#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const instancesDeclaration = { name, shader };
//# sourceMappingURL=instancesDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   instancesVertex: () => (/* binding */ instancesVertex)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "instancesVertex";
const shader = `#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const instancesVertex = { name, shader };
//# sourceMappingURL=instancesVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightVxFragmentDeclaration: () => (/* binding */ lightVxFragmentDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "lightVxFragmentDeclaration";
const shader = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const lightVxFragmentDeclaration = { name, shader };
//# sourceMappingURL=lightVxFragmentDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightVxUboDeclaration: () => (/* binding */ lightVxUboDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "lightVxUboDeclaration";
const shader = `#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const lightVxUboDeclaration = { name, shader };
//# sourceMappingURL=lightVxUboDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mainUVVaryingDeclaration: () => (/* binding */ mainUVVaryingDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "mainUVVaryingDeclaration";
const shader = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const mainUVVaryingDeclaration = { name, shader };
//# sourceMappingURL=mainUVVaryingDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   morphTargetsVertex: () => (/* binding */ morphTargetsVertex)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "morphTargetsVertex";
const shader = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
#if {X}==0
for (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];
#endif
}
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const morphTargetsVertex = { name, shader };
//# sourceMappingURL=morphTargetsVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   morphTargetsVertexDeclaration: () => (/* binding */ morphTargetsVertexDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "morphTargetsVertexDeclaration";
const shader = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#elif {X}==0
uniform int morphTargetCount;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const morphTargetsVertexDeclaration = { name, shader };
//# sourceMappingURL=morphTargetsVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   morphTargetsVertexGlobal: () => (/* binding */ morphTargetsVertexGlobal)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "morphTargetsVertexGlobal";
const shader = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const morphTargetsVertexGlobal = { name, shader };
//# sourceMappingURL=morphTargetsVertexGlobal.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   morphTargetsVertexGlobalDeclaration: () => (/* binding */ morphTargetsVertexGlobalDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "morphTargetsVertexGlobalDeclaration";
const shader = `#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const morphTargetsVertexGlobalDeclaration = { name, shader };
//# sourceMappingURL=morphTargetsVertexGlobalDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prePassVertex: () => (/* binding */ prePassVertex)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "prePassVertex";
const shader = `#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const prePassVertex = { name, shader };
//# sourceMappingURL=prePassVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prePassVertexDeclaration: () => (/* binding */ prePassVertexDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "prePassVertexDeclaration";
const shader = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const prePassVertexDeclaration = { name, shader };
//# sourceMappingURL=prePassVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   samplerVertexDeclaration: () => (/* binding */ samplerVertexDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "samplerVertexDeclaration";
const shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const samplerVertexDeclaration = { name, shader };
//# sourceMappingURL=samplerVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   samplerVertexImplementation: () => (/* binding */ samplerVertexImplementation)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "samplerVertexImplementation";
const shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}
#ifdef UV2
else if (v_INFONAME_==1.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const samplerVertexImplementation = { name, shader };
//# sourceMappingURL=samplerVertexImplementation.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shadowsVertex: () => (/* binding */ shadowsVertex)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "shadowsVertex";
const shader = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const shadowsVertex = { name, shader };
//# sourceMappingURL=shadowsVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uvAttributeDeclaration: () => (/* binding */ uvAttributeDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "uvAttributeDeclaration";
const shader = `#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const uvAttributeDeclaration = { name, shader };
//# sourceMappingURL=uvAttributeDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uvVariableDeclaration: () => (/* binding */ uvVariableDeclaration)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "uvVariableDeclaration";
const shader = `#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const uvVariableDeclaration = { name, shader };
//# sourceMappingURL=uvVariableDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   vertexColorMixing: () => (/* binding */ vertexColorMixing)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "vertexColorMixing";
const shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
/** @internal */
const vertexColorMixing = { name, shader };
//# sourceMappingURL=vertexColorMixing.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfU2hhZGVyc19TaGFkZXJzSW5jbHVkZV9iYWtlZFZlcnRleEFuaW1hdGlvbl9qcy1ub2RlX21vZHVsLTNjYTQ4Ny5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QixnQ0FBZ0MsMEJBQTBCLGdEQUFnRCx5REFBeUQsMkNBQTJDLDhDQUE4QywwQ0FBMEMsd0RBQXdELCtCQUErQiwyQ0FBMkMsa0JBQWtCO0FBQ3RmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLCtCQUErQjtBQUN0Qzs7Ozs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQzJEO0FBQzNEO0FBQ0E7QUFDQSx1Q0FBdUMscURBQXFELDBDQUEwQztBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsb0VBQW9FLG1EQUFtRCxxREFBcUQscURBQXFELHFEQUFxRCxxREFBcUQ7QUFDblc7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLDBDQUEwQztBQUNqRDs7Ozs7Ozs7Ozs7Ozs7O0FDakJBO0FBQzJEO0FBQzNEO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLDhCQUE4QixnREFBZ0QsZ0RBQWdELGdEQUFnRCxnREFBZ0Q7QUFDdlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9iYWtlZFZlcnRleEFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL2Jha2VkVmVydGV4QW5pbWF0aW9uRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9ib25lc0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvYm9uZXNWZXJ0ZXguanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9idW1wVmVydGV4LmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvYnVtcFZlcnRleERlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvZGVjYWxWZXJ0ZXhEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL2luc3RhbmNlc0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvaW5zdGFuY2VzVmVydGV4LmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvbGlnaHRWeEZyYWdtZW50RGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9saWdodFZ4VWJvRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9tYWluVVZWYXJ5aW5nRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9tb3JwaFRhcmdldHNWZXJ0ZXguanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS9tb3JwaFRhcmdldHNWZXJ0ZXhEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL21vcnBoVGFyZ2V0c1ZlcnRleEdsb2JhbC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL21vcnBoVGFyZ2V0c1ZlcnRleEdsb2JhbERlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvcHJlUGFzc1ZlcnRleC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL3ByZVBhc3NWZXJ0ZXhEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL3NhbXBsZXJWZXJ0ZXhEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL3NhbXBsZXJWZXJ0ZXhJbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL3NoYWRvd3NWZXJ0ZXguanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9TaGFkZXJzSW5jbHVkZS91dkF0dHJpYnV0ZURlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvdXZWYXJpYWJsZURlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvU2hhZGVyc0luY2x1ZGUvdmVydGV4Q29sb3JNaXhpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJiYWtlZFZlcnRleEFuaW1hdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBCQUtFRF9WRVJURVhfQU5JTUFUSU9OX1RFWFRVUkVcbntcbiNpZmRlZiBJTlNUQU5DRVNcbiNkZWZpbmUgQlZBU05BTUUgYmFrZWRWZXJ0ZXhBbmltYXRpb25TZXR0aW5nc0luc3RhbmNlZFxuI2Vsc2VcbiNkZWZpbmUgQlZBU05BTUUgYmFrZWRWZXJ0ZXhBbmltYXRpb25TZXR0aW5nc1xuI2VuZGlmXG5mbG9hdCBWQVRTdGFydEZyYW1lPUJWQVNOQU1FLng7ZmxvYXQgVkFURW5kRnJhbWU9QlZBU05BTUUueTtmbG9hdCBWQVRPZmZzZXRGcmFtZT1CVkFTTkFNRS56O2Zsb2F0IFZBVFNwZWVkPUJWQVNOQU1FLnc7ZmxvYXQgdG90YWxGcmFtZXM9VkFURW5kRnJhbWUtVkFUU3RhcnRGcmFtZSsxLjA7ZmxvYXQgdGltZT1iYWtlZFZlcnRleEFuaW1hdGlvblRpbWUqVkFUU3BlZWQvdG90YWxGcmFtZXM7ZmxvYXQgZnJhbWVDb3JyZWN0aW9uPXRpbWU8MS4wID8gMC4wIDogMS4wO2Zsb2F0IG51bU9mRnJhbWVzPXRvdGFsRnJhbWVzLWZyYW1lQ29ycmVjdGlvbjtmbG9hdCBWQVRGcmFtZU51bT1mcmFjdCh0aW1lKSpudW1PZkZyYW1lcztWQVRGcmFtZU51bT1tb2QoVkFURnJhbWVOdW0rVkFUT2Zmc2V0RnJhbWUsbnVtT2ZGcmFtZXMpO1ZBVEZyYW1lTnVtPWZsb29yKFZBVEZyYW1lTnVtKTtWQVRGcmFtZU51bSs9VkFUU3RhcnRGcmFtZStmcmFtZUNvcnJlY3Rpb247bWF0NCBWQVRJbmZsdWVuY2U7VkFUSW5mbHVlbmNlPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmUsbWF0cmljZXNJbmRpY2VzWzBdLFZBVEZyYW1lTnVtKSptYXRyaWNlc1dlaWdodHNbMF07XG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+MVxuVkFUSW5mbHVlbmNlKz1yZWFkTWF0cml4RnJvbVJhd1NhbXBsZXJWQVQoYmFrZWRWZXJ0ZXhBbmltYXRpb25UZXh0dXJlLG1hdHJpY2VzSW5kaWNlc1sxXSxWQVRGcmFtZU51bSkqbWF0cmljZXNXZWlnaHRzWzFdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+MlxuVkFUSW5mbHVlbmNlKz1yZWFkTWF0cml4RnJvbVJhd1NhbXBsZXJWQVQoYmFrZWRWZXJ0ZXhBbmltYXRpb25UZXh0dXJlLG1hdHJpY2VzSW5kaWNlc1syXSxWQVRGcmFtZU51bSkqbWF0cmljZXNXZWlnaHRzWzJdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+M1xuVkFUSW5mbHVlbmNlKz1yZWFkTWF0cml4RnJvbVJhd1NhbXBsZXJWQVQoYmFrZWRWZXJ0ZXhBbmltYXRpb25UZXh0dXJlLG1hdHJpY2VzSW5kaWNlc1szXSxWQVRGcmFtZU51bSkqbWF0cmljZXNXZWlnaHRzWzNdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+NFxuVkFUSW5mbHVlbmNlKz1yZWFkTWF0cml4RnJvbVJhd1NhbXBsZXJWQVQoYmFrZWRWZXJ0ZXhBbmltYXRpb25UZXh0dXJlLG1hdHJpY2VzSW5kaWNlc0V4dHJhWzBdLFZBVEZyYW1lTnVtKSptYXRyaWNlc1dlaWdodHNFeHRyYVswXTtcbiNlbmRpZlxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjVcblZBVEluZmx1ZW5jZSs9cmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyVkFUKGJha2VkVmVydGV4QW5pbWF0aW9uVGV4dHVyZSxtYXRyaWNlc0luZGljZXNFeHRyYVsxXSxWQVRGcmFtZU51bSkqbWF0cmljZXNXZWlnaHRzRXh0cmFbMV07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz42XG5WQVRJbmZsdWVuY2UrPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmUsbWF0cmljZXNJbmRpY2VzRXh0cmFbMl0sVkFURnJhbWVOdW0pKm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzJdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+N1xuVkFUSW5mbHVlbmNlKz1yZWFkTWF0cml4RnJvbVJhd1NhbXBsZXJWQVQoYmFrZWRWZXJ0ZXhBbmltYXRpb25UZXh0dXJlLG1hdHJpY2VzSW5kaWNlc0V4dHJhWzNdLFZBVEZyYW1lTnVtKSptYXRyaWNlc1dlaWdodHNFeHRyYVszXTtcbiNlbmRpZlxuZmluYWxXb3JsZD1maW5hbFdvcmxkKlZBVEluZmx1ZW5jZTt9XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBiYWtlZFZlcnRleEFuaW1hdGlvbiA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWtlZFZlcnRleEFuaW1hdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImJha2VkVmVydGV4QW5pbWF0aW9uRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgQkFLRURfVkVSVEVYX0FOSU1BVElPTl9URVhUVVJFXG51bmlmb3JtIGZsb2F0IGJha2VkVmVydGV4QW5pbWF0aW9uVGltZTt1bmlmb3JtIHZlYzIgYmFrZWRWZXJ0ZXhBbmltYXRpb25UZXh0dXJlU2l6ZUludmVydGVkO3VuaWZvcm0gdmVjNCBiYWtlZFZlcnRleEFuaW1hdGlvblNldHRpbmdzO3VuaWZvcm0gc2FtcGxlcjJEIGJha2VkVmVydGV4QW5pbWF0aW9uVGV4dHVyZTtcbiNpZmRlZiBJTlNUQU5DRVNcbmF0dHJpYnV0ZSB2ZWM0IGJha2VkVmVydGV4QW5pbWF0aW9uU2V0dGluZ3NJbnN0YW5jZWQ7XG4jZW5kaWZcbiNkZWZpbmUgaW5saW5lXG5tYXQ0IHJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChzYW1wbGVyMkQgc21wLGZsb2F0IGluZGV4LGZsb2F0IGZyYW1lKVxue2Zsb2F0IG9mZnNldD1pbmRleCo0LjA7ZmxvYXQgZnJhbWVVVj0oZnJhbWUrMC41KSpiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmVTaXplSW52ZXJ0ZWQueTtmbG9hdCBkeD1iYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmVTaXplSW52ZXJ0ZWQueDt2ZWM0IG0wPXRleHR1cmUyRChzbXAsdmVjMihkeCoob2Zmc2V0KzAuNSksZnJhbWVVVikpO3ZlYzQgbTE9dGV4dHVyZTJEKHNtcCx2ZWMyKGR4KihvZmZzZXQrMS41KSxmcmFtZVVWKSk7dmVjNCBtMj10ZXh0dXJlMkQoc21wLHZlYzIoZHgqKG9mZnNldCsyLjUpLGZyYW1lVVYpKTt2ZWM0IG0zPXRleHR1cmUyRChzbXAsdmVjMihkeCoob2Zmc2V0KzMuNSksZnJhbWVVVikpO3JldHVybiBtYXQ0KG0wLG0xLG0yLG0zKTt9XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBiYWtlZFZlcnRleEFuaW1hdGlvbkRlY2xhcmF0aW9uID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJha2VkVmVydGV4QW5pbWF0aW9uRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJib25lc0RlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjBcbmF0dHJpYnV0ZSB2ZWM0IG1hdHJpY2VzSW5kaWNlczthdHRyaWJ1dGUgdmVjNCBtYXRyaWNlc1dlaWdodHM7XG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+NFxuYXR0cmlidXRlIHZlYzQgbWF0cmljZXNJbmRpY2VzRXh0cmE7YXR0cmlidXRlIHZlYzQgbWF0cmljZXNXZWlnaHRzRXh0cmE7XG4jZW5kaWZcbiNpZm5kZWYgQkFLRURfVkVSVEVYX0FOSU1BVElPTl9URVhUVVJFXG4jaWZkZWYgQk9ORVRFWFRVUkVcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGJvbmVTYW1wbGVyO3VuaWZvcm0gZmxvYXQgYm9uZVRleHR1cmVXaWR0aDtcbiNlbHNlXG51bmlmb3JtIG1hdDQgbUJvbmVzW0JvbmVzUGVyTWVzaF07XG4jZW5kaWZcbiNpZmRlZiBCT05FU19WRUxPQ0lUWV9FTkFCTEVEXG51bmlmb3JtIG1hdDQgbVByZXZpb3VzQm9uZXNbQm9uZXNQZXJNZXNoXTtcbiNlbmRpZlxuI2lmZGVmIEJPTkVURVhUVVJFXG4jZGVmaW5lIGlubGluZVxubWF0NCByZWFkTWF0cml4RnJvbVJhd1NhbXBsZXIoc2FtcGxlcjJEIHNtcCxmbG9hdCBpbmRleClcbntmbG9hdCBvZmZzZXQ9aW5kZXggKjQuMDtmbG9hdCBkeD0xLjAvYm9uZVRleHR1cmVXaWR0aDt2ZWM0IG0wPXRleHR1cmUyRChzbXAsdmVjMihkeCoob2Zmc2V0KzAuNSksMC4pKTt2ZWM0IG0xPXRleHR1cmUyRChzbXAsdmVjMihkeCoob2Zmc2V0KzEuNSksMC4pKTt2ZWM0IG0yPXRleHR1cmUyRChzbXAsdmVjMihkeCoob2Zmc2V0KzIuNSksMC4pKTt2ZWM0IG0zPXRleHR1cmUyRChzbXAsdmVjMihkeCoob2Zmc2V0KzMuNSksMC4pKTtyZXR1cm4gbWF0NChtMCxtMSxtMixtMyk7fVxuI2VuZGlmXG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGJvbmVzRGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9uZXNEZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImJvbmVzVmVydGV4XCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmbmRlZiBCQUtFRF9WRVJURVhfQU5JTUFUSU9OX1RFWFRVUkVcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz4wXG5tYXQ0IGluZmx1ZW5jZTtcbiNpZmRlZiBCT05FVEVYVFVSRVxuaW5mbHVlbmNlPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlcihib25lU2FtcGxlcixtYXRyaWNlc0luZGljZXNbMF0pKm1hdHJpY2VzV2VpZ2h0c1swXTtcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz4xXG5pbmZsdWVuY2UrPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlcihib25lU2FtcGxlcixtYXRyaWNlc0luZGljZXNbMV0pKm1hdHJpY2VzV2VpZ2h0c1sxXTtcbiNlbmRpZlxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjJcbmluZmx1ZW5jZSs9cmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyKGJvbmVTYW1wbGVyLG1hdHJpY2VzSW5kaWNlc1syXSkqbWF0cmljZXNXZWlnaHRzWzJdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+M1xuaW5mbHVlbmNlKz1yZWFkTWF0cml4RnJvbVJhd1NhbXBsZXIoYm9uZVNhbXBsZXIsbWF0cmljZXNJbmRpY2VzWzNdKSptYXRyaWNlc1dlaWdodHNbM107XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz40XG5pbmZsdWVuY2UrPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlcihib25lU2FtcGxlcixtYXRyaWNlc0luZGljZXNFeHRyYVswXSkqbWF0cmljZXNXZWlnaHRzRXh0cmFbMF07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz41XG5pbmZsdWVuY2UrPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlcihib25lU2FtcGxlcixtYXRyaWNlc0luZGljZXNFeHRyYVsxXSkqbWF0cmljZXNXZWlnaHRzRXh0cmFbMV07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz42XG5pbmZsdWVuY2UrPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlcihib25lU2FtcGxlcixtYXRyaWNlc0luZGljZXNFeHRyYVsyXSkqbWF0cmljZXNXZWlnaHRzRXh0cmFbMl07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz43XG5pbmZsdWVuY2UrPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlcihib25lU2FtcGxlcixtYXRyaWNlc0luZGljZXNFeHRyYVszXSkqbWF0cmljZXNXZWlnaHRzRXh0cmFbM107XG4jZW5kaWZcbiNlbHNlXG5pbmZsdWVuY2U9bUJvbmVzW2ludChtYXRyaWNlc0luZGljZXNbMF0pXSptYXRyaWNlc1dlaWdodHNbMF07XG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+MVxuaW5mbHVlbmNlKz1tQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlc1sxXSldKm1hdHJpY2VzV2VpZ2h0c1sxXTtcbiNlbmRpZlxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjJcbmluZmx1ZW5jZSs9bUJvbmVzW2ludChtYXRyaWNlc0luZGljZXNbMl0pXSptYXRyaWNlc1dlaWdodHNbMl07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz4zXG5pbmZsdWVuY2UrPW1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzWzNdKV0qbWF0cmljZXNXZWlnaHRzWzNdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+NFxuaW5mbHVlbmNlKz1tQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlc0V4dHJhWzBdKV0qbWF0cmljZXNXZWlnaHRzRXh0cmFbMF07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz41XG5pbmZsdWVuY2UrPW1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzRXh0cmFbMV0pXSptYXRyaWNlc1dlaWdodHNFeHRyYVsxXTtcbiNlbmRpZlxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjZcbmluZmx1ZW5jZSs9bUJvbmVzW2ludChtYXRyaWNlc0luZGljZXNFeHRyYVsyXSldKm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzJdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+N1xuaW5mbHVlbmNlKz1tQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlc0V4dHJhWzNdKV0qbWF0cmljZXNXZWlnaHRzRXh0cmFbM107XG4jZW5kaWZcbiNlbmRpZlxuZmluYWxXb3JsZD1maW5hbFdvcmxkKmluZmx1ZW5jZTtcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgYm9uZXNWZXJ0ZXggPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9uZXNWZXJ0ZXguanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJidW1wVmVydGV4XCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmIGRlZmluZWQoQlVNUCkgfHwgZGVmaW5lZChQQVJBTExBWCkgfHwgZGVmaW5lZChDTEVBUkNPQVRfQlVNUCkgfHwgZGVmaW5lZChBTklTT1RST1BJQylcbiNpZiBkZWZpbmVkKFRBTkdFTlQpICYmIGRlZmluZWQoTk9STUFMKVxudmVjMyB0Ym5Ob3JtYWw9bm9ybWFsaXplKG5vcm1hbFVwZGF0ZWQpO3ZlYzMgdGJuVGFuZ2VudD1ub3JtYWxpemUodGFuZ2VudFVwZGF0ZWQueHl6KTt2ZWMzIHRibkJpdGFuZ2VudD1jcm9zcyh0Ym5Ob3JtYWwsdGJuVGFuZ2VudCkqdGFuZ2VudFVwZGF0ZWQudzt2VEJOPW1hdDMoZmluYWxXb3JsZCkqbWF0Myh0Ym5UYW5nZW50LHRibkJpdGFuZ2VudCx0Ym5Ob3JtYWwpO1xuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBidW1wVmVydGV4ID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bXBWZXJ0ZXguanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJidW1wVmVydGV4RGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWYgZGVmaW5lZChCVU1QKSB8fCBkZWZpbmVkKFBBUkFMTEFYKSB8fCBkZWZpbmVkKENMRUFSQ09BVF9CVU1QKSB8fCBkZWZpbmVkKEFOSVNPVFJPUElDKVxuI2lmIGRlZmluZWQoVEFOR0VOVCkgJiYgZGVmaW5lZChOT1JNQUwpIFxudmFyeWluZyBtYXQzIHZUQk47XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGJ1bXBWZXJ0ZXhEZWNsYXJhdGlvbiA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW1wVmVydGV4RGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJkZWNhbFZlcnRleERlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIERFQ0FMXG51bmlmb3JtIHZlYzQgdkRlY2FsSW5mb3M7dW5pZm9ybSBtYXQ0IGRlY2FsTWF0cml4O1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZGVjYWxWZXJ0ZXhEZWNsYXJhdGlvbiA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNhbFZlcnRleERlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiaW5zdGFuY2VzRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgSU5TVEFOQ0VTXG5hdHRyaWJ1dGUgdmVjNCB3b3JsZDA7YXR0cmlidXRlIHZlYzQgd29ybGQxO2F0dHJpYnV0ZSB2ZWM0IHdvcmxkMjthdHRyaWJ1dGUgdmVjNCB3b3JsZDM7XG4jaWZkZWYgSU5TVEFOQ0VTQ09MT1JcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3I7XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFRISU5fSU5TVEFOQ0VTKSAmJiAhZGVmaW5lZChXT1JMRF9VQk8pXG51bmlmb3JtIG1hdDQgd29ybGQ7XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFZFTE9DSVRZKSB8fCBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpXG5hdHRyaWJ1dGUgdmVjNCBwcmV2aW91c1dvcmxkMDthdHRyaWJ1dGUgdmVjNCBwcmV2aW91c1dvcmxkMTthdHRyaWJ1dGUgdmVjNCBwcmV2aW91c1dvcmxkMjthdHRyaWJ1dGUgdmVjNCBwcmV2aW91c1dvcmxkMztcbiNpZmRlZiBUSElOX0lOU1RBTkNFU1xudW5pZm9ybSBtYXQ0IHByZXZpb3VzV29ybGQ7XG4jZW5kaWZcbiNlbmRpZlxuI2Vsc2VcbiNpZiAhZGVmaW5lZChXT1JMRF9VQk8pXG51bmlmb3JtIG1hdDQgd29ybGQ7XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFZFTE9DSVRZKSB8fCBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpXG51bmlmb3JtIG1hdDQgcHJldmlvdXNXb3JsZDtcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaW5zdGFuY2VzRGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdGFuY2VzRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJpbnN0YW5jZXNWZXJ0ZXhcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgSU5TVEFOQ0VTXG5tYXQ0IGZpbmFsV29ybGQ9bWF0NCh3b3JsZDAsd29ybGQxLHdvcmxkMix3b3JsZDMpO1xuI2lmIGRlZmluZWQoUFJFUEFTU19WRUxPQ0lUWSkgfHwgZGVmaW5lZChWRUxPQ0lUWSlcbm1hdDQgZmluYWxQcmV2aW91c1dvcmxkPW1hdDQocHJldmlvdXNXb3JsZDAscHJldmlvdXNXb3JsZDEscHJldmlvdXNXb3JsZDIscHJldmlvdXNXb3JsZDMpO1xuI2VuZGlmXG4jaWZkZWYgVEhJTl9JTlNUQU5DRVNcbmZpbmFsV29ybGQ9d29ybGQqZmluYWxXb3JsZDtcbiNpZiBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpIHx8IGRlZmluZWQoVkVMT0NJVFkpXG5maW5hbFByZXZpb3VzV29ybGQ9cHJldmlvdXNXb3JsZCpmaW5hbFByZXZpb3VzV29ybGQ7XG4jZW5kaWZcbiNlbmRpZlxuI2Vsc2Vcbm1hdDQgZmluYWxXb3JsZD13b3JsZDtcbiNpZiBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpIHx8IGRlZmluZWQoVkVMT0NJVFkpXG5tYXQ0IGZpbmFsUHJldmlvdXNXb3JsZD1wcmV2aW91c1dvcmxkO1xuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpbnN0YW5jZXNWZXJ0ZXggPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdGFuY2VzVmVydGV4LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibGlnaHRWeEZyYWdtZW50RGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTElHSFR7WH1cbnVuaWZvcm0gdmVjNCB2TGlnaHREYXRhe1h9O3VuaWZvcm0gdmVjNCB2TGlnaHREaWZmdXNle1h9O1xuI2lmZGVmIFNQRUNVTEFSVEVSTVxudW5pZm9ybSB2ZWM0IHZMaWdodFNwZWN1bGFye1h9O1xuI2Vsc2VcbnZlYzQgdkxpZ2h0U3BlY3VsYXJ7WH09dmVjNCgwLik7XG4jZW5kaWZcbiNpZmRlZiBTSEFET1d7WH1cbiNpZmRlZiBTSEFET1dDU017WH1cbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeHtYfVtTSEFET1dDU01OVU1fQ0FTQ0FERVN7WH1dO3ZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHR7WH1bU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9XTt2YXJ5aW5nIGZsb2F0IHZEZXB0aE1ldHJpY3tYfVtTSEFET1dDU01OVU1fQ0FTQ0FERVN7WH1dO3ZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tQ2FtZXJhe1h9O1xuI2VsaWYgZGVmaW5lZChTSEFET1dDVUJFe1h9KVxuI2Vsc2VcbnZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHR7WH07dmFyeWluZyBmbG9hdCB2RGVwdGhNZXRyaWN7WH07dW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4e1h9O1xuI2VuZGlmXG51bmlmb3JtIHZlYzQgc2hhZG93c0luZm97WH07dW5pZm9ybSB2ZWMyIGRlcHRoVmFsdWVze1h9O1xuI2VuZGlmXG4jaWZkZWYgU1BPVExJR0hUe1h9XG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlyZWN0aW9ue1h9O3VuaWZvcm0gdmVjNCB2TGlnaHRGYWxsb2Zme1h9O1xuI2VsaWYgZGVmaW5lZChQT0lOVExJR0hUe1h9KVxudW5pZm9ybSB2ZWM0IHZMaWdodEZhbGxvZmZ7WH07XG4jZWxpZiBkZWZpbmVkKEhFTUlMSUdIVHtYfSlcbnVuaWZvcm0gdmVjMyB2TGlnaHRHcm91bmR7WH07XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGxpZ2h0VnhGcmFnbWVudERlY2xhcmF0aW9uID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZ2h0VnhGcmFnbWVudERlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibGlnaHRWeFVib0RlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIExJR0hUe1h9XG51bmlmb3JtIExpZ2h0e1h9XG57dmVjNCB2TGlnaHREYXRhO3ZlYzQgdkxpZ2h0RGlmZnVzZTt2ZWM0IHZMaWdodFNwZWN1bGFyO1xuI2lmZGVmIFNQT1RMSUdIVHtYfVxudmVjNCB2TGlnaHREaXJlY3Rpb247dmVjNCB2TGlnaHRGYWxsb2ZmO1xuI2VsaWYgZGVmaW5lZChQT0lOVExJR0hUe1h9KVxudmVjNCB2TGlnaHRGYWxsb2ZmO1xuI2VsaWYgZGVmaW5lZChIRU1JTElHSFR7WH0pXG52ZWMzIHZMaWdodEdyb3VuZDtcbiNlbmRpZlxudmVjNCBzaGFkb3dzSW5mbzt2ZWMyIGRlcHRoVmFsdWVzO30gbGlnaHR7WH07XG4jaWZkZWYgU0hBRE9Xe1h9XG4jaWZkZWYgU0hBRE9XQ1NNe1h9XG51bmlmb3JtIG1hdDQgbGlnaHRNYXRyaXh7WH1bU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9XTt2YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0e1h9W1NIQURPV0NTTU5VTV9DQVNDQURFU3tYfV07dmFyeWluZyBmbG9hdCB2RGVwdGhNZXRyaWN7WH1bU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9XTt2YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUNhbWVyYXtYfTtcbiNlbGlmIGRlZmluZWQoU0hBRE9XQ1VCRXtYfSlcbiNlbHNlXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0e1h9O3ZhcnlpbmcgZmxvYXQgdkRlcHRoTWV0cmlje1h9O3VuaWZvcm0gbWF0NCBsaWdodE1hdHJpeHtYfTtcbiNlbmRpZlxuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBsaWdodFZ4VWJvRGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlnaHRWeFVib0RlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibWFpblVWVmFyeWluZ0RlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIE1BSU5VVntYfVxudmFyeWluZyB2ZWMyIHZNYWluVVZ7WH07XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBtYWluVVZWYXJ5aW5nRGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpblVWVmFyeWluZ0RlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibW9ycGhUYXJnZXRzVmVydGV4XCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIE1PUlBIVEFSR0VUU1xuI2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXG4jaWYge1h9PT0wXG5mb3IgKGludCBpPTA7IGk8TlVNX01PUlBIX0lORkxVRU5DRVJTOyBpKyspIHtpZiAoaT49bW9ycGhUYXJnZXRDb3VudCkgYnJlYWs7dmVydGV4SUQ9ZmxvYXQoZ2xfVmVydGV4SUQpKm1vcnBoVGFyZ2V0VGV4dHVyZUluZm8ueDtwb3NpdGlvblVwZGF0ZWQrPShyZWFkVmVjdG9yM0Zyb21SYXdTYW1wbGVyKGksdmVydGV4SUQpLXBvc2l0aW9uKSptb3JwaFRhcmdldEluZmx1ZW5jZXNbaV07dmVydGV4SUQrPTEuMDtcbiNpZmRlZiBNT1JQSFRBUkdFVFNfTk9STUFMXG5ub3JtYWxVcGRhdGVkKz0ocmVhZFZlY3RvcjNGcm9tUmF3U2FtcGxlcihpLHZlcnRleElEKSAtbm9ybWFsKSptb3JwaFRhcmdldEluZmx1ZW5jZXNbaV07dmVydGV4SUQrPTEuMDtcbiNlbmRpZlxuI2lmZGVmIE1PUlBIVEFSR0VUU19VVlxudXZVcGRhdGVkKz0ocmVhZFZlY3RvcjNGcm9tUmF3U2FtcGxlcihpLHZlcnRleElEKS54eS11dikqbW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldO3ZlcnRleElEKz0xLjA7XG4jZW5kaWZcbiNpZmRlZiBNT1JQSFRBUkdFVFNfVEFOR0VOVFxudGFuZ2VudFVwZGF0ZWQueHl6Kz0ocmVhZFZlY3RvcjNGcm9tUmF3U2FtcGxlcihpLHZlcnRleElEKSAtdGFuZ2VudC54eXopKm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXTtcbiNlbmRpZlxufVxuI2VuZGlmXG4jZWxzZVxucG9zaXRpb25VcGRhdGVkKz0ocG9zaXRpb257WH0tcG9zaXRpb24pKm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t7WH1dO1xuI2lmZGVmIE1PUlBIVEFSR0VUU19OT1JNQUxcbm5vcm1hbFVwZGF0ZWQrPShub3JtYWx7WH0tbm9ybWFsKSptb3JwaFRhcmdldEluZmx1ZW5jZXNbe1h9XTtcbiNlbmRpZlxuI2lmZGVmIE1PUlBIVEFSR0VUU19UQU5HRU5UXG50YW5nZW50VXBkYXRlZC54eXorPSh0YW5nZW50e1h9LXRhbmdlbnQueHl6KSptb3JwaFRhcmdldEluZmx1ZW5jZXNbe1h9XTtcbiNlbmRpZlxuI2lmZGVmIE1PUlBIVEFSR0VUU19VVlxudXZVcGRhdGVkKz0odXZfe1h9LXV2KSptb3JwaFRhcmdldEluZmx1ZW5jZXNbe1h9XTtcbiNlbmRpZlxuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBtb3JwaFRhcmdldHNWZXJ0ZXggPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ycGhUYXJnZXRzVmVydGV4LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibW9ycGhUYXJnZXRzVmVydGV4RGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTU9SUEhUQVJHRVRTXG4jaWZuZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbntYfTtcbiNpZmRlZiBNT1JQSFRBUkdFVFNfTk9STUFMXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWx7WH07XG4jZW5kaWZcbiNpZmRlZiBNT1JQSFRBUkdFVFNfVEFOR0VOVFxuYXR0cmlidXRlIHZlYzMgdGFuZ2VudHtYfTtcbiNlbmRpZlxuI2lmZGVmIE1PUlBIVEFSR0VUU19VVlxuYXR0cmlidXRlIHZlYzIgdXZfe1h9O1xuI2VuZGlmXG4jZWxpZiB7WH09PTBcbnVuaWZvcm0gaW50IG1vcnBoVGFyZ2V0Q291bnQ7XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG1vcnBoVGFyZ2V0c1ZlcnRleERlY2xhcmF0aW9uID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vcnBoVGFyZ2V0c1ZlcnRleERlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibW9ycGhUYXJnZXRzVmVydGV4R2xvYmFsXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIE1PUlBIVEFSR0VUU1xuI2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXG5mbG9hdCB2ZXJ0ZXhJRDtcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbW9ycGhUYXJnZXRzVmVydGV4R2xvYmFsID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vcnBoVGFyZ2V0c1ZlcnRleEdsb2JhbC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcIm1vcnBoVGFyZ2V0c1ZlcnRleEdsb2JhbERlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIE1PUlBIVEFSR0VUU1xudW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbTlVNX01PUlBIX0lORkxVRU5DRVJTXTtcbiNpZmRlZiBNT1JQSFRBUkdFVFNfVEVYVFVSRSBcbnVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRUZXh0dXJlSW5kaWNlc1tOVU1fTU9SUEhfSU5GTFVFTkNFUlNdO3VuaWZvcm0gdmVjMyBtb3JwaFRhcmdldFRleHR1cmVJbmZvO3VuaWZvcm0gaGlnaHAgc2FtcGxlcjJEQXJyYXkgbW9ycGhUYXJnZXRzO3ZlYzMgcmVhZFZlY3RvcjNGcm9tUmF3U2FtcGxlcihpbnQgdGFyZ2V0SW5kZXgsZmxvYXQgdmVydGV4SW5kZXgpXG57IFxuZmxvYXQgeT1mbG9vcih2ZXJ0ZXhJbmRleC9tb3JwaFRhcmdldFRleHR1cmVJbmZvLnkpO2Zsb2F0IHg9dmVydGV4SW5kZXgteSptb3JwaFRhcmdldFRleHR1cmVJbmZvLnk7dmVjMyB0ZXh0dXJlVVY9dmVjMygoeCswLjUpL21vcnBoVGFyZ2V0VGV4dHVyZUluZm8ueSwoeSswLjUpL21vcnBoVGFyZ2V0VGV4dHVyZUluZm8ueixtb3JwaFRhcmdldFRleHR1cmVJbmRpY2VzW3RhcmdldEluZGV4XSk7cmV0dXJuIHRleHR1cmUobW9ycGhUYXJnZXRzLHRleHR1cmVVVikueHl6O31cbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbW9ycGhUYXJnZXRzVmVydGV4R2xvYmFsRGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ycGhUYXJnZXRzVmVydGV4R2xvYmFsRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJwcmVQYXNzVmVydGV4XCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIFBSRVBBU1NfREVQVEhcbnZWaWV3UG9zPSh2aWV3KndvcmxkUG9zKS5yZ2I7XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpICYmIGRlZmluZWQoQk9ORVNfVkVMT0NJVFlfRU5BQkxFRClcbnZDdXJyZW50UG9zaXRpb249dmlld1Byb2plY3Rpb24qd29ybGRQb3M7XG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+MFxubWF0NCBwcmV2aW91c0luZmx1ZW5jZTtwcmV2aW91c0luZmx1ZW5jZT1tUHJldmlvdXNCb25lc1tpbnQobWF0cmljZXNJbmRpY2VzWzBdKV0qbWF0cmljZXNXZWlnaHRzWzBdO1xuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjFcbnByZXZpb3VzSW5mbHVlbmNlKz1tUHJldmlvdXNCb25lc1tpbnQobWF0cmljZXNJbmRpY2VzWzFdKV0qbWF0cmljZXNXZWlnaHRzWzFdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjJcbnByZXZpb3VzSW5mbHVlbmNlKz1tUHJldmlvdXNCb25lc1tpbnQobWF0cmljZXNJbmRpY2VzWzJdKV0qbWF0cmljZXNXZWlnaHRzWzJdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjNcbnByZXZpb3VzSW5mbHVlbmNlKz1tUHJldmlvdXNCb25lc1tpbnQobWF0cmljZXNJbmRpY2VzWzNdKV0qbWF0cmljZXNXZWlnaHRzWzNdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+NFxucHJldmlvdXNJbmZsdWVuY2UrPW1QcmV2aW91c0JvbmVzW2ludChtYXRyaWNlc0luZGljZXNFeHRyYVswXSldKm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzBdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjVcbnByZXZpb3VzSW5mbHVlbmNlKz1tUHJldmlvdXNCb25lc1tpbnQobWF0cmljZXNJbmRpY2VzRXh0cmFbMV0pXSptYXRyaWNlc1dlaWdodHNFeHRyYVsxXTtcbiNlbmRpZiBcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz42XG5wcmV2aW91c0luZmx1ZW5jZSs9bVByZXZpb3VzQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlc0V4dHJhWzJdKV0qbWF0cmljZXNXZWlnaHRzRXh0cmFbMl07XG4jZW5kaWYgXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+N1xucHJldmlvdXNJbmZsdWVuY2UrPW1QcmV2aW91c0JvbmVzW2ludChtYXRyaWNlc0luZGljZXNFeHRyYVszXSldKm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzNdO1xuI2VuZGlmXG52UHJldmlvdXNQb3NpdGlvbj1wcmV2aW91c1ZpZXdQcm9qZWN0aW9uKmZpbmFsUHJldmlvdXNXb3JsZCpwcmV2aW91c0luZmx1ZW5jZSp2ZWM0KHBvc2l0aW9uVXBkYXRlZCwxLjApO1xuI2Vsc2VcbnZQcmV2aW91c1Bvc2l0aW9uPXByZXZpb3VzVmlld1Byb2plY3Rpb24qZmluYWxQcmV2aW91c1dvcmxkKnZlYzQocG9zaXRpb25VcGRhdGVkLDEuMCk7XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHByZVBhc3NWZXJ0ZXggPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlUGFzc1ZlcnRleC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcInByZVBhc3NWZXJ0ZXhEZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBQUkVQQVNTXG4jaWZkZWYgUFJFUEFTU19ERVBUSFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zO1xuI2VuZGlmXG4jaWZkZWYgUFJFUEFTU19WRUxPQ0lUWVxudW5pZm9ybSBtYXQ0IHByZXZpb3VzVmlld1Byb2plY3Rpb247dmFyeWluZyB2ZWM0IHZDdXJyZW50UG9zaXRpb247dmFyeWluZyB2ZWM0IHZQcmV2aW91c1Bvc2l0aW9uO1xuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwcmVQYXNzVmVydGV4RGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlUGFzc1ZlcnRleERlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwic2FtcGxlclZlcnRleERlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmIGRlZmluZWQoX0RFRklORU5BTUVfKSAmJiBfREVGSU5FTkFNRV9ESVJFQ1RVVj09MFxudmFyeWluZyB2ZWMyIHZfVkFSWUlOR05BTUVfVVY7XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBzYW1wbGVyVmVydGV4RGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlclZlcnRleERlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwic2FtcGxlclZlcnRleEltcGxlbWVudGF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmIGRlZmluZWQoX0RFRklORU5BTUVfKSAmJiBfREVGSU5FTkFNRV9ESVJFQ1RVVj09MFxuaWYgKHZfSU5GT05BTUVfPT0wLilcbnt2X1ZBUllJTkdOQU1FX1VWPXZlYzIoX01BVFJJWE5BTUVfTWF0cml4KnZlYzQodXZVcGRhdGVkLDEuMCwwLjApKTt9XG4jaWZkZWYgVVYyXG5lbHNlIGlmICh2X0lORk9OQU1FXz09MS4pXG57dl9WQVJZSU5HTkFNRV9VVj12ZWMyKF9NQVRSSVhOQU1FX01hdHJpeCp2ZWM0KHV2MiwxLjAsMC4wKSk7fVxuI2VuZGlmXG4jaWZkZWYgVVYzXG5lbHNlIGlmICh2X0lORk9OQU1FXz09Mi4pXG57dl9WQVJZSU5HTkFNRV9VVj12ZWMyKF9NQVRSSVhOQU1FX01hdHJpeCp2ZWM0KHV2MywxLjAsMC4wKSk7fVxuI2VuZGlmXG4jaWZkZWYgVVY0XG5lbHNlIGlmICh2X0lORk9OQU1FXz09My4pXG57dl9WQVJZSU5HTkFNRV9VVj12ZWMyKF9NQVRSSVhOQU1FX01hdHJpeCp2ZWM0KHV2NCwxLjAsMC4wKSk7fVxuI2VuZGlmXG4jaWZkZWYgVVY1XG5lbHNlIGlmICh2X0lORk9OQU1FXz09NC4pXG57dl9WQVJZSU5HTkFNRV9VVj12ZWMyKF9NQVRSSVhOQU1FX01hdHJpeCp2ZWM0KHV2NSwxLjAsMC4wKSk7fVxuI2VuZGlmXG4jaWZkZWYgVVY2XG5lbHNlIGlmICh2X0lORk9OQU1FXz09NS4pXG57dl9WQVJZSU5HTkFNRV9VVj12ZWMyKF9NQVRSSVhOQU1FX01hdHJpeCp2ZWM0KHV2NiwxLjAsMC4wKSk7fVxuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBzYW1wbGVyVmVydGV4SW1wbGVtZW50YXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlclZlcnRleEltcGxlbWVudGF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwic2hhZG93c1ZlcnRleFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBTSEFET1dTXG4jaWYgZGVmaW5lZChTSEFET1dDU017WH0pXG52UG9zaXRpb25Gcm9tQ2FtZXJhe1h9PXZpZXcqd29ybGRQb3M7Zm9yIChpbnQgaT0wOyBpPFNIQURPV0NTTU5VTV9DQVNDQURFU3tYfTsgaSsrKSB7dlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2ldPWxpZ2h0TWF0cml4e1h9W2ldKndvcmxkUG9zO1xuI2lmZGVmIFVTRV9SRVZFUlNFX0RFUFRIQlVGRkVSXG52RGVwdGhNZXRyaWN7WH1baV09KC12UG9zaXRpb25Gcm9tTGlnaHR7WH1baV0ueitsaWdodHtYfS5kZXB0aFZhbHVlcy54KS9saWdodHtYfS5kZXB0aFZhbHVlcy55O1xuI2Vsc2VcbnZEZXB0aE1ldHJpY3tYfVtpXT0odlBvc2l0aW9uRnJvbUxpZ2h0e1h9W2ldLnorbGlnaHR7WH0uZGVwdGhWYWx1ZXMueCkvbGlnaHR7WH0uZGVwdGhWYWx1ZXMueTtcbiNlbmRpZlxufVxuI2VsaWYgZGVmaW5lZChTSEFET1d7WH0pICYmICFkZWZpbmVkKFNIQURPV0NVQkV7WH0pXG52UG9zaXRpb25Gcm9tTGlnaHR7WH09bGlnaHRNYXRyaXh7WH0qd29ybGRQb3M7XG4jaWZkZWYgVVNFX1JFVkVSU0VfREVQVEhCVUZGRVJcbnZEZXB0aE1ldHJpY3tYfT0oLXZQb3NpdGlvbkZyb21MaWdodHtYfS56K2xpZ2h0e1h9LmRlcHRoVmFsdWVzLngpL2xpZ2h0e1h9LmRlcHRoVmFsdWVzLnk7XG4jZWxzZVxudkRlcHRoTWV0cmlje1h9PSh2UG9zaXRpb25Gcm9tTGlnaHR7WH0ueitsaWdodHtYfS5kZXB0aFZhbHVlcy54KS9saWdodHtYfS5kZXB0aFZhbHVlcy55O1xuI2VuZGlmXG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHNoYWRvd3NWZXJ0ZXggPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93c1ZlcnRleC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcInV2QXR0cmlidXRlRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgVVZ7WH1cbmF0dHJpYnV0ZSB2ZWMyIHV2e1h9O1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgdXZBdHRyaWJ1dGVEZWNsYXJhdGlvbiA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dkF0dHJpYnV0ZURlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwidXZWYXJpYWJsZURlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmICFkZWZpbmVkKFVWe1h9KSAmJiBkZWZpbmVkKE1BSU5VVntYfSlcbnZlYzIgdXZ7WH09dmVjMigwLiwwLik7XG4jZW5kaWZcbiNpZmRlZiBNQUlOVVZ7WH1cbnZNYWluVVZ7WH09dXZ7WH07XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCB1dlZhcmlhYmxlRGVjbGFyYXRpb24gPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXZWYXJpYWJsZURlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwidmVydGV4Q29sb3JNaXhpbmdcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWYgZGVmaW5lZChWRVJURVhDT0xPUikgfHwgZGVmaW5lZChJTlNUQU5DRVNDT0xPUikgJiYgZGVmaW5lZChJTlNUQU5DRVMpXG52Q29sb3I9dmVjNCgxLjApO1xuI2lmZGVmIFZFUlRFWENPTE9SXG4jaWZkZWYgVkVSVEVYQUxQSEFcbnZDb2xvcio9Y29sb3I7XG4jZWxzZVxudkNvbG9yLnJnYio9Y29sb3IucmdiO1xuI2VuZGlmXG4jZW5kaWZcbiNpZmRlZiBJTlNUQU5DRVNDT0xPUlxudkNvbG9yKj1pbnN0YW5jZUNvbG9yO1xuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCB2ZXJ0ZXhDb2xvck1peGluZyA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJ0ZXhDb2xvck1peGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=