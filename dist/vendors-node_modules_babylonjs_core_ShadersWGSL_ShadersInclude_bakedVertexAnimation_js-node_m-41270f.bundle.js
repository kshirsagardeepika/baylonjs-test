"use strict";
(self["webpackChunksample1"] = self["webpackChunksample1"] || []).push([["vendors-node_modules_babylonjs_core_ShadersWGSL_ShadersInclude_bakedVertexAnimation_js-node_m-41270f"],{

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimation.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimation.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bakedVertexAnimationWGSL: () => (/* binding */ bakedVertexAnimationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bakedVertexAnimation";
const shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
let VATStartFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.x;let VATEndFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.y;let VATOffsetFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.z;let VATSpeed: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.w;
#else
let VATStartFrame: f32=uniforms.bakedVertexAnimationSettings.x;let VATEndFrame: f32=uniforms.bakedVertexAnimationSettings.y;let VATOffsetFrame: f32=uniforms.bakedVertexAnimationSettings.z;let VATSpeed: f32=uniforms.bakedVertexAnimationSettings.w;
#endif
let totalFrames: f32=VATEndFrame-VATStartFrame+1.0;let time: f32=uniforms.bakedVertexAnimationTime*VATSpeed/totalFrames;let frameCorrection: f32=select(1.0,0.0,time<1.0);let numOfFrames: f32=totalFrames-frameCorrection;var VATFrameNum: f32=fract(time)*numOfFrames;VATFrameNum=(VATFrameNum+VATOffsetFrame) % numOfFrames;VATFrameNum=floor(VATFrameNum);VATFrameNum=VATFrameNum+VATStartFrame+frameCorrection;var VATInfluence : mat4x4<f32>;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[0],VATFrameNum)*vertexInputs.matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[1],VATFrameNum)*vertexInputs.matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[2],VATFrameNum)*vertexInputs.matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[3],VATFrameNum)*vertexInputs.matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[0],VATFrameNum)*vertexInputs.matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[1],VATFrameNum)*vertexInputs.matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[2],VATFrameNum)*vertexInputs.matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[3],VATFrameNum)*vertexInputs.matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bakedVertexAnimationWGSL = { name, shader };
//# sourceMappingURL=bakedVertexAnimation.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bakedVertexAnimationDeclarationWGSL: () => (/* binding */ bakedVertexAnimationDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bakedVertexAnimationDeclaration";
const shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform bakedVertexAnimationTime: f32;uniform bakedVertexAnimationTextureSizeInverted: vec2<f32>;uniform bakedVertexAnimationSettings: vec4<f32>;var bakedVertexAnimationTexture : texture_2d<f32>;
#ifdef INSTANCES
attribute bakedVertexAnimationSettingsInstanced : vec4<f32>;
#endif
fn readMatrixFromRawSamplerVAT(smp : texture_2d<f32>,index : f32,frame : f32)->mat4x4<f32>
{let offset=i32(index)*4;let frameUV=i32(frame);let m0=textureLoad(smp,vec2<i32>(offset+0,frameUV),0);let m1=textureLoad(smp,vec2<i32>(offset+1,frameUV),0);let m2=textureLoad(smp,vec2<i32>(offset+2,frameUV),0);let m3=textureLoad(smp,vec2<i32>(offset+3,frameUV),0);return mat4x4<f32>(m0,m1,m2,m3);}
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bakedVertexAnimationDeclarationWGSL = { name, shader };
//# sourceMappingURL=bakedVertexAnimationDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesDeclaration.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesDeclaration.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bonesDeclarationWGSL: () => (/* binding */ bonesDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bonesDeclaration";
const shader = `#if NUM_BONE_INFLUENCERS>0
attribute matricesIndices : vec4<f32>;attribute matricesWeights : vec4<f32>;
#if NUM_BONE_INFLUENCERS>4
attribute matricesIndicesExtra : vec4<f32>;attribute matricesWeightsExtra : vec4<f32>;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
var boneSampler : texture_2d<f32>;uniform boneTextureWidth : f32;
#else
uniform mBones : array<mat4x4,BonesPerMesh>;
#ifdef BONES_VELOCITY_ENABLED
uniform mPreviousBones : array<mat4x4,BonesPerMesh>;
#endif
#endif
#ifdef BONETEXTURE
fn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>
{let offset=i32(index) *4; 
let m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bonesDeclarationWGSL = { name, shader };
//# sourceMappingURL=bonesDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesVertex.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesVertex.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bonesVertexWGSL: () => (/* binding */ bonesVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bonesVertex";
const shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
var influence : mat4x4<f32>;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[0])*vertexInputs.matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[1])*vertexInputs.matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[2])*vertexInputs.matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[3])*vertexInputs.matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[0])*vertexInputs.matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[1])*vertexInputs.matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[2])*vertexInputs.matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[3])*vertexInputs.matricesWeightsExtra[3];
#endif 
#else 
influence=uniforms.mBones[int(vertexInputs.matricesIndices[0])]*vertexInputs.matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+uniforms.mBones[int(vertexInputs.matricesIndices[1])]*vertexInputs.matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+uniforms.mBones[int(vertexInputs.matricesIndices[2])]*vertexInputs.matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+uniforms.mBones[int(vertexInputs.matricesIndices[3])]*vertexInputs.matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
influence=influence+uniforms.mBones[int(vertexInputs.matricesIndicesExtra[0])]*vertexInputs.matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
influence=influence+uniforms.mBones[int(vertexInputs.matricesIndicesExtra[1])]*vertexInputs.matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+uniforms.mBones[int(vertexInputs.matricesIndicesExtra[2])]*vertexInputs.matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+uniforms.mBones[int(vertexInputs.matricesIndicesExtra[3])]*vertexInputs.matricesWeightsExtra[3];
#endif 
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bonesVertexWGSL = { name, shader };
//# sourceMappingURL=bonesVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpVertex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpVertex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpVertexWGSL: () => (/* binding */ bumpVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bumpVertex";
const shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
var tbnNormal: vec3f=normalize(normalUpdated);var tbnTangent: vec3f=normalize(tangentUpdated.xyz);var tbnBitangent: vec3f=cross(tbnNormal,tbnTangent)*tangentUpdated.w;var matTemp= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz)* mat3x3f(tbnTangent,tbnBitangent,tbnNormal);vertexOutputs.vTBN0=matTemp[0];vertexOutputs.vTBN1=matTemp[1];vertexOutputs.vTBN2=matTemp[2];
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bumpVertexWGSL = { name, shader };
//# sourceMappingURL=bumpVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpVertexDeclaration.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpVertexDeclaration.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpVertexDeclarationWGSL: () => (/* binding */ bumpVertexDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "bumpVertexDeclaration";
const shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying vTBN0: vec3f;varying vTBN1: vec3f;varying vTBN2: vec3f;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const bumpVertexDeclarationWGSL = { name, shader };
//# sourceMappingURL=bumpVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertex.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertex.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clipPlaneVertexWGSL: () => (/* binding */ clipPlaneVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "clipPlaneVertex";
const shader = `#ifdef CLIPPLANE
vertexOutputs.fClipDistance=dot(worldPos,uniforms.vClipPlane);
#endif
#ifdef CLIPPLANE2
vertexOutputs.fClipDistance2=dot(worldPos,uniforms.vClipPlane2);
#endif
#ifdef CLIPPLANE3
vertexOutputs.fClipDistance3=dot(worldPos,uniforms.vClipPlane3);
#endif
#ifdef CLIPPLANE4
vertexOutputs.fClipDistance4=dot(worldPos,uniforms.vClipPlane4);
#endif
#ifdef CLIPPLANE5
vertexOutputs.fClipDistance5=dot(worldPos,uniforms.vClipPlane5);
#endif
#ifdef CLIPPLANE6
vertexOutputs.fClipDistance6=dot(worldPos,uniforms.vClipPlane6);
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const clipPlaneVertexWGSL = { name, shader };
//# sourceMappingURL=clipPlaneVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clipPlaneVertexDeclarationWGSL: () => (/* binding */ clipPlaneVertexDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "clipPlaneVertexDeclaration";
const shader = `#ifdef CLIPPLANE
uniform vClipPlane: vec4<f32>;varying fClipDistance: f32;
#endif
#ifdef CLIPPLANE2
uniform vClipPlane2: vec4<f32>;varying fClipDistance2: f32;
#endif
#ifdef CLIPPLANE3
uniform vClipPlane3: vec4<f32>;varying fClipDistance3: f32;
#endif
#ifdef CLIPPLANE4
uniform vClipPlane4: vec4<f32>;varying fClipDistance4: f32;
#endif
#ifdef CLIPPLANE5
uniform vClipPlane5: vec4<f32>;varying fClipDistance5: f32;
#endif
#ifdef CLIPPLANE6
uniform vClipPlane6: vec4<f32>;varying fClipDistance6: f32;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const clipPlaneVertexDeclarationWGSL = { name, shader };
//# sourceMappingURL=clipPlaneVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogVertex.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogVertex.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fogVertexWGSL: () => (/* binding */ fogVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "fogVertex";
const shader = `#ifdef FOG
vertexOutputs.vFogDistance=(scene.view*worldPos).xyz;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const fogVertexWGSL = { name, shader };
//# sourceMappingURL=fogVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogVertexDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogVertexDeclaration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fogVertexDeclarationWGSL: () => (/* binding */ fogVertexDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "fogVertexDeclaration";
const shader = `#ifdef FOG
varying vFogDistance: vec3f;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const fogVertexDeclarationWGSL = { name, shader };
//# sourceMappingURL=fogVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   helperFunctionsWGSL: () => (/* binding */ helperFunctionsWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "helperFunctions";
const shader = `const PI: f32=3.1415926535897932384626433832795;const RECIPROCAL_PI: f32=0.3183098861837907;const RECIPROCAL_PI2: f32=0.15915494309189535;const HALF_MIN: f32=5.96046448e-08; 
const LinearEncodePowerApprox: f32=2.2;const GammaEncodePowerApprox: f32=1.0/LinearEncodePowerApprox;const LuminanceEncodeApprox: vec3<f32>=vec3<f32> (0.2126,0.7152,0.0722);const Epsilon:f32=0.0000001;fn square(x: f32)->f32 {return x*x;}
fn saturate(x: f32)->f32 {return clamp(x,0.0,1.0);}
fn saturateVec3(x: vec3f)->vec3f {return clamp(x,vec3f(0.0),vec3f(1.0));}
fn saturateEps(x: f32)->f32 {return clamp(x,Epsilon,1.0);} 
fn maxEps(x: f32)->f32 {return max(x,Epsilon);}
fn maxEpsVec3(x: vec3f)->vec3f {return max(x,vec3f(Epsilon));}
fn absEps(x: f32)->f32 {return abs(x)+Epsilon;}
fn transposeMat3(inMatrix: mat3x3f)->mat3x3f {let i0: vec3<f32>=inMatrix[0];let i1: vec3<f32>=inMatrix[1];let i2: vec3<f32>=inMatrix[2];let outMatrix:mat3x3f=mat3x3f(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
fn inverseMat3(inMatrix: mat3x3f)->mat3x3f {let a00: f32=inMatrix[0][0];let a01: f32=inMatrix[0][1];let a02: f32=inMatrix[0][2];let a10: f32=inMatrix[1][0];let a11: f32=inMatrix[1][1];let a12: f32=inMatrix[1][2];let a20: f32=inMatrix[2][0];let a21: f32=inMatrix[2][1];let a22: f32=inMatrix[2][2];let b01: f32=a22*a11-a12*a21;let b11: f32=-a22*a10+a12*a20;let b21: f32=a21*a10-a11*a20;let det: f32=a00*b01+a01*b11+a02*b21;return mat3x3f(b01/det,(-a22*a01+a02*a21)/det,(a12*a01-a02*a11)/det,
b11/det,(a22*a00-a02*a20)/det,(-a12*a00+a02*a10)/det,
b21/det,(-a21*a00+a01*a20)/det,(a11*a00-a01*a10)/det);}
#if USE_EXACT_SRGB_CONVERSIONS
fn toLinearSpaceExact(color: vec3<f32>)->vec3<f32>
{let nearZeroSection: vec3<f32>=0.0773993808*color;let remainingSection: vec3<f32>=pow(0.947867299*(color+vec3<f32>(0.055)),vec3<f32>(2.4));return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3<f32>(0.04045)));}
fn toGammaSpaceExact(color: vec3<f32>)->vec3<f32>
{let nearZeroSection: vec3<f32>=12.92*color;let remainingSection: vec3<f32>=1.055*pow(color,vec3<f32>(0.41666))-vec3<f32>(0.055);return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3<f32>(0.0031308)));}
#endif
fn toLinearSpace(color: f32)->f32
{
#if USE_EXACT_SRGB_CONVERSIONS
var nearZeroSection=0.0773993808*color;var remainingSection=pow(0.947867299*(color+0.055),2.4);return select(remainingSection,nearZeroSection,color<=0.04045);
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
fn toLinearSpaceVec3(color: vec3<f32>)->vec3<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3<f32>(LinearEncodePowerApprox));
#endif
}
fn toLinearSpaceVec4(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4f(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4f(pow(color.rgb,vec3f(LinearEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpace(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4<f32>(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4<f32>(pow(color.rgb,vec3<f32>(GammaEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpaceVec3(color: vec3<f32>)->vec3<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3<f32>(GammaEncodePowerApprox));
#endif
}
fn squareVec3(value: vec3<f32>)->vec3<f32>
{return value*value;}
fn pow5(value: f32)->f32 {let sq: f32=value*value;return sq*sq*value;}
fn getLuminance(color: vec3<f32>)->f32
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
fn getRand(seed: vec2<f32>)->f32 {return fract(sin(dot(seed.xy ,vec2<f32>(12.9898,78.233)))*43758.5453);}
fn dither(seed: vec2<f32>,varianceAmount: f32)->f32 {let rand: f32=getRand(seed);let normVariance: f32=varianceAmount/255.0;let dither: f32=mix(-normVariance,normVariance,rand);return dither;}
const rgbdMaxRange: f32=255.0;fn toRGBD(color: vec3<f32>)->vec4<f32> {let maxRGB: f32=max(max(color.r,max(color.g,color.b)),Epsilon);var D: f32 =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);var rgb: vec3<f32> =color.rgb*D;rgb=toGammaSpaceVec3(rgb);return vec4<f32>(clamp(rgb,vec3<f32>(0.,0.,0.),vec3<f32>(1.,1.,1.)),D); }
fn fromRGBD(rgbd: vec4<f32>)->vec3<f32> {let rgb=toLinearSpaceVec3(rgbd.rgb);return rgb/rgbd.a;}
fn parallaxCorrectNormal(vertexPos: vec3<f32>,origVec: vec3<f32>,cubeSize: vec3<f32>,cubePos: vec3<f32>)->vec3<f32> {let invOrigVec: vec3<f32>=vec3<f32>(1.0,1.0,1.0)/origVec;let halfSize: vec3<f32>=cubeSize*0.5;let intersecAtMaxPlane: vec3<f32>=(cubePos+halfSize-vertexPos)*invOrigVec;let intersecAtMinPlane: vec3<f32>=(cubePos-halfSize-vertexPos)*invOrigVec;let largestIntersec: vec3<f32>=max(intersecAtMaxPlane,intersecAtMinPlane);let distance: f32=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);let intersectPositionWS: vec3<f32>=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const helperFunctionsWGSL = { name, shader };
//# sourceMappingURL=helperFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesDeclaration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   instancesDeclarationWGSL: () => (/* binding */ instancesDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "instancesDeclaration";
const shader = `#ifdef INSTANCES
attribute world0 : vec4<f32>;attribute world1 : vec4<f32>;attribute world2 : vec4<f32>;attribute world3 : vec4<f32>;
#ifdef INSTANCESCOLOR
attribute instanceColor : vec4<f32>;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform world : mat4x4<f32>;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute previousWorld0 : vec4<f32>;attribute previousWorld1 : vec4<f32>;attribute previousWorld2 : vec4<f32>;attribute previousWorld3 : vec4<f32>;
#ifdef THIN_INSTANCES
uniform previousWorld : mat4x4<f32>;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform world : mat4x4<f32>;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform previousWorld : mat4x4<f32>;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const instancesDeclarationWGSL = { name, shader };
//# sourceMappingURL=instancesDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesVertex.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesVertex.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   instancesVertexWGSL: () => (/* binding */ instancesVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "instancesVertex";
const shader = `#ifdef INSTANCES
var finalWorld=mat4x4<f32>(vertexInputs.world0,vertexInputs.world1,vertexInputs.world2,vertexInputs.world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
var finalPreviousWorld=mat4x4<f32>(vertexInputs.previousWorld0,vertexInputs.previousWorld1,vertexInputs.previousWorld2,vertexInputs.previousWorld3);
#endif
#ifdef THIN_INSTANCES
#if !defined(WORLD_UBO)
finalWorld=uniforms.world*finalWorld;
#else
finalWorld=mesh.world*finalWorld;
#endif
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=uniforms.previousWorld*finalPreviousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
var finalWorld=uniforms.world;
#else
var finalWorld=mesh.world;
#endif
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
var finalPreviousWorld=uniforms.previousWorld;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const instancesVertexWGSL = { name, shader };
//# sourceMappingURL=instancesVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightVxUboDeclaration.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightVxUboDeclaration.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightVxUboDeclarationWGSL: () => (/* binding */ lightVxUboDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "lightVxUboDeclaration";
const shader = `#ifdef LIGHT{X}
struct Light{X}
{vLightData: vec4f,
vLightDiffuse: vec4f,
vLightSpecular: vec4f,
#ifdef SPOTLIGHT{X}
vLightDirection: vec4f,
vLightFalloff: vec4f,
#elif defined(POINTLIGHT{X})
vLightFalloff: vec4f,
#elif defined(HEMILIGHT{X})
vLightGround: vec3f,
#endif
shadowsInfo: vec4f,
depthValues: vec2f} ;var<uniform> light{X} : Light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform lightMatrix{X}: array<mat4x4f,SHADOWCSMNUM_CASCADES{X}>;varying vPositionFromLight{X}_0: vec4f;varying vDepthMetric{X}_0: f32;varying vPositionFromLight{X}_1: vec4f;varying vDepthMetric{X}_1: f32;varying vPositionFromLight{X}_2: vec4f;varying vDepthMetric{X}_2: f32;varying vPositionFromLight{X}_3: vec4f;varying vDepthMetric{X}_3: f32;varying vPositionFromCamera{X}: vec4f;
#elif defined(SHADOWCUBE{X})
#else
varying vPositionFromLight{X}: vec4f;varying vDepthMetric{X}: f32;uniform lightMatrix{X}: mat4x4f;
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const lightVxUboDeclarationWGSL = { name, shader };
//# sourceMappingURL=lightVxUboDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthDeclaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthDeclaration.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logDepthDeclarationWGSL: () => (/* binding */ logDepthDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "logDepthDeclaration";
const shader = `#ifdef LOGARITHMICDEPTH
uniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const logDepthDeclarationWGSL = { name, shader };
//# sourceMappingURL=logDepthDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthVertex.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthVertex.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logDepthVertexWGSL: () => (/* binding */ logDepthVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "logDepthVertex";
const shader = `#ifdef LOGARITHMICDEPTH
vertexOutputs.vFragmentDepth=1.0+vertexOutputs.position.w;vertexOutputs.position.z=log2(max(0.000001,vertexOutputs.vFragmentDepth))*uniforms.logarithmicDepthConstant;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const logDepthVertexWGSL = { name, shader };
//# sourceMappingURL=logDepthVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/mainUVVaryingDeclaration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/mainUVVaryingDeclaration.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mainUVVaryingDeclarationWGSL: () => (/* binding */ mainUVVaryingDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "mainUVVaryingDeclaration";
const shader = `#ifdef MAINUV{X}
varying vMainUV{X}: vec2f;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const mainUVVaryingDeclarationWGSL = { name, shader };
//# sourceMappingURL=mainUVVaryingDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/meshUboDeclaration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/meshUboDeclaration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   meshUboDeclarationWGSL: () => (/* binding */ meshUboDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "meshUboDeclaration";
const shader = `struct Mesh {world : mat4x4<f32>,
visibility : f32,};var<uniform> mesh : Mesh;
#define WORLD_UBO
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const meshUboDeclarationWGSL = { name, shader };
//# sourceMappingURL=meshUboDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertex.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertex.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   morphTargetsVertexWGSL: () => (/* binding */ morphTargetsVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "morphTargetsVertex";
const shader = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
#if {X}==0
for (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (i>=uniforms.morphTargetCount) {break;}
vertexID=f32(vertexInputs.vertexIndex)*uniforms.morphTargetTextureInfo.x;positionUpdated=positionUpdated+(readVector3FromRawSampler(i,vertexID)-vertexInputs.position)*uniforms.morphTargetInfluences[i];vertexID=vertexID+1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated=normalUpdated+(readVector3FromRawSampler(i,vertexID) -vertexInputs.normal)*uniforms.morphTargetInfluences[i];vertexID=vertexID+1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated=uvUpdated+(readVector3FromRawSampler(i,vertexID).xy-vertexInputs.uv)*uniforms.morphTargetInfluences[i];vertexID=vertexID+1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated=vec4f(tangentUpdated.xyz+(readVector3FromRawSampler(i,vertexID) -vertexInputs.tangent.xyz)*uniforms.morphTargetInfluences[i],tangentUpdated.a);
#endif
}
#endif
#else
positionUpdated=positionUpdated+(vertexInputs.position{X}-vertexInputs.position)*uniforms.morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(vertexInputs.normal{X}-vertexInputs.normal)*uniforms.morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz=tangentUpdated.xyz+(vertexInputs.tangent{X}-vertexInputs.tangent.xyz)*uniforms.morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated=uvUpdated+(vertexInputs.uv_{X}-vertexInputs.uv)*uniforms.morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const morphTargetsVertexWGSL = { name, shader };
//# sourceMappingURL=morphTargetsVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   morphTargetsVertexDeclarationWGSL: () => (/* binding */ morphTargetsVertexDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "morphTargetsVertexDeclaration";
const shader = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute position{X} : vec3<f32>;
#ifdef MORPHTARGETS_NORMAL
attribute normal{X} : vec3<f32>;
#endif
#ifdef MORPHTARGETS_TANGENT
attribute tangent{X} : vec3<f32>;
#endif
#ifdef MORPHTARGETS_UV
attribute uv_{X} : vec2<f32>;
#endif
#elif {X}==0
uniform morphTargetCount: i32;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const morphTargetsVertexDeclarationWGSL = { name, shader };
//# sourceMappingURL=morphTargetsVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   morphTargetsVertexGlobalWGSL: () => (/* binding */ morphTargetsVertexGlobalWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "morphTargetsVertexGlobal";
const shader = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
var vertexID : f32;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const morphTargetsVertexGlobalWGSL = { name, shader };
//# sourceMappingURL=morphTargetsVertexGlobal.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   morphTargetsVertexGlobalDeclarationWGSL: () => (/* binding */ morphTargetsVertexGlobalDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "morphTargetsVertexGlobalDeclaration";
const shader = `#ifdef MORPHTARGETS
uniform morphTargetInfluences : array<f32,NUM_MORPH_INFLUENCERS>;
#ifdef MORPHTARGETS_TEXTURE 
uniform morphTargetTextureIndices : array<f32,NUM_MORPH_INFLUENCERS>;uniform morphTargetTextureInfo : vec3<f32>;var morphTargets : texture_2d_array<f32>;var morphTargetsSampler : sampler;fn readVector3FromRawSampler(targetIndex : i32,vertexIndex : f32)->vec3<f32>
{ 
let y=floor(vertexIndex/uniforms.morphTargetTextureInfo.y);let x=vertexIndex-y*uniforms.morphTargetTextureInfo.y;let textureUV=vec2<f32>((x+0.5)/uniforms.morphTargetTextureInfo.y,(y+0.5)/uniforms.morphTargetTextureInfo.z);return textureSampleLevel(morphTargets,morphTargetsSampler,textureUV,i32(uniforms.morphTargetTextureIndices[targetIndex]),0.0).xyz;}
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const morphTargetsVertexGlobalDeclarationWGSL = { name, shader };
//# sourceMappingURL=morphTargetsVertexGlobalDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassVertex.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassVertex.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prePassVertexWGSL: () => (/* binding */ prePassVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "prePassVertex";
const shader = `#ifdef PREPASS_DEPTH
vertexOutputs.vViewPos=(scene.view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vertexOutputs.vCurrentPosition=scene.viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
var previousInfluence: mat4x4f;previousInfluence=mPreviousBones[ i32(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[ i32(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[ i32(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[ i32(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*previousInfluence* vec4f(positionUpdated,1.0);
#else
vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const prePassVertexWGSL = { name, shader };
//# sourceMappingURL=prePassVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassVertexDeclaration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassVertexDeclaration.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prePassVertexDeclarationWGSL: () => (/* binding */ prePassVertexDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "prePassVertexDeclaration";
const shader = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vViewPos: vec3f;
#endif
#ifdef PREPASS_VELOCITY
uniform previousViewProjection: mat4x4f;varying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const prePassVertexDeclarationWGSL = { name, shader };
//# sourceMappingURL=prePassVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerVertexDeclaration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerVertexDeclaration.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   samplerVertexDeclarationWGSL: () => (/* binding */ samplerVertexDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "samplerVertexDeclaration";
const shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying v_VARYINGNAME_UV: vec2f;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const samplerVertexDeclarationWGSL = { name, shader };
//# sourceMappingURL=samplerVertexDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerVertexImplementation.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerVertexImplementation.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   samplerVertexImplementationWGSL: () => (/* binding */ samplerVertexImplementationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "samplerVertexImplementation";
const shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (uniforms.v_INFONAME_==0.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(uvUpdated,1.0,0.0)).xy;}
#ifdef UV2
else if (uniforms.v_INFONAME_==1.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv2,1.0,0.0)).xy;}
#endif
#ifdef UV3
else if (uniforms.v_INFONAME_==2.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv3,1.0,0.0)).xy;}
#endif
#ifdef UV4
else if (uniforms.v_INFONAME_==3.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv4,1.0,0.0)).xy;}
#endif
#ifdef UV5
else if (uniforms.v_INFONAME_==4.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv5,1.0,0.0)).xy;}
#endif
#ifdef UV6
else if (uniforms.v_INFONAME_==5.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv6,1.0,0.0)).xy;}
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const samplerVertexImplementationWGSL = { name, shader };
//# sourceMappingURL=samplerVertexImplementation.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/sceneUboDeclaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/sceneUboDeclaration.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sceneUboDeclarationWGSL: () => (/* binding */ sceneUboDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "sceneUboDeclaration";
const shader = `struct Scene {viewProjection : mat4x4<f32>,
#ifdef MULTIVIEW
viewProjectionR : mat4x4<f32>,
#endif 
view : mat4x4<f32>,
projection : mat4x4<f32>,
vEyePosition : vec4<f32>,};var<uniform> scene : Scene;
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const sceneUboDeclarationWGSL = { name, shader };
//# sourceMappingURL=sceneUboDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowsVertex.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowsVertex.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shadowsVertexWGSL: () => (/* binding */ shadowsVertexWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "shadowsVertex";
const shader = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vertexOutputs.vPositionFromCamera{X}=scene.view*worldPos;
#if SHADOWCSMNUM_CASCADES{X}>0
vertexOutputs.vPositionFromLight{X}_0=uniforms.lightMatrix{X}[0]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}_0=(-vertexOutputs.vPositionFromLight{X}_0.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}_0= (vertexOutputs.vPositionFromLight{X}_0.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#if SHADOWCSMNUM_CASCADES{X}>1
vertexOutputs.vPositionFromLight{X}_1=uniforms.lightMatrix{X}[1]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}_1=(-vertexOutputs.vPositionFromLight{X}_1.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}_1= (vertexOutputs.vPositionFromLight{X}_1.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif 
#if SHADOWCSMNUM_CASCADES{X}>2
vertexOutputs.vPositionFromLight{X}_2=uniforms.lightMatrix{X}[2]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}_2=(-vertexOutputs.vPositionFromLight{X}_2.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}_2= (vertexOutputs.vPositionFromLight{X}_2.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif 
#if SHADOWCSMNUM_CASCADES{X}>3
vertexOutputs.vPositionFromLight{X}_3=uniforms.lightMatrix{X}[3]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}_3=(-vertexOutputs.vPositionFromLight{X}_3.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}_3= (vertexOutputs.vPositionFromLight{X}_3.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif 
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vertexOutputs.vPositionFromLight{X}=uniforms.lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}=(-vertexOutputs.vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}=(vertexOutputs.vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const shadowsVertexWGSL = { name, shader };
//# sourceMappingURL=shadowsVertex.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/uvAttributeDeclaration.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/uvAttributeDeclaration.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uvAttributeDeclarationWGSL: () => (/* binding */ uvAttributeDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "uvAttributeDeclaration";
const shader = `#ifdef UV{X}
attribute uv{X}: vec2f;
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const uvAttributeDeclarationWGSL = { name, shader };
//# sourceMappingURL=uvAttributeDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/uvVariableDeclaration.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/uvVariableDeclaration.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uvVariableDeclarationWGSL: () => (/* binding */ uvVariableDeclarationWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "uvVariableDeclaration";
const shader = `#ifdef MAINUV{X}
#if !defined(UV{X})
var uv{X}: vec2f=vec2f(0.,0.);
#else
var uv{X}: vec2f=vertexInputs.uv{X};
#endif
vertexOutputs.vMainUV{X}=uv{X};
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const uvVariableDeclarationWGSL = { name, shader };
//# sourceMappingURL=uvVariableDeclaration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/vertexColorMixing.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/vertexColorMixing.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   vertexColorMixingWGSL: () => (/* binding */ vertexColorMixingWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "vertexColorMixing";
const shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vertexOutputs.vColor=vec4f(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vertexOutputs.vColor*=vertexInputs.color;
#else
vertexOutputs.vColor=vec4f(vertexOutputs.vColor.rgb*vertexInputs.color.rgb,vertexOutputs.vColor.a);
#endif
#endif
#ifdef INSTANCESCOLOR
vertexOutputs.vColor*=vertexInputs.instanceColor;
#endif
#endif
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const vertexColorMixingWGSL = { name, shader };
//# sourceMappingURL=vertexColorMixing.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfU2hhZGVyc1dHU0xfU2hhZGVyc0luY2x1ZGVfYmFrZWRWZXJ0ZXhBbmltYXRpb25fanMtbm9kZV9tLTQxMjcwZi5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwwRUFBMEUsNkVBQTZFO0FBQ25PO0FBQ0EsK0RBQStELDZEQUE2RCxnRUFBZ0U7QUFDNUw7QUFDQSxtREFBbUQscUVBQXFFLGtEQUFrRCxpREFBaUQsNkNBQTZDLHVEQUF1RCwrQkFBK0Isc0RBQXNELCtCQUErQjtBQUNuYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyxtQ0FBbUM7QUFDMUM7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0Esc0NBQXNDLDJEQUEyRCxnREFBZ0Q7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix1QkFBdUIsc0RBQXNELHNEQUFzRCxzREFBc0Qsc0RBQXNEO0FBQ3hRO0FBQ0E7QUFDQTtBQUNBLGdFQUFXO0FBQ1g7QUFDTyw4Q0FBOEM7QUFDckQ7Ozs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdEQUFnRCxnREFBZ0QsZ0RBQWdELGdEQUFnRDtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQVc7QUFDWDtBQUNPLCtCQUEr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LEVBQUU7QUFDbEIsT0FBTyxFQUFFO0FBQ1Q7QUFDQSxPQUFPLEVBQUUsd0JBQXdCO0FBQ2pDO0FBQ0Esc0JBQXNCLEVBQUUsSUFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxnRUFBVztBQUNYO0FBQ08sb0NBQW9DO0FBQzNDOzs7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBVztBQUNYO0FBQ08sZ0NBQWdDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvYmFrZWRWZXJ0ZXhBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvYmFrZWRWZXJ0ZXhBbmltYXRpb25EZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9ib25lc0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2JvbmVzVmVydGV4LmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2J1bXBWZXJ0ZXguanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvYnVtcFZlcnRleERlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2NsaXBQbGFuZVZlcnRleC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9jbGlwUGxhbmVWZXJ0ZXhEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9mb2dWZXJ0ZXguanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvZm9nVmVydGV4RGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvaGVscGVyRnVuY3Rpb25zLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2luc3RhbmNlc0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2luc3RhbmNlc1ZlcnRleC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9saWdodFZ4VWJvRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvbG9nRGVwdGhEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9sb2dEZXB0aFZlcnRleC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9tYWluVVZWYXJ5aW5nRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvbWVzaFVib0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL21vcnBoVGFyZ2V0c1ZlcnRleC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9tb3JwaFRhcmdldHNWZXJ0ZXhEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9tb3JwaFRhcmdldHNWZXJ0ZXhHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvbW9ycGhUYXJnZXRzVmVydGV4R2xvYmFsRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvcHJlUGFzc1ZlcnRleC5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9wcmVQYXNzVmVydGV4RGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvc2FtcGxlclZlcnRleERlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL3NhbXBsZXJWZXJ0ZXhJbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS9zY2VuZVVib0RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL3NoYWRvd3NWZXJ0ZXguanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvdXZBdHRyaWJ1dGVEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9zYW1wbGUxLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9TaGFkZXJzSW5jbHVkZS91dlZhcmlhYmxlRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvdmVydGV4Q29sb3JNaXhpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJiYWtlZFZlcnRleEFuaW1hdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBCQUtFRF9WRVJURVhfQU5JTUFUSU9OX1RFWFRVUkVcbntcbiNpZmRlZiBJTlNUQU5DRVNcbmxldCBWQVRTdGFydEZyYW1lOiBmMzI9dmVydGV4SW5wdXRzLmJha2VkVmVydGV4QW5pbWF0aW9uU2V0dGluZ3NJbnN0YW5jZWQueDtsZXQgVkFURW5kRnJhbWU6IGYzMj12ZXJ0ZXhJbnB1dHMuYmFrZWRWZXJ0ZXhBbmltYXRpb25TZXR0aW5nc0luc3RhbmNlZC55O2xldCBWQVRPZmZzZXRGcmFtZTogZjMyPXZlcnRleElucHV0cy5iYWtlZFZlcnRleEFuaW1hdGlvblNldHRpbmdzSW5zdGFuY2VkLno7bGV0IFZBVFNwZWVkOiBmMzI9dmVydGV4SW5wdXRzLmJha2VkVmVydGV4QW5pbWF0aW9uU2V0dGluZ3NJbnN0YW5jZWQudztcbiNlbHNlXG5sZXQgVkFUU3RhcnRGcmFtZTogZjMyPXVuaWZvcm1zLmJha2VkVmVydGV4QW5pbWF0aW9uU2V0dGluZ3MueDtsZXQgVkFURW5kRnJhbWU6IGYzMj11bmlmb3Jtcy5iYWtlZFZlcnRleEFuaW1hdGlvblNldHRpbmdzLnk7bGV0IFZBVE9mZnNldEZyYW1lOiBmMzI9dW5pZm9ybXMuYmFrZWRWZXJ0ZXhBbmltYXRpb25TZXR0aW5ncy56O2xldCBWQVRTcGVlZDogZjMyPXVuaWZvcm1zLmJha2VkVmVydGV4QW5pbWF0aW9uU2V0dGluZ3MudztcbiNlbmRpZlxubGV0IHRvdGFsRnJhbWVzOiBmMzI9VkFURW5kRnJhbWUtVkFUU3RhcnRGcmFtZSsxLjA7bGV0IHRpbWU6IGYzMj11bmlmb3Jtcy5iYWtlZFZlcnRleEFuaW1hdGlvblRpbWUqVkFUU3BlZWQvdG90YWxGcmFtZXM7bGV0IGZyYW1lQ29ycmVjdGlvbjogZjMyPXNlbGVjdCgxLjAsMC4wLHRpbWU8MS4wKTtsZXQgbnVtT2ZGcmFtZXM6IGYzMj10b3RhbEZyYW1lcy1mcmFtZUNvcnJlY3Rpb247dmFyIFZBVEZyYW1lTnVtOiBmMzI9ZnJhY3QodGltZSkqbnVtT2ZGcmFtZXM7VkFURnJhbWVOdW09KFZBVEZyYW1lTnVtK1ZBVE9mZnNldEZyYW1lKSAlIG51bU9mRnJhbWVzO1ZBVEZyYW1lTnVtPWZsb29yKFZBVEZyYW1lTnVtKTtWQVRGcmFtZU51bT1WQVRGcmFtZU51bStWQVRTdGFydEZyYW1lK2ZyYW1lQ29ycmVjdGlvbjt2YXIgVkFUSW5mbHVlbmNlIDogbWF0NHg0PGYzMj47VkFUSW5mbHVlbmNlPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmUsdmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc1swXSxWQVRGcmFtZU51bSkqdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c1swXTtcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz4xXG5WQVRJbmZsdWVuY2U9VkFUSW5mbHVlbmNlK3JlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmUsdmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc1sxXSxWQVRGcmFtZU51bSkqdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c1sxXTtcbiNlbmRpZlxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjJcblZBVEluZmx1ZW5jZT1WQVRJbmZsdWVuY2UrcmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyVkFUKGJha2VkVmVydGV4QW5pbWF0aW9uVGV4dHVyZSx2ZXJ0ZXhJbnB1dHMubWF0cmljZXNJbmRpY2VzWzJdLFZBVEZyYW1lTnVtKSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzWzJdO1xuI2VuZGlmXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+M1xuVkFUSW5mbHVlbmNlPVZBVEluZmx1ZW5jZStyZWFkTWF0cml4RnJvbVJhd1NhbXBsZXJWQVQoYmFrZWRWZXJ0ZXhBbmltYXRpb25UZXh0dXJlLHZlcnRleElucHV0cy5tYXRyaWNlc0luZGljZXNbM10sVkFURnJhbWVOdW0pKnZlcnRleElucHV0cy5tYXRyaWNlc1dlaWdodHNbM107XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz40XG5WQVRJbmZsdWVuY2U9VkFUSW5mbHVlbmNlK3JlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmUsdmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc0V4dHJhWzBdLFZBVEZyYW1lTnVtKSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzRXh0cmFbMF07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz41XG5WQVRJbmZsdWVuY2U9VkFUSW5mbHVlbmNlK3JlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmUsdmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc0V4dHJhWzFdLFZBVEZyYW1lTnVtKSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzRXh0cmFbMV07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz42XG5WQVRJbmZsdWVuY2U9VkFUSW5mbHVlbmNlK3JlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmUsdmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc0V4dHJhWzJdLFZBVEZyYW1lTnVtKSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzRXh0cmFbMl07XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz43XG5WQVRJbmZsdWVuY2U9VkFUSW5mbHVlbmNlK3JlYWRNYXRyaXhGcm9tUmF3U2FtcGxlclZBVChiYWtlZFZlcnRleEFuaW1hdGlvblRleHR1cmUsdmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc0V4dHJhWzNdLFZBVEZyYW1lTnVtKSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzRXh0cmFbM107XG4jZW5kaWZcbmZpbmFsV29ybGQ9ZmluYWxXb3JsZCpWQVRJbmZsdWVuY2U7fVxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGJha2VkVmVydGV4QW5pbWF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWtlZFZlcnRleEFuaW1hdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImJha2VkVmVydGV4QW5pbWF0aW9uRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgQkFLRURfVkVSVEVYX0FOSU1BVElPTl9URVhUVVJFXG51bmlmb3JtIGJha2VkVmVydGV4QW5pbWF0aW9uVGltZTogZjMyO3VuaWZvcm0gYmFrZWRWZXJ0ZXhBbmltYXRpb25UZXh0dXJlU2l6ZUludmVydGVkOiB2ZWMyPGYzMj47dW5pZm9ybSBiYWtlZFZlcnRleEFuaW1hdGlvblNldHRpbmdzOiB2ZWM0PGYzMj47dmFyIGJha2VkVmVydGV4QW5pbWF0aW9uVGV4dHVyZSA6IHRleHR1cmVfMmQ8ZjMyPjtcbiNpZmRlZiBJTlNUQU5DRVNcbmF0dHJpYnV0ZSBiYWtlZFZlcnRleEFuaW1hdGlvblNldHRpbmdzSW5zdGFuY2VkIDogdmVjNDxmMzI+O1xuI2VuZGlmXG5mbiByZWFkTWF0cml4RnJvbVJhd1NhbXBsZXJWQVQoc21wIDogdGV4dHVyZV8yZDxmMzI+LGluZGV4IDogZjMyLGZyYW1lIDogZjMyKS0+bWF0NHg0PGYzMj5cbntsZXQgb2Zmc2V0PWkzMihpbmRleCkqNDtsZXQgZnJhbWVVVj1pMzIoZnJhbWUpO2xldCBtMD10ZXh0dXJlTG9hZChzbXAsdmVjMjxpMzI+KG9mZnNldCswLGZyYW1lVVYpLDApO2xldCBtMT10ZXh0dXJlTG9hZChzbXAsdmVjMjxpMzI+KG9mZnNldCsxLGZyYW1lVVYpLDApO2xldCBtMj10ZXh0dXJlTG9hZChzbXAsdmVjMjxpMzI+KG9mZnNldCsyLGZyYW1lVVYpLDApO2xldCBtMz10ZXh0dXJlTG9hZChzbXAsdmVjMjxpMzI+KG9mZnNldCszLGZyYW1lVVYpLDApO3JldHVybiBtYXQ0eDQ8ZjMyPihtMCxtMSxtMixtMyk7fVxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGJha2VkVmVydGV4QW5pbWF0aW9uRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJha2VkVmVydGV4QW5pbWF0aW9uRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJib25lc0RlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjBcbmF0dHJpYnV0ZSBtYXRyaWNlc0luZGljZXMgOiB2ZWM0PGYzMj47YXR0cmlidXRlIG1hdHJpY2VzV2VpZ2h0cyA6IHZlYzQ8ZjMyPjtcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz40XG5hdHRyaWJ1dGUgbWF0cmljZXNJbmRpY2VzRXh0cmEgOiB2ZWM0PGYzMj47YXR0cmlidXRlIG1hdHJpY2VzV2VpZ2h0c0V4dHJhIDogdmVjNDxmMzI+O1xuI2VuZGlmXG4jaWZuZGVmIEJBS0VEX1ZFUlRFWF9BTklNQVRJT05fVEVYVFVSRVxuI2lmZGVmIEJPTkVURVhUVVJFXG52YXIgYm9uZVNhbXBsZXIgOiB0ZXh0dXJlXzJkPGYzMj47dW5pZm9ybSBib25lVGV4dHVyZVdpZHRoIDogZjMyO1xuI2Vsc2VcbnVuaWZvcm0gbUJvbmVzIDogYXJyYXk8bWF0NHg0LEJvbmVzUGVyTWVzaD47XG4jaWZkZWYgQk9ORVNfVkVMT0NJVFlfRU5BQkxFRFxudW5pZm9ybSBtUHJldmlvdXNCb25lcyA6IGFycmF5PG1hdDR4NCxCb25lc1Blck1lc2g+O1xuI2VuZGlmXG4jZW5kaWZcbiNpZmRlZiBCT05FVEVYVFVSRVxuZm4gcmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyKHNtcCA6IHRleHR1cmVfMmQ8ZjMyPixpbmRleCA6IGYzMiktPm1hdDR4NDxmMzI+XG57bGV0IG9mZnNldD1pMzIoaW5kZXgpICo0OyBcbmxldCBtMD10ZXh0dXJlTG9hZChzbXAsdmVjMjxpMzI+KG9mZnNldCswLDApLDApO2xldCBtMT10ZXh0dXJlTG9hZChzbXAsdmVjMjxpMzI+KG9mZnNldCsxLDApLDApO2xldCBtMj10ZXh0dXJlTG9hZChzbXAsdmVjMjxpMzI+KG9mZnNldCsyLDApLDApO2xldCBtMz10ZXh0dXJlTG9hZChzbXAsdmVjMjxpMzI+KG9mZnNldCszLDApLDApO3JldHVybiBtYXQ0eDQ8ZjMyPihtMCxtMSxtMixtMyk7fVxuI2VuZGlmXG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBib25lc0RlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib25lc0RlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiYm9uZXNWZXJ0ZXhcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZuZGVmIEJBS0VEX1ZFUlRFWF9BTklNQVRJT05fVEVYVFVSRVxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjBcbnZhciBpbmZsdWVuY2UgOiBtYXQ0eDQ8ZjMyPjtcbiNpZmRlZiBCT05FVEVYVFVSRVxuaW5mbHVlbmNlPXJlYWRNYXRyaXhGcm9tUmF3U2FtcGxlcihib25lU2FtcGxlcix2ZXJ0ZXhJbnB1dHMubWF0cmljZXNJbmRpY2VzWzBdKSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzWzBdO1xuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjFcbmluZmx1ZW5jZT1pbmZsdWVuY2UrcmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyKGJvbmVTYW1wbGVyLHZlcnRleElucHV0cy5tYXRyaWNlc0luZGljZXNbMV0pKnZlcnRleElucHV0cy5tYXRyaWNlc1dlaWdodHNbMV07XG4jZW5kaWYgXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+MlxuaW5mbHVlbmNlPWluZmx1ZW5jZStyZWFkTWF0cml4RnJvbVJhd1NhbXBsZXIoYm9uZVNhbXBsZXIsdmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc1syXSkqdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c1syXTtcbiNlbmRpZiBcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz4zXG5pbmZsdWVuY2U9aW5mbHVlbmNlK3JlYWRNYXRyaXhGcm9tUmF3U2FtcGxlcihib25lU2FtcGxlcix2ZXJ0ZXhJbnB1dHMubWF0cmljZXNJbmRpY2VzWzNdKSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzWzNdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjRcbmluZmx1ZW5jZT1pbmZsdWVuY2UrcmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyKGJvbmVTYW1wbGVyLHZlcnRleElucHV0cy5tYXRyaWNlc0luZGljZXNFeHRyYVswXSkqdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzBdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjVcbmluZmx1ZW5jZT1pbmZsdWVuY2UrcmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyKGJvbmVTYW1wbGVyLHZlcnRleElucHV0cy5tYXRyaWNlc0luZGljZXNFeHRyYVsxXSkqdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzFdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjZcbmluZmx1ZW5jZT1pbmZsdWVuY2UrcmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyKGJvbmVTYW1wbGVyLHZlcnRleElucHV0cy5tYXRyaWNlc0luZGljZXNFeHRyYVsyXSkqdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzJdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjdcbmluZmx1ZW5jZT1pbmZsdWVuY2UrcmVhZE1hdHJpeEZyb21SYXdTYW1wbGVyKGJvbmVTYW1wbGVyLHZlcnRleElucHV0cy5tYXRyaWNlc0luZGljZXNFeHRyYVszXSkqdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzNdO1xuI2VuZGlmIFxuI2Vsc2UgXG5pbmZsdWVuY2U9dW5pZm9ybXMubUJvbmVzW2ludCh2ZXJ0ZXhJbnB1dHMubWF0cmljZXNJbmRpY2VzWzBdKV0qdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c1swXTtcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz4xXG5pbmZsdWVuY2U9aW5mbHVlbmNlK3VuaWZvcm1zLm1Cb25lc1tpbnQodmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc1sxXSldKnZlcnRleElucHV0cy5tYXRyaWNlc1dlaWdodHNbMV07XG4jZW5kaWYgXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+MlxuaW5mbHVlbmNlPWluZmx1ZW5jZSt1bmlmb3Jtcy5tQm9uZXNbaW50KHZlcnRleElucHV0cy5tYXRyaWNlc0luZGljZXNbMl0pXSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzWzJdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjNcbmluZmx1ZW5jZT1pbmZsdWVuY2UrdW5pZm9ybXMubUJvbmVzW2ludCh2ZXJ0ZXhJbnB1dHMubWF0cmljZXNJbmRpY2VzWzNdKV0qdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c1szXTtcbiNlbmRpZiBcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz40XG5pbmZsdWVuY2U9aW5mbHVlbmNlK3VuaWZvcm1zLm1Cb25lc1tpbnQodmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc0V4dHJhWzBdKV0qdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzBdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjVcbmluZmx1ZW5jZT1pbmZsdWVuY2UrdW5pZm9ybXMubUJvbmVzW2ludCh2ZXJ0ZXhJbnB1dHMubWF0cmljZXNJbmRpY2VzRXh0cmFbMV0pXSp2ZXJ0ZXhJbnB1dHMubWF0cmljZXNXZWlnaHRzRXh0cmFbMV07XG4jZW5kaWYgXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+NlxuaW5mbHVlbmNlPWluZmx1ZW5jZSt1bmlmb3Jtcy5tQm9uZXNbaW50KHZlcnRleElucHV0cy5tYXRyaWNlc0luZGljZXNFeHRyYVsyXSldKnZlcnRleElucHV0cy5tYXRyaWNlc1dlaWdodHNFeHRyYVsyXTtcbiNlbmRpZiBcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz43XG5pbmZsdWVuY2U9aW5mbHVlbmNlK3VuaWZvcm1zLm1Cb25lc1tpbnQodmVydGV4SW5wdXRzLm1hdHJpY2VzSW5kaWNlc0V4dHJhWzNdKV0qdmVydGV4SW5wdXRzLm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzNdO1xuI2VuZGlmIFxuI2VuZGlmXG5maW5hbFdvcmxkPWZpbmFsV29ybGQqaW5mbHVlbmNlO1xuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgYm9uZXNWZXJ0ZXhXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvbmVzVmVydGV4LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiYnVtcFZlcnRleFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZiBkZWZpbmVkKEJVTVApIHx8IGRlZmluZWQoUEFSQUxMQVgpIHx8IGRlZmluZWQoQ0xFQVJDT0FUX0JVTVApIHx8IGRlZmluZWQoQU5JU09UUk9QSUMpXG4jaWYgZGVmaW5lZChUQU5HRU5UKSAmJiBkZWZpbmVkKE5PUk1BTClcbnZhciB0Ym5Ob3JtYWw6IHZlYzNmPW5vcm1hbGl6ZShub3JtYWxVcGRhdGVkKTt2YXIgdGJuVGFuZ2VudDogdmVjM2Y9bm9ybWFsaXplKHRhbmdlbnRVcGRhdGVkLnh5eik7dmFyIHRibkJpdGFuZ2VudDogdmVjM2Y9Y3Jvc3ModGJuTm9ybWFsLHRiblRhbmdlbnQpKnRhbmdlbnRVcGRhdGVkLnc7dmFyIG1hdFRlbXA9IG1hdDN4M2YoZmluYWxXb3JsZFswXS54eXosZmluYWxXb3JsZFsxXS54eXosZmluYWxXb3JsZFsyXS54eXopKiBtYXQzeDNmKHRiblRhbmdlbnQsdGJuQml0YW5nZW50LHRibk5vcm1hbCk7dmVydGV4T3V0cHV0cy52VEJOMD1tYXRUZW1wWzBdO3ZlcnRleE91dHB1dHMudlRCTjE9bWF0VGVtcFsxXTt2ZXJ0ZXhPdXRwdXRzLnZUQk4yPW1hdFRlbXBbMl07XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBidW1wVmVydGV4V0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW1wVmVydGV4LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiYnVtcFZlcnRleERlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmIGRlZmluZWQoQlVNUCkgfHwgZGVmaW5lZChQQVJBTExBWCkgfHwgZGVmaW5lZChDTEVBUkNPQVRfQlVNUCkgfHwgZGVmaW5lZChBTklTT1RST1BJQylcbiNpZiBkZWZpbmVkKFRBTkdFTlQpICYmIGRlZmluZWQoTk9STUFMKSBcbnZhcnlpbmcgdlRCTjA6IHZlYzNmO3ZhcnlpbmcgdlRCTjE6IHZlYzNmO3ZhcnlpbmcgdlRCTjI6IHZlYzNmO1xuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgYnVtcFZlcnRleERlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW1wVmVydGV4RGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJjbGlwUGxhbmVWZXJ0ZXhcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgQ0xJUFBMQU5FXG52ZXJ0ZXhPdXRwdXRzLmZDbGlwRGlzdGFuY2U9ZG90KHdvcmxkUG9zLHVuaWZvcm1zLnZDbGlwUGxhbmUpO1xuI2VuZGlmXG4jaWZkZWYgQ0xJUFBMQU5FMlxudmVydGV4T3V0cHV0cy5mQ2xpcERpc3RhbmNlMj1kb3Qod29ybGRQb3MsdW5pZm9ybXMudkNsaXBQbGFuZTIpO1xuI2VuZGlmXG4jaWZkZWYgQ0xJUFBMQU5FM1xudmVydGV4T3V0cHV0cy5mQ2xpcERpc3RhbmNlMz1kb3Qod29ybGRQb3MsdW5pZm9ybXMudkNsaXBQbGFuZTMpO1xuI2VuZGlmXG4jaWZkZWYgQ0xJUFBMQU5FNFxudmVydGV4T3V0cHV0cy5mQ2xpcERpc3RhbmNlND1kb3Qod29ybGRQb3MsdW5pZm9ybXMudkNsaXBQbGFuZTQpO1xuI2VuZGlmXG4jaWZkZWYgQ0xJUFBMQU5FNVxudmVydGV4T3V0cHV0cy5mQ2xpcERpc3RhbmNlNT1kb3Qod29ybGRQb3MsdW5pZm9ybXMudkNsaXBQbGFuZTUpO1xuI2VuZGlmXG4jaWZkZWYgQ0xJUFBMQU5FNlxudmVydGV4T3V0cHV0cy5mQ2xpcERpc3RhbmNlNj1kb3Qod29ybGRQb3MsdW5pZm9ybXMudkNsaXBQbGFuZTYpO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNsaXBQbGFuZVZlcnRleFdHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpcFBsYW5lVmVydGV4LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiY2xpcFBsYW5lVmVydGV4RGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgQ0xJUFBMQU5FXG51bmlmb3JtIHZDbGlwUGxhbmU6IHZlYzQ8ZjMyPjt2YXJ5aW5nIGZDbGlwRGlzdGFuY2U6IGYzMjtcbiNlbmRpZlxuI2lmZGVmIENMSVBQTEFORTJcbnVuaWZvcm0gdkNsaXBQbGFuZTI6IHZlYzQ8ZjMyPjt2YXJ5aW5nIGZDbGlwRGlzdGFuY2UyOiBmMzI7XG4jZW5kaWZcbiNpZmRlZiBDTElQUExBTkUzXG51bmlmb3JtIHZDbGlwUGxhbmUzOiB2ZWM0PGYzMj47dmFyeWluZyBmQ2xpcERpc3RhbmNlMzogZjMyO1xuI2VuZGlmXG4jaWZkZWYgQ0xJUFBMQU5FNFxudW5pZm9ybSB2Q2xpcFBsYW5lNDogdmVjNDxmMzI+O3ZhcnlpbmcgZkNsaXBEaXN0YW5jZTQ6IGYzMjtcbiNlbmRpZlxuI2lmZGVmIENMSVBQTEFORTVcbnVuaWZvcm0gdkNsaXBQbGFuZTU6IHZlYzQ8ZjMyPjt2YXJ5aW5nIGZDbGlwRGlzdGFuY2U1OiBmMzI7XG4jZW5kaWZcbiNpZmRlZiBDTElQUExBTkU2XG51bmlmb3JtIHZDbGlwUGxhbmU2OiB2ZWM0PGYzMj47dmFyeWluZyBmQ2xpcERpc3RhbmNlNjogZjMyO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNsaXBQbGFuZVZlcnRleERlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGlwUGxhbmVWZXJ0ZXhEZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImZvZ1ZlcnRleFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBGT0dcbnZlcnRleE91dHB1dHMudkZvZ0Rpc3RhbmNlPShzY2VuZS52aWV3KndvcmxkUG9zKS54eXo7XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZm9nVmVydGV4V0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2dWZXJ0ZXguanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJmb2dWZXJ0ZXhEZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBGT0dcbnZhcnlpbmcgdkZvZ0Rpc3RhbmNlOiB2ZWMzZjtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBmb2dWZXJ0ZXhEZWNsYXJhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9nVmVydGV4RGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJoZWxwZXJGdW5jdGlvbnNcIjtcbmNvbnN0IHNoYWRlciA9IGBjb25zdCBQSTogZjMyPTMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTtjb25zdCBSRUNJUFJPQ0FMX1BJOiBmMzI9MC4zMTgzMDk4ODYxODM3OTA3O2NvbnN0IFJFQ0lQUk9DQUxfUEkyOiBmMzI9MC4xNTkxNTQ5NDMwOTE4OTUzNTtjb25zdCBIQUxGX01JTjogZjMyPTUuOTYwNDY0NDhlLTA4OyBcbmNvbnN0IExpbmVhckVuY29kZVBvd2VyQXBwcm94OiBmMzI9Mi4yO2NvbnN0IEdhbW1hRW5jb2RlUG93ZXJBcHByb3g6IGYzMj0xLjAvTGluZWFyRW5jb2RlUG93ZXJBcHByb3g7Y29uc3QgTHVtaW5hbmNlRW5jb2RlQXBwcm94OiB2ZWMzPGYzMj49dmVjMzxmMzI+ICgwLjIxMjYsMC43MTUyLDAuMDcyMik7Y29uc3QgRXBzaWxvbjpmMzI9MC4wMDAwMDAxO2ZuIHNxdWFyZSh4OiBmMzIpLT5mMzIge3JldHVybiB4Kng7fVxuZm4gc2F0dXJhdGUoeDogZjMyKS0+ZjMyIHtyZXR1cm4gY2xhbXAoeCwwLjAsMS4wKTt9XG5mbiBzYXR1cmF0ZVZlYzMoeDogdmVjM2YpLT52ZWMzZiB7cmV0dXJuIGNsYW1wKHgsdmVjM2YoMC4wKSx2ZWMzZigxLjApKTt9XG5mbiBzYXR1cmF0ZUVwcyh4OiBmMzIpLT5mMzIge3JldHVybiBjbGFtcCh4LEVwc2lsb24sMS4wKTt9IFxuZm4gbWF4RXBzKHg6IGYzMiktPmYzMiB7cmV0dXJuIG1heCh4LEVwc2lsb24pO31cbmZuIG1heEVwc1ZlYzMoeDogdmVjM2YpLT52ZWMzZiB7cmV0dXJuIG1heCh4LHZlYzNmKEVwc2lsb24pKTt9XG5mbiBhYnNFcHMoeDogZjMyKS0+ZjMyIHtyZXR1cm4gYWJzKHgpK0Vwc2lsb247fVxuZm4gdHJhbnNwb3NlTWF0Myhpbk1hdHJpeDogbWF0M3gzZiktPm1hdDN4M2Yge2xldCBpMDogdmVjMzxmMzI+PWluTWF0cml4WzBdO2xldCBpMTogdmVjMzxmMzI+PWluTWF0cml4WzFdO2xldCBpMjogdmVjMzxmMzI+PWluTWF0cml4WzJdO2xldCBvdXRNYXRyaXg6bWF0M3gzZj1tYXQzeDNmKFxudmVjMyhpMC54LGkxLngsaTIueCksXG52ZWMzKGkwLnksaTEueSxpMi55KSxcbnZlYzMoaTAueixpMS56LGkyLnopXG4pO3JldHVybiBvdXRNYXRyaXg7fVxuZm4gaW52ZXJzZU1hdDMoaW5NYXRyaXg6IG1hdDN4M2YpLT5tYXQzeDNmIHtsZXQgYTAwOiBmMzI9aW5NYXRyaXhbMF1bMF07bGV0IGEwMTogZjMyPWluTWF0cml4WzBdWzFdO2xldCBhMDI6IGYzMj1pbk1hdHJpeFswXVsyXTtsZXQgYTEwOiBmMzI9aW5NYXRyaXhbMV1bMF07bGV0IGExMTogZjMyPWluTWF0cml4WzFdWzFdO2xldCBhMTI6IGYzMj1pbk1hdHJpeFsxXVsyXTtsZXQgYTIwOiBmMzI9aW5NYXRyaXhbMl1bMF07bGV0IGEyMTogZjMyPWluTWF0cml4WzJdWzFdO2xldCBhMjI6IGYzMj1pbk1hdHJpeFsyXVsyXTtsZXQgYjAxOiBmMzI9YTIyKmExMS1hMTIqYTIxO2xldCBiMTE6IGYzMj0tYTIyKmExMCthMTIqYTIwO2xldCBiMjE6IGYzMj1hMjEqYTEwLWExMSphMjA7bGV0IGRldDogZjMyPWEwMCpiMDErYTAxKmIxMSthMDIqYjIxO3JldHVybiBtYXQzeDNmKGIwMS9kZXQsKC1hMjIqYTAxK2EwMiphMjEpL2RldCwoYTEyKmEwMS1hMDIqYTExKS9kZXQsXG5iMTEvZGV0LChhMjIqYTAwLWEwMiphMjApL2RldCwoLWExMiphMDArYTAyKmExMCkvZGV0LFxuYjIxL2RldCwoLWEyMSphMDArYTAxKmEyMCkvZGV0LChhMTEqYTAwLWEwMSphMTApL2RldCk7fVxuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5mbiB0b0xpbmVhclNwYWNlRXhhY3QoY29sb3I6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue2xldCBuZWFyWmVyb1NlY3Rpb246IHZlYzM8ZjMyPj0wLjA3NzM5OTM4MDgqY29sb3I7bGV0IHJlbWFpbmluZ1NlY3Rpb246IHZlYzM8ZjMyPj1wb3coMC45NDc4NjcyOTkqKGNvbG9yK3ZlYzM8ZjMyPigwLjA1NSkpLHZlYzM8ZjMyPigyLjQpKTtyZXR1cm4gbWl4KHJlbWFpbmluZ1NlY3Rpb24sbmVhclplcm9TZWN0aW9uLGxlc3NUaGFuRXF1YWwoY29sb3IsdmVjMzxmMzI+KDAuMDQwNDUpKSk7fVxuZm4gdG9HYW1tYVNwYWNlRXhhY3QoY29sb3I6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue2xldCBuZWFyWmVyb1NlY3Rpb246IHZlYzM8ZjMyPj0xMi45Mipjb2xvcjtsZXQgcmVtYWluaW5nU2VjdGlvbjogdmVjMzxmMzI+PTEuMDU1KnBvdyhjb2xvcix2ZWMzPGYzMj4oMC40MTY2NikpLXZlYzM8ZjMyPigwLjA1NSk7cmV0dXJuIG1peChyZW1haW5pbmdTZWN0aW9uLG5lYXJaZXJvU2VjdGlvbixsZXNzVGhhbkVxdWFsKGNvbG9yLHZlYzM8ZjMyPigwLjAwMzEzMDgpKSk7fVxuI2VuZGlmXG5mbiB0b0xpbmVhclNwYWNlKGNvbG9yOiBmMzIpLT5mMzJcbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xudmFyIG5lYXJaZXJvU2VjdGlvbj0wLjA3NzM5OTM4MDgqY29sb3I7dmFyIHJlbWFpbmluZ1NlY3Rpb249cG93KDAuOTQ3ODY3Mjk5Kihjb2xvciswLjA1NSksMi40KTtyZXR1cm4gc2VsZWN0KHJlbWFpbmluZ1NlY3Rpb24sbmVhclplcm9TZWN0aW9uLGNvbG9yPD0wLjA0MDQ1KTtcbiNlbHNlXG5yZXR1cm4gcG93KGNvbG9yLExpbmVhckVuY29kZVBvd2VyQXBwcm94KTtcbiNlbmRpZlxufVxuZm4gdG9MaW5lYXJTcGFjZVZlYzMoY29sb3I6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdG9MaW5lYXJTcGFjZUV4YWN0KGNvbG9yKTtcbiNlbHNlXG5yZXR1cm4gcG93KGNvbG9yLHZlYzM8ZjMyPihMaW5lYXJFbmNvZGVQb3dlckFwcHJveCkpO1xuI2VuZGlmXG59XG5mbiB0b0xpbmVhclNwYWNlVmVjNChjb2xvcjogdmVjNDxmMzI+KS0+dmVjNDxmMzI+XG57XG4jaWYgVVNFX0VYQUNUX1NSR0JfQ09OVkVSU0lPTlNcbnJldHVybiB2ZWM0Zih0b0xpbmVhclNwYWNlRXhhY3QoY29sb3IucmdiKSxjb2xvci5hKTtcbiNlbHNlXG5yZXR1cm4gdmVjNGYocG93KGNvbG9yLnJnYix2ZWMzZihMaW5lYXJFbmNvZGVQb3dlckFwcHJveCkpLGNvbG9yLmEpO1xuI2VuZGlmXG59XG5mbiB0b0dhbW1hU3BhY2UoY29sb3I6IHZlYzQ8ZjMyPiktPnZlYzQ8ZjMyPlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdmVjNDxmMzI+KHRvR2FtbWFTcGFjZUV4YWN0KGNvbG9yLnJnYiksY29sb3IuYSk7XG4jZWxzZVxucmV0dXJuIHZlYzQ8ZjMyPihwb3coY29sb3IucmdiLHZlYzM8ZjMyPihHYW1tYUVuY29kZVBvd2VyQXBwcm94KSksY29sb3IuYSk7XG4jZW5kaWZcbn1cbmZuIHRvR2FtbWFTcGFjZVZlYzMoY29sb3I6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdG9HYW1tYVNwYWNlRXhhY3QoY29sb3IpO1xuI2Vsc2VcbnJldHVybiBwb3coY29sb3IsdmVjMzxmMzI+KEdhbW1hRW5jb2RlUG93ZXJBcHByb3gpKTtcbiNlbmRpZlxufVxuZm4gc3F1YXJlVmVjMyh2YWx1ZTogdmVjMzxmMzI+KS0+dmVjMzxmMzI+XG57cmV0dXJuIHZhbHVlKnZhbHVlO31cbmZuIHBvdzUodmFsdWU6IGYzMiktPmYzMiB7bGV0IHNxOiBmMzI9dmFsdWUqdmFsdWU7cmV0dXJuIHNxKnNxKnZhbHVlO31cbmZuIGdldEx1bWluYW5jZShjb2xvcjogdmVjMzxmMzI+KS0+ZjMyXG57cmV0dXJuIGNsYW1wKGRvdChjb2xvcixMdW1pbmFuY2VFbmNvZGVBcHByb3gpLDAuLDEuKTt9XG5mbiBnZXRSYW5kKHNlZWQ6IHZlYzI8ZjMyPiktPmYzMiB7cmV0dXJuIGZyYWN0KHNpbihkb3Qoc2VlZC54eSAsdmVjMjxmMzI+KDEyLjk4OTgsNzguMjMzKSkpKjQzNzU4LjU0NTMpO31cbmZuIGRpdGhlcihzZWVkOiB2ZWMyPGYzMj4sdmFyaWFuY2VBbW91bnQ6IGYzMiktPmYzMiB7bGV0IHJhbmQ6IGYzMj1nZXRSYW5kKHNlZWQpO2xldCBub3JtVmFyaWFuY2U6IGYzMj12YXJpYW5jZUFtb3VudC8yNTUuMDtsZXQgZGl0aGVyOiBmMzI9bWl4KC1ub3JtVmFyaWFuY2Usbm9ybVZhcmlhbmNlLHJhbmQpO3JldHVybiBkaXRoZXI7fVxuY29uc3QgcmdiZE1heFJhbmdlOiBmMzI9MjU1LjA7Zm4gdG9SR0JEKGNvbG9yOiB2ZWMzPGYzMj4pLT52ZWM0PGYzMj4ge2xldCBtYXhSR0I6IGYzMj1tYXgobWF4KGNvbG9yLnIsbWF4KGNvbG9yLmcsY29sb3IuYikpLEVwc2lsb24pO3ZhciBEOiBmMzIgPW1heChyZ2JkTWF4UmFuZ2UvbWF4UkdCLDEuKTtEID1jbGFtcChmbG9vcihEKS8yNTUuMCwwLiwxLik7dmFyIHJnYjogdmVjMzxmMzI+ID1jb2xvci5yZ2IqRDtyZ2I9dG9HYW1tYVNwYWNlVmVjMyhyZ2IpO3JldHVybiB2ZWM0PGYzMj4oY2xhbXAocmdiLHZlYzM8ZjMyPigwLiwwLiwwLiksdmVjMzxmMzI+KDEuLDEuLDEuKSksRCk7IH1cbmZuIGZyb21SR0JEKHJnYmQ6IHZlYzQ8ZjMyPiktPnZlYzM8ZjMyPiB7bGV0IHJnYj10b0xpbmVhclNwYWNlVmVjMyhyZ2JkLnJnYik7cmV0dXJuIHJnYi9yZ2JkLmE7fVxuZm4gcGFyYWxsYXhDb3JyZWN0Tm9ybWFsKHZlcnRleFBvczogdmVjMzxmMzI+LG9yaWdWZWM6IHZlYzM8ZjMyPixjdWJlU2l6ZTogdmVjMzxmMzI+LGN1YmVQb3M6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPiB7bGV0IGludk9yaWdWZWM6IHZlYzM8ZjMyPj12ZWMzPGYzMj4oMS4wLDEuMCwxLjApL29yaWdWZWM7bGV0IGhhbGZTaXplOiB2ZWMzPGYzMj49Y3ViZVNpemUqMC41O2xldCBpbnRlcnNlY0F0TWF4UGxhbmU6IHZlYzM8ZjMyPj0oY3ViZVBvcytoYWxmU2l6ZS12ZXJ0ZXhQb3MpKmludk9yaWdWZWM7bGV0IGludGVyc2VjQXRNaW5QbGFuZTogdmVjMzxmMzI+PShjdWJlUG9zLWhhbGZTaXplLXZlcnRleFBvcykqaW52T3JpZ1ZlYztsZXQgbGFyZ2VzdEludGVyc2VjOiB2ZWMzPGYzMj49bWF4KGludGVyc2VjQXRNYXhQbGFuZSxpbnRlcnNlY0F0TWluUGxhbmUpO2xldCBkaXN0YW5jZTogZjMyPW1pbihtaW4obGFyZ2VzdEludGVyc2VjLngsbGFyZ2VzdEludGVyc2VjLnkpLGxhcmdlc3RJbnRlcnNlYy56KTtsZXQgaW50ZXJzZWN0UG9zaXRpb25XUzogdmVjMzxmMzI+PXZlcnRleFBvcytvcmlnVmVjKmRpc3RhbmNlO3JldHVybiBpbnRlcnNlY3RQb3NpdGlvbldTLWN1YmVQb3M7fVxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBoZWxwZXJGdW5jdGlvbnNXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlckZ1bmN0aW9ucy5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImluc3RhbmNlc0RlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIElOU1RBTkNFU1xuYXR0cmlidXRlIHdvcmxkMCA6IHZlYzQ8ZjMyPjthdHRyaWJ1dGUgd29ybGQxIDogdmVjNDxmMzI+O2F0dHJpYnV0ZSB3b3JsZDIgOiB2ZWM0PGYzMj47YXR0cmlidXRlIHdvcmxkMyA6IHZlYzQ8ZjMyPjtcbiNpZmRlZiBJTlNUQU5DRVNDT0xPUlxuYXR0cmlidXRlIGluc3RhbmNlQ29sb3IgOiB2ZWM0PGYzMj47XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFRISU5fSU5TVEFOQ0VTKSAmJiAhZGVmaW5lZChXT1JMRF9VQk8pXG51bmlmb3JtIHdvcmxkIDogbWF0NHg0PGYzMj47XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFZFTE9DSVRZKSB8fCBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpXG5hdHRyaWJ1dGUgcHJldmlvdXNXb3JsZDAgOiB2ZWM0PGYzMj47YXR0cmlidXRlIHByZXZpb3VzV29ybGQxIDogdmVjNDxmMzI+O2F0dHJpYnV0ZSBwcmV2aW91c1dvcmxkMiA6IHZlYzQ8ZjMyPjthdHRyaWJ1dGUgcHJldmlvdXNXb3JsZDMgOiB2ZWM0PGYzMj47XG4jaWZkZWYgVEhJTl9JTlNUQU5DRVNcbnVuaWZvcm0gcHJldmlvdXNXb3JsZCA6IG1hdDR4NDxmMzI+O1xuI2VuZGlmXG4jZW5kaWZcbiNlbHNlXG4jaWYgIWRlZmluZWQoV09STERfVUJPKVxudW5pZm9ybSB3b3JsZCA6IG1hdDR4NDxmMzI+O1xuI2VuZGlmXG4jaWYgZGVmaW5lZChWRUxPQ0lUWSkgfHwgZGVmaW5lZChQUkVQQVNTX1ZFTE9DSVRZKVxudW5pZm9ybSBwcmV2aW91c1dvcmxkIDogbWF0NHg0PGYzMj47XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpbnN0YW5jZXNEZWNsYXJhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdGFuY2VzRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJpbnN0YW5jZXNWZXJ0ZXhcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgSU5TVEFOQ0VTXG52YXIgZmluYWxXb3JsZD1tYXQ0eDQ8ZjMyPih2ZXJ0ZXhJbnB1dHMud29ybGQwLHZlcnRleElucHV0cy53b3JsZDEsdmVydGV4SW5wdXRzLndvcmxkMix2ZXJ0ZXhJbnB1dHMud29ybGQzKTtcbiNpZiBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpIHx8IGRlZmluZWQoVkVMT0NJVFkpXG52YXIgZmluYWxQcmV2aW91c1dvcmxkPW1hdDR4NDxmMzI+KHZlcnRleElucHV0cy5wcmV2aW91c1dvcmxkMCx2ZXJ0ZXhJbnB1dHMucHJldmlvdXNXb3JsZDEsdmVydGV4SW5wdXRzLnByZXZpb3VzV29ybGQyLHZlcnRleElucHV0cy5wcmV2aW91c1dvcmxkMyk7XG4jZW5kaWZcbiNpZmRlZiBUSElOX0lOU1RBTkNFU1xuI2lmICFkZWZpbmVkKFdPUkxEX1VCTylcbmZpbmFsV29ybGQ9dW5pZm9ybXMud29ybGQqZmluYWxXb3JsZDtcbiNlbHNlXG5maW5hbFdvcmxkPW1lc2gud29ybGQqZmluYWxXb3JsZDtcbiNlbmRpZlxuI2lmIGRlZmluZWQoUFJFUEFTU19WRUxPQ0lUWSkgfHwgZGVmaW5lZChWRUxPQ0lUWSlcbmZpbmFsUHJldmlvdXNXb3JsZD11bmlmb3Jtcy5wcmV2aW91c1dvcmxkKmZpbmFsUHJldmlvdXNXb3JsZDtcbiNlbmRpZlxuI2VuZGlmXG4jZWxzZVxuI2lmICFkZWZpbmVkKFdPUkxEX1VCTylcbnZhciBmaW5hbFdvcmxkPXVuaWZvcm1zLndvcmxkO1xuI2Vsc2VcbnZhciBmaW5hbFdvcmxkPW1lc2gud29ybGQ7XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpIHx8IGRlZmluZWQoVkVMT0NJVFkpXG52YXIgZmluYWxQcmV2aW91c1dvcmxkPXVuaWZvcm1zLnByZXZpb3VzV29ybGQ7XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpbnN0YW5jZXNWZXJ0ZXhXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RhbmNlc1ZlcnRleC5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImxpZ2h0VnhVYm9EZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBMSUdIVHtYfVxuc3RydWN0IExpZ2h0e1h9XG57dkxpZ2h0RGF0YTogdmVjNGYsXG52TGlnaHREaWZmdXNlOiB2ZWM0ZixcbnZMaWdodFNwZWN1bGFyOiB2ZWM0ZixcbiNpZmRlZiBTUE9UTElHSFR7WH1cbnZMaWdodERpcmVjdGlvbjogdmVjNGYsXG52TGlnaHRGYWxsb2ZmOiB2ZWM0ZixcbiNlbGlmIGRlZmluZWQoUE9JTlRMSUdIVHtYfSlcbnZMaWdodEZhbGxvZmY6IHZlYzRmLFxuI2VsaWYgZGVmaW5lZChIRU1JTElHSFR7WH0pXG52TGlnaHRHcm91bmQ6IHZlYzNmLFxuI2VuZGlmXG5zaGFkb3dzSW5mbzogdmVjNGYsXG5kZXB0aFZhbHVlczogdmVjMmZ9IDt2YXI8dW5pZm9ybT4gbGlnaHR7WH0gOiBMaWdodHtYfTtcbiNpZmRlZiBTSEFET1d7WH1cbiNpZmRlZiBTSEFET1dDU017WH1cbnVuaWZvcm0gbGlnaHRNYXRyaXh7WH06IGFycmF5PG1hdDR4NGYsU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9Pjt2YXJ5aW5nIHZQb3NpdGlvbkZyb21MaWdodHtYfV8wOiB2ZWM0Zjt2YXJ5aW5nIHZEZXB0aE1ldHJpY3tYfV8wOiBmMzI7dmFyeWluZyB2UG9zaXRpb25Gcm9tTGlnaHR7WH1fMTogdmVjNGY7dmFyeWluZyB2RGVwdGhNZXRyaWN7WH1fMTogZjMyO3ZhcnlpbmcgdlBvc2l0aW9uRnJvbUxpZ2h0e1h9XzI6IHZlYzRmO3ZhcnlpbmcgdkRlcHRoTWV0cmlje1h9XzI6IGYzMjt2YXJ5aW5nIHZQb3NpdGlvbkZyb21MaWdodHtYfV8zOiB2ZWM0Zjt2YXJ5aW5nIHZEZXB0aE1ldHJpY3tYfV8zOiBmMzI7dmFyeWluZyB2UG9zaXRpb25Gcm9tQ2FtZXJhe1h9OiB2ZWM0ZjtcbiNlbGlmIGRlZmluZWQoU0hBRE9XQ1VCRXtYfSlcbiNlbHNlXG52YXJ5aW5nIHZQb3NpdGlvbkZyb21MaWdodHtYfTogdmVjNGY7dmFyeWluZyB2RGVwdGhNZXRyaWN7WH06IGYzMjt1bmlmb3JtIGxpZ2h0TWF0cml4e1h9OiBtYXQ0eDRmO1xuI2VuZGlmXG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBsaWdodFZ4VWJvRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZ2h0VnhVYm9EZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImxvZ0RlcHRoRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTE9HQVJJVEhNSUNERVBUSFxudW5pZm9ybSBsb2dhcml0aG1pY0RlcHRoQ29uc3RhbnQ6IGYzMjt2YXJ5aW5nIHZGcmFnbWVudERlcHRoOiBmMzI7XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbG9nRGVwdGhEZWNsYXJhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nRGVwdGhEZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImxvZ0RlcHRoVmVydGV4XCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIExPR0FSSVRITUlDREVQVEhcbnZlcnRleE91dHB1dHMudkZyYWdtZW50RGVwdGg9MS4wK3ZlcnRleE91dHB1dHMucG9zaXRpb24udzt2ZXJ0ZXhPdXRwdXRzLnBvc2l0aW9uLno9bG9nMihtYXgoMC4wMDAwMDEsdmVydGV4T3V0cHV0cy52RnJhZ21lbnREZXB0aCkpKnVuaWZvcm1zLmxvZ2FyaXRobWljRGVwdGhDb25zdGFudDtcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBsb2dEZXB0aFZlcnRleFdHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nRGVwdGhWZXJ0ZXguanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJtYWluVVZWYXJ5aW5nRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTUFJTlVWe1h9XG52YXJ5aW5nIHZNYWluVVZ7WH06IHZlYzJmO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG1haW5VVlZhcnlpbmdEZWNsYXJhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpblVWVmFyeWluZ0RlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibWVzaFVib0RlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgc3RydWN0IE1lc2gge3dvcmxkIDogbWF0NHg0PGYzMj4sXG52aXNpYmlsaXR5IDogZjMyLH07dmFyPHVuaWZvcm0+IG1lc2ggOiBNZXNoO1xuI2RlZmluZSBXT1JMRF9VQk9cbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbWVzaFVib0RlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNoVWJvRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJtb3JwaFRhcmdldHNWZXJ0ZXhcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTU9SUEhUQVJHRVRTXG4jaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkVcbiNpZiB7WH09PTBcbmZvciAodmFyIGk9MDsgaTxOVU1fTU9SUEhfSU5GTFVFTkNFUlM7IGk9aSsxKSB7aWYgKGk+PXVuaWZvcm1zLm1vcnBoVGFyZ2V0Q291bnQpIHticmVhazt9XG52ZXJ0ZXhJRD1mMzIodmVydGV4SW5wdXRzLnZlcnRleEluZGV4KSp1bmlmb3Jtcy5tb3JwaFRhcmdldFRleHR1cmVJbmZvLng7cG9zaXRpb25VcGRhdGVkPXBvc2l0aW9uVXBkYXRlZCsocmVhZFZlY3RvcjNGcm9tUmF3U2FtcGxlcihpLHZlcnRleElEKS12ZXJ0ZXhJbnB1dHMucG9zaXRpb24pKnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXTt2ZXJ0ZXhJRD12ZXJ0ZXhJRCsxLjA7XG4jaWZkZWYgTU9SUEhUQVJHRVRTX05PUk1BTFxubm9ybWFsVXBkYXRlZD1ub3JtYWxVcGRhdGVkKyhyZWFkVmVjdG9yM0Zyb21SYXdTYW1wbGVyKGksdmVydGV4SUQpIC12ZXJ0ZXhJbnB1dHMubm9ybWFsKSp1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV07dmVydGV4SUQ9dmVydGV4SUQrMS4wO1xuI2VuZGlmXG4jaWZkZWYgTU9SUEhUQVJHRVRTX1VWXG51dlVwZGF0ZWQ9dXZVcGRhdGVkKyhyZWFkVmVjdG9yM0Zyb21SYXdTYW1wbGVyKGksdmVydGV4SUQpLnh5LXZlcnRleElucHV0cy51dikqdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldO3ZlcnRleElEPXZlcnRleElEKzEuMDtcbiNlbmRpZlxuI2lmZGVmIE1PUlBIVEFSR0VUU19UQU5HRU5UXG50YW5nZW50VXBkYXRlZD12ZWM0Zih0YW5nZW50VXBkYXRlZC54eXorKHJlYWRWZWN0b3IzRnJvbVJhd1NhbXBsZXIoaSx2ZXJ0ZXhJRCkgLXZlcnRleElucHV0cy50YW5nZW50Lnh5eikqdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldLHRhbmdlbnRVcGRhdGVkLmEpO1xuI2VuZGlmXG59XG4jZW5kaWZcbiNlbHNlXG5wb3NpdGlvblVwZGF0ZWQ9cG9zaXRpb25VcGRhdGVkKyh2ZXJ0ZXhJbnB1dHMucG9zaXRpb257WH0tdmVydGV4SW5wdXRzLnBvc2l0aW9uKSp1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbe1h9XTtcbiNpZmRlZiBNT1JQSFRBUkdFVFNfTk9STUFMXG5ub3JtYWxVcGRhdGVkKz0odmVydGV4SW5wdXRzLm5vcm1hbHtYfS12ZXJ0ZXhJbnB1dHMubm9ybWFsKSp1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbe1h9XTtcbiNlbmRpZlxuI2lmZGVmIE1PUlBIVEFSR0VUU19UQU5HRU5UXG50YW5nZW50VXBkYXRlZC54eXo9dGFuZ2VudFVwZGF0ZWQueHl6Kyh2ZXJ0ZXhJbnB1dHMudGFuZ2VudHtYfS12ZXJ0ZXhJbnB1dHMudGFuZ2VudC54eXopKnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t7WH1dO1xuI2VuZGlmXG4jaWZkZWYgTU9SUEhUQVJHRVRTX1VWXG51dlVwZGF0ZWQ9dXZVcGRhdGVkKyh2ZXJ0ZXhJbnB1dHMudXZfe1h9LXZlcnRleElucHV0cy51dikqdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW3tYfV07XG4jZW5kaWZcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG1vcnBoVGFyZ2V0c1ZlcnRleFdHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ycGhUYXJnZXRzVmVydGV4LmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwibW9ycGhUYXJnZXRzVmVydGV4RGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTU9SUEhUQVJHRVRTXG4jaWZuZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXG5hdHRyaWJ1dGUgcG9zaXRpb257WH0gOiB2ZWMzPGYzMj47XG4jaWZkZWYgTU9SUEhUQVJHRVRTX05PUk1BTFxuYXR0cmlidXRlIG5vcm1hbHtYfSA6IHZlYzM8ZjMyPjtcbiNlbmRpZlxuI2lmZGVmIE1PUlBIVEFSR0VUU19UQU5HRU5UXG5hdHRyaWJ1dGUgdGFuZ2VudHtYfSA6IHZlYzM8ZjMyPjtcbiNlbmRpZlxuI2lmZGVmIE1PUlBIVEFSR0VUU19VVlxuYXR0cmlidXRlIHV2X3tYfSA6IHZlYzI8ZjMyPjtcbiNlbmRpZlxuI2VsaWYge1h9PT0wXG51bmlmb3JtIG1vcnBoVGFyZ2V0Q291bnQ6IGkzMjtcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG1vcnBoVGFyZ2V0c1ZlcnRleERlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3JwaFRhcmdldHNWZXJ0ZXhEZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcIm1vcnBoVGFyZ2V0c1ZlcnRleEdsb2JhbFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBNT1JQSFRBUkdFVFNcbiNpZmRlZiBNT1JQSFRBUkdFVFNfVEVYVFVSRVxudmFyIHZlcnRleElEIDogZjMyO1xuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbW9ycGhUYXJnZXRzVmVydGV4R2xvYmFsV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3JwaFRhcmdldHNWZXJ0ZXhHbG9iYWwuanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJtb3JwaFRhcmdldHNWZXJ0ZXhHbG9iYWxEZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBNT1JQSFRBUkdFVFNcbnVuaWZvcm0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIDogYXJyYXk8ZjMyLE5VTV9NT1JQSF9JTkZMVUVOQ0VSUz47XG4jaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkUgXG51bmlmb3JtIG1vcnBoVGFyZ2V0VGV4dHVyZUluZGljZXMgOiBhcnJheTxmMzIsTlVNX01PUlBIX0lORkxVRU5DRVJTPjt1bmlmb3JtIG1vcnBoVGFyZ2V0VGV4dHVyZUluZm8gOiB2ZWMzPGYzMj47dmFyIG1vcnBoVGFyZ2V0cyA6IHRleHR1cmVfMmRfYXJyYXk8ZjMyPjt2YXIgbW9ycGhUYXJnZXRzU2FtcGxlciA6IHNhbXBsZXI7Zm4gcmVhZFZlY3RvcjNGcm9tUmF3U2FtcGxlcih0YXJnZXRJbmRleCA6IGkzMix2ZXJ0ZXhJbmRleCA6IGYzMiktPnZlYzM8ZjMyPlxueyBcbmxldCB5PWZsb29yKHZlcnRleEluZGV4L3VuaWZvcm1zLm1vcnBoVGFyZ2V0VGV4dHVyZUluZm8ueSk7bGV0IHg9dmVydGV4SW5kZXgteSp1bmlmb3Jtcy5tb3JwaFRhcmdldFRleHR1cmVJbmZvLnk7bGV0IHRleHR1cmVVVj12ZWMyPGYzMj4oKHgrMC41KS91bmlmb3Jtcy5tb3JwaFRhcmdldFRleHR1cmVJbmZvLnksKHkrMC41KS91bmlmb3Jtcy5tb3JwaFRhcmdldFRleHR1cmVJbmZvLnopO3JldHVybiB0ZXh0dXJlU2FtcGxlTGV2ZWwobW9ycGhUYXJnZXRzLG1vcnBoVGFyZ2V0c1NhbXBsZXIsdGV4dHVyZVVWLGkzMih1bmlmb3Jtcy5tb3JwaFRhcmdldFRleHR1cmVJbmRpY2VzW3RhcmdldEluZGV4XSksMC4wKS54eXo7fVxuI2VuZGlmXG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbW9ycGhUYXJnZXRzVmVydGV4R2xvYmFsRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vcnBoVGFyZ2V0c1ZlcnRleEdsb2JhbERlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwicHJlUGFzc1ZlcnRleFwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZmRlZiBQUkVQQVNTX0RFUFRIXG52ZXJ0ZXhPdXRwdXRzLnZWaWV3UG9zPShzY2VuZS52aWV3KndvcmxkUG9zKS5yZ2I7XG4jZW5kaWZcbiNpZiBkZWZpbmVkKFBSRVBBU1NfVkVMT0NJVFkpICYmIGRlZmluZWQoQk9ORVNfVkVMT0NJVFlfRU5BQkxFRClcbnZlcnRleE91dHB1dHMudkN1cnJlbnRQb3NpdGlvbj1zY2VuZS52aWV3UHJvamVjdGlvbip3b3JsZFBvcztcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz4wXG52YXIgcHJldmlvdXNJbmZsdWVuY2U6IG1hdDR4NGY7cHJldmlvdXNJbmZsdWVuY2U9bVByZXZpb3VzQm9uZXNbIGkzMihtYXRyaWNlc0luZGljZXNbMF0pXSptYXRyaWNlc1dlaWdodHNbMF07XG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+MVxucHJldmlvdXNJbmZsdWVuY2UrPW1QcmV2aW91c0JvbmVzWyBpMzIobWF0cmljZXNJbmRpY2VzWzFdKV0qbWF0cmljZXNXZWlnaHRzWzFdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjJcbnByZXZpb3VzSW5mbHVlbmNlKz1tUHJldmlvdXNCb25lc1sgaTMyKG1hdHJpY2VzSW5kaWNlc1syXSldKm1hdHJpY2VzV2VpZ2h0c1syXTtcbiNlbmRpZiBcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz4zXG5wcmV2aW91c0luZmx1ZW5jZSs9bVByZXZpb3VzQm9uZXNbIGkzMihtYXRyaWNlc0luZGljZXNbM10pXSptYXRyaWNlc1dlaWdodHNbM107XG4jZW5kaWZcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz40XG5wcmV2aW91c0luZmx1ZW5jZSs9bVByZXZpb3VzQm9uZXNbIGkzMihtYXRyaWNlc0luZGljZXNFeHRyYVswXSldKm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzBdO1xuI2VuZGlmIFxuI2lmIE5VTV9CT05FX0lORkxVRU5DRVJTPjVcbnByZXZpb3VzSW5mbHVlbmNlKz1tUHJldmlvdXNCb25lc1sgaTMyKG1hdHJpY2VzSW5kaWNlc0V4dHJhWzFdKV0qbWF0cmljZXNXZWlnaHRzRXh0cmFbMV07XG4jZW5kaWYgXG4jaWYgTlVNX0JPTkVfSU5GTFVFTkNFUlM+NlxucHJldmlvdXNJbmZsdWVuY2UrPW1QcmV2aW91c0JvbmVzWyBpMzIobWF0cmljZXNJbmRpY2VzRXh0cmFbMl0pXSptYXRyaWNlc1dlaWdodHNFeHRyYVsyXTtcbiNlbmRpZiBcbiNpZiBOVU1fQk9ORV9JTkZMVUVOQ0VSUz43XG5wcmV2aW91c0luZmx1ZW5jZSs9bVByZXZpb3VzQm9uZXNbIGkzMihtYXRyaWNlc0luZGljZXNFeHRyYVszXSldKm1hdHJpY2VzV2VpZ2h0c0V4dHJhWzNdO1xuI2VuZGlmXG52ZXJ0ZXhPdXRwdXRzLnZQcmV2aW91c1Bvc2l0aW9uPXVuaWZvcm1zLnByZXZpb3VzVmlld1Byb2plY3Rpb24qZmluYWxQcmV2aW91c1dvcmxkKnByZXZpb3VzSW5mbHVlbmNlKiB2ZWM0Zihwb3NpdGlvblVwZGF0ZWQsMS4wKTtcbiNlbHNlXG52ZXJ0ZXhPdXRwdXRzLnZQcmV2aW91c1Bvc2l0aW9uPXVuaWZvcm1zLnByZXZpb3VzVmlld1Byb2plY3Rpb24qZmluYWxQcmV2aW91c1dvcmxkKiB2ZWM0Zihwb3NpdGlvblVwZGF0ZWQsMS4wKTtcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHByZVBhc3NWZXJ0ZXhXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZVBhc3NWZXJ0ZXguanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJwcmVQYXNzVmVydGV4RGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgUFJFUEFTU1xuI2lmZGVmIFBSRVBBU1NfREVQVEhcbnZhcnlpbmcgdlZpZXdQb3M6IHZlYzNmO1xuI2VuZGlmXG4jaWZkZWYgUFJFUEFTU19WRUxPQ0lUWVxudW5pZm9ybSBwcmV2aW91c1ZpZXdQcm9qZWN0aW9uOiBtYXQ0eDRmO3ZhcnlpbmcgdkN1cnJlbnRQb3NpdGlvbjogdmVjNGY7dmFyeWluZyB2UHJldmlvdXNQb3NpdGlvbjogdmVjNGY7XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwcmVQYXNzVmVydGV4RGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZVBhc3NWZXJ0ZXhEZWNsYXJhdGlvbi5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcInNhbXBsZXJWZXJ0ZXhEZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYCNpZiBkZWZpbmVkKF9ERUZJTkVOQU1FXykgJiYgX0RFRklORU5BTUVfRElSRUNUVVY9PTBcbnZhcnlpbmcgdl9WQVJZSU5HTkFNRV9VVjogdmVjMmY7XG4jZW5kaWZcbmA7XG4vLyBTaWRlZWZmZWN0XG5TaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3Qgc2FtcGxlclZlcnRleERlY2xhcmF0aW9uV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGVyVmVydGV4RGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJzYW1wbGVyVmVydGV4SW1wbGVtZW50YXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWYgZGVmaW5lZChfREVGSU5FTkFNRV8pICYmIF9ERUZJTkVOQU1FX0RJUkVDVFVWPT0wXG5pZiAodW5pZm9ybXMudl9JTkZPTkFNRV89PTAuKVxue3ZlcnRleE91dHB1dHMudl9WQVJZSU5HTkFNRV9VVj0gKHVuaWZvcm1zLl9NQVRSSVhOQU1FX01hdHJpeCogdmVjNGYodXZVcGRhdGVkLDEuMCwwLjApKS54eTt9XG4jaWZkZWYgVVYyXG5lbHNlIGlmICh1bmlmb3Jtcy52X0lORk9OQU1FXz09MS4pXG57dmVydGV4T3V0cHV0cy52X1ZBUllJTkdOQU1FX1VWPSAodW5pZm9ybXMuX01BVFJJWE5BTUVfTWF0cml4KiB2ZWM0Zih2ZXJ0ZXhJbnB1dHMudXYyLDEuMCwwLjApKS54eTt9XG4jZW5kaWZcbiNpZmRlZiBVVjNcbmVsc2UgaWYgKHVuaWZvcm1zLnZfSU5GT05BTUVfPT0yLilcbnt2ZXJ0ZXhPdXRwdXRzLnZfVkFSWUlOR05BTUVfVVY9ICh1bmlmb3Jtcy5fTUFUUklYTkFNRV9NYXRyaXgqIHZlYzRmKHZlcnRleElucHV0cy51djMsMS4wLDAuMCkpLnh5O31cbiNlbmRpZlxuI2lmZGVmIFVWNFxuZWxzZSBpZiAodW5pZm9ybXMudl9JTkZPTkFNRV89PTMuKVxue3ZlcnRleE91dHB1dHMudl9WQVJZSU5HTkFNRV9VVj0gKHVuaWZvcm1zLl9NQVRSSVhOQU1FX01hdHJpeCogdmVjNGYodmVydGV4SW5wdXRzLnV2NCwxLjAsMC4wKSkueHk7fVxuI2VuZGlmXG4jaWZkZWYgVVY1XG5lbHNlIGlmICh1bmlmb3Jtcy52X0lORk9OQU1FXz09NC4pXG57dmVydGV4T3V0cHV0cy52X1ZBUllJTkdOQU1FX1VWPSAodW5pZm9ybXMuX01BVFJJWE5BTUVfTWF0cml4KiB2ZWM0Zih2ZXJ0ZXhJbnB1dHMudXY1LDEuMCwwLjApKS54eTt9XG4jZW5kaWZcbiNpZmRlZiBVVjZcbmVsc2UgaWYgKHVuaWZvcm1zLnZfSU5GT05BTUVfPT01Lilcbnt2ZXJ0ZXhPdXRwdXRzLnZfVkFSWUlOR05BTUVfVVY9ICh1bmlmb3Jtcy5fTUFUUklYTkFNRV9NYXRyaXgqIHZlYzRmKHZlcnRleElucHV0cy51djYsMS4wLDAuMCkpLnh5O31cbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHNhbXBsZXJWZXJ0ZXhJbXBsZW1lbnRhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlclZlcnRleEltcGxlbWVudGF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwic2NlbmVVYm9EZWNsYXJhdGlvblwiO1xuY29uc3Qgc2hhZGVyID0gYHN0cnVjdCBTY2VuZSB7dmlld1Byb2plY3Rpb24gOiBtYXQ0eDQ8ZjMyPixcbiNpZmRlZiBNVUxUSVZJRVdcbnZpZXdQcm9qZWN0aW9uUiA6IG1hdDR4NDxmMzI+LFxuI2VuZGlmIFxudmlldyA6IG1hdDR4NDxmMzI+LFxucHJvamVjdGlvbiA6IG1hdDR4NDxmMzI+LFxudkV5ZVBvc2l0aW9uIDogdmVjNDxmMzI+LH07dmFyPHVuaWZvcm0+IHNjZW5lIDogU2NlbmU7XG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHNjZW5lVWJvRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjZW5lVWJvRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJzaGFkb3dzVmVydGV4XCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIFNIQURPV1NcbiNpZiBkZWZpbmVkKFNIQURPV0NTTXtYfSlcbnZlcnRleE91dHB1dHMudlBvc2l0aW9uRnJvbUNhbWVyYXtYfT1zY2VuZS52aWV3KndvcmxkUG9zO1xuI2lmIFNIQURPV0NTTU5VTV9DQVNDQURFU3tYfT4wXG52ZXJ0ZXhPdXRwdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfV8wPXVuaWZvcm1zLmxpZ2h0TWF0cml4e1h9WzBdKndvcmxkUG9zO1xuI2lmZGVmIFVTRV9SRVZFUlNFX0RFUFRIQlVGRkVSXG52ZXJ0ZXhPdXRwdXRzLnZEZXB0aE1ldHJpY3tYfV8wPSgtdmVydGV4T3V0cHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH1fMC56K2xpZ2h0e1h9LmRlcHRoVmFsdWVzLngpL2xpZ2h0e1h9LmRlcHRoVmFsdWVzLnk7XG4jZWxzZVxudmVydGV4T3V0cHV0cy52RGVwdGhNZXRyaWN7WH1fMD0gKHZlcnRleE91dHB1dHMudlBvc2l0aW9uRnJvbUxpZ2h0e1h9XzAueitsaWdodHtYfS5kZXB0aFZhbHVlcy54KS9saWdodHtYfS5kZXB0aFZhbHVlcy55O1xuI2VuZGlmXG4jZW5kaWZcbiNpZiBTSEFET1dDU01OVU1fQ0FTQ0FERVN7WH0+MVxudmVydGV4T3V0cHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH1fMT11bmlmb3Jtcy5saWdodE1hdHJpeHtYfVsxXSp3b3JsZFBvcztcbiNpZmRlZiBVU0VfUkVWRVJTRV9ERVBUSEJVRkZFUlxudmVydGV4T3V0cHV0cy52RGVwdGhNZXRyaWN7WH1fMT0oLXZlcnRleE91dHB1dHMudlBvc2l0aW9uRnJvbUxpZ2h0e1h9XzEueitsaWdodHtYfS5kZXB0aFZhbHVlcy54KS9saWdodHtYfS5kZXB0aFZhbHVlcy55O1xuI2Vsc2VcbnZlcnRleE91dHB1dHMudkRlcHRoTWV0cmlje1h9XzE9ICh2ZXJ0ZXhPdXRwdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfV8xLnorbGlnaHR7WH0uZGVwdGhWYWx1ZXMueCkvbGlnaHR7WH0uZGVwdGhWYWx1ZXMueTtcbiNlbmRpZlxuI2VuZGlmIFxuI2lmIFNIQURPV0NTTU5VTV9DQVNDQURFU3tYfT4yXG52ZXJ0ZXhPdXRwdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfV8yPXVuaWZvcm1zLmxpZ2h0TWF0cml4e1h9WzJdKndvcmxkUG9zO1xuI2lmZGVmIFVTRV9SRVZFUlNFX0RFUFRIQlVGRkVSXG52ZXJ0ZXhPdXRwdXRzLnZEZXB0aE1ldHJpY3tYfV8yPSgtdmVydGV4T3V0cHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH1fMi56K2xpZ2h0e1h9LmRlcHRoVmFsdWVzLngpL2xpZ2h0e1h9LmRlcHRoVmFsdWVzLnk7XG4jZWxzZVxudmVydGV4T3V0cHV0cy52RGVwdGhNZXRyaWN7WH1fMj0gKHZlcnRleE91dHB1dHMudlBvc2l0aW9uRnJvbUxpZ2h0e1h9XzIueitsaWdodHtYfS5kZXB0aFZhbHVlcy54KS9saWdodHtYfS5kZXB0aFZhbHVlcy55O1xuI2VuZGlmXG4jZW5kaWYgXG4jaWYgU0hBRE9XQ1NNTlVNX0NBU0NBREVTe1h9PjNcbnZlcnRleE91dHB1dHMudlBvc2l0aW9uRnJvbUxpZ2h0e1h9XzM9dW5pZm9ybXMubGlnaHRNYXRyaXh7WH1bM10qd29ybGRQb3M7XG4jaWZkZWYgVVNFX1JFVkVSU0VfREVQVEhCVUZGRVJcbnZlcnRleE91dHB1dHMudkRlcHRoTWV0cmlje1h9XzM9KC12ZXJ0ZXhPdXRwdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfV8zLnorbGlnaHR7WH0uZGVwdGhWYWx1ZXMueCkvbGlnaHR7WH0uZGVwdGhWYWx1ZXMueTtcbiNlbHNlXG52ZXJ0ZXhPdXRwdXRzLnZEZXB0aE1ldHJpY3tYfV8zPSAodmVydGV4T3V0cHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH1fMy56K2xpZ2h0e1h9LmRlcHRoVmFsdWVzLngpL2xpZ2h0e1h9LmRlcHRoVmFsdWVzLnk7XG4jZW5kaWZcbiNlbmRpZiBcbiNlbGlmIGRlZmluZWQoU0hBRE9Xe1h9KSAmJiAhZGVmaW5lZChTSEFET1dDVUJFe1h9KVxudmVydGV4T3V0cHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH09dW5pZm9ybXMubGlnaHRNYXRyaXh7WH0qd29ybGRQb3M7XG4jaWZkZWYgVVNFX1JFVkVSU0VfREVQVEhCVUZGRVJcbnZlcnRleE91dHB1dHMudkRlcHRoTWV0cmlje1h9PSgtdmVydGV4T3V0cHV0cy52UG9zaXRpb25Gcm9tTGlnaHR7WH0ueitsaWdodHtYfS5kZXB0aFZhbHVlcy54KS9saWdodHtYfS5kZXB0aFZhbHVlcy55O1xuI2Vsc2VcbnZlcnRleE91dHB1dHMudkRlcHRoTWV0cmlje1h9PSh2ZXJ0ZXhPdXRwdXRzLnZQb3NpdGlvbkZyb21MaWdodHtYfS56K2xpZ2h0e1h9LmRlcHRoVmFsdWVzLngpL2xpZ2h0e1h9LmRlcHRoVmFsdWVzLnk7XG4jZW5kaWZcbiNlbmRpZlxuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHNoYWRvd3NWZXJ0ZXhXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRvd3NWZXJ0ZXguanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJ1dkF0dHJpYnV0ZURlY2xhcmF0aW9uXCI7XG5jb25zdCBzaGFkZXIgPSBgI2lmZGVmIFVWe1h9XG5hdHRyaWJ1dGUgdXZ7WH06IHZlYzJmO1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHV2QXR0cmlidXRlRGVjbGFyYXRpb25XR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV2QXR0cmlidXRlRGVjbGFyYXRpb24uanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJ1dlZhcmlhYmxlRGVjbGFyYXRpb25cIjtcbmNvbnN0IHNoYWRlciA9IGAjaWZkZWYgTUFJTlVWe1h9XG4jaWYgIWRlZmluZWQoVVZ7WH0pXG52YXIgdXZ7WH06IHZlYzJmPXZlYzJmKDAuLDAuKTtcbiNlbHNlXG52YXIgdXZ7WH06IHZlYzJmPXZlcnRleElucHV0cy51dntYfTtcbiNlbmRpZlxudmVydGV4T3V0cHV0cy52TWFpblVWe1h9PXV2e1h9O1xuI2VuZGlmXG5gO1xuLy8gU2lkZWVmZmVjdFxuU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHV2VmFyaWFibGVEZWNsYXJhdGlvbldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXZWYXJpYWJsZURlY2xhcmF0aW9uLmpzLm1hcCIsIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwidmVydGV4Q29sb3JNaXhpbmdcIjtcbmNvbnN0IHNoYWRlciA9IGAjaWYgZGVmaW5lZChWRVJURVhDT0xPUikgfHwgZGVmaW5lZChJTlNUQU5DRVNDT0xPUikgJiYgZGVmaW5lZChJTlNUQU5DRVMpXG52ZXJ0ZXhPdXRwdXRzLnZDb2xvcj12ZWM0ZigxLjApO1xuI2lmZGVmIFZFUlRFWENPTE9SXG4jaWZkZWYgVkVSVEVYQUxQSEFcbnZlcnRleE91dHB1dHMudkNvbG9yKj12ZXJ0ZXhJbnB1dHMuY29sb3I7XG4jZWxzZVxudmVydGV4T3V0cHV0cy52Q29sb3I9dmVjNGYodmVydGV4T3V0cHV0cy52Q29sb3IucmdiKnZlcnRleElucHV0cy5jb2xvci5yZ2IsdmVydGV4T3V0cHV0cy52Q29sb3IuYSk7XG4jZW5kaWZcbiNlbmRpZlxuI2lmZGVmIElOU1RBTkNFU0NPTE9SXG52ZXJ0ZXhPdXRwdXRzLnZDb2xvcio9dmVydGV4SW5wdXRzLmluc3RhbmNlQ29sb3I7XG4jZW5kaWZcbiNlbmRpZlxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCB2ZXJ0ZXhDb2xvck1peGluZ1dHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVydGV4Q29sb3JNaXhpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9