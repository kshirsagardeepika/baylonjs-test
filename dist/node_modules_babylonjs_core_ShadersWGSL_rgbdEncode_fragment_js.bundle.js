"use strict";
(self["webpackChunksample1"] = self["webpackChunksample1"] || []).push([["node_modules_babylonjs_core_ShadersWGSL_rgbdEncode_fragment_js"],{

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   helperFunctionsWGSL: () => (/* binding */ helperFunctionsWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "helperFunctions";
const shader = `const PI: f32=3.1415926535897932384626433832795;const RECIPROCAL_PI: f32=0.3183098861837907;const RECIPROCAL_PI2: f32=0.15915494309189535;const HALF_MIN: f32=5.96046448e-08; 
const LinearEncodePowerApprox: f32=2.2;const GammaEncodePowerApprox: f32=1.0/LinearEncodePowerApprox;const LuminanceEncodeApprox: vec3<f32>=vec3<f32> (0.2126,0.7152,0.0722);const Epsilon:f32=0.0000001;fn square(x: f32)->f32 {return x*x;}
fn saturate(x: f32)->f32 {return clamp(x,0.0,1.0);}
fn saturateVec3(x: vec3f)->vec3f {return clamp(x,vec3f(0.0),vec3f(1.0));}
fn saturateEps(x: f32)->f32 {return clamp(x,Epsilon,1.0);} 
fn maxEps(x: f32)->f32 {return max(x,Epsilon);}
fn maxEpsVec3(x: vec3f)->vec3f {return max(x,vec3f(Epsilon));}
fn absEps(x: f32)->f32 {return abs(x)+Epsilon;}
fn transposeMat3(inMatrix: mat3x3f)->mat3x3f {let i0: vec3<f32>=inMatrix[0];let i1: vec3<f32>=inMatrix[1];let i2: vec3<f32>=inMatrix[2];let outMatrix:mat3x3f=mat3x3f(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
fn inverseMat3(inMatrix: mat3x3f)->mat3x3f {let a00: f32=inMatrix[0][0];let a01: f32=inMatrix[0][1];let a02: f32=inMatrix[0][2];let a10: f32=inMatrix[1][0];let a11: f32=inMatrix[1][1];let a12: f32=inMatrix[1][2];let a20: f32=inMatrix[2][0];let a21: f32=inMatrix[2][1];let a22: f32=inMatrix[2][2];let b01: f32=a22*a11-a12*a21;let b11: f32=-a22*a10+a12*a20;let b21: f32=a21*a10-a11*a20;let det: f32=a00*b01+a01*b11+a02*b21;return mat3x3f(b01/det,(-a22*a01+a02*a21)/det,(a12*a01-a02*a11)/det,
b11/det,(a22*a00-a02*a20)/det,(-a12*a00+a02*a10)/det,
b21/det,(-a21*a00+a01*a20)/det,(a11*a00-a01*a10)/det);}
#if USE_EXACT_SRGB_CONVERSIONS
fn toLinearSpaceExact(color: vec3<f32>)->vec3<f32>
{let nearZeroSection: vec3<f32>=0.0773993808*color;let remainingSection: vec3<f32>=pow(0.947867299*(color+vec3<f32>(0.055)),vec3<f32>(2.4));return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3<f32>(0.04045)));}
fn toGammaSpaceExact(color: vec3<f32>)->vec3<f32>
{let nearZeroSection: vec3<f32>=12.92*color;let remainingSection: vec3<f32>=1.055*pow(color,vec3<f32>(0.41666))-vec3<f32>(0.055);return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3<f32>(0.0031308)));}
#endif
fn toLinearSpace(color: f32)->f32
{
#if USE_EXACT_SRGB_CONVERSIONS
var nearZeroSection=0.0773993808*color;var remainingSection=pow(0.947867299*(color+0.055),2.4);return select(remainingSection,nearZeroSection,color<=0.04045);
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
fn toLinearSpaceVec3(color: vec3<f32>)->vec3<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3<f32>(LinearEncodePowerApprox));
#endif
}
fn toLinearSpaceVec4(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4f(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4f(pow(color.rgb,vec3f(LinearEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpace(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4<f32>(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4<f32>(pow(color.rgb,vec3<f32>(GammaEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpaceVec3(color: vec3<f32>)->vec3<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3<f32>(GammaEncodePowerApprox));
#endif
}
fn squareVec3(value: vec3<f32>)->vec3<f32>
{return value*value;}
fn pow5(value: f32)->f32 {let sq: f32=value*value;return sq*sq*value;}
fn getLuminance(color: vec3<f32>)->f32
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
fn getRand(seed: vec2<f32>)->f32 {return fract(sin(dot(seed.xy ,vec2<f32>(12.9898,78.233)))*43758.5453);}
fn dither(seed: vec2<f32>,varianceAmount: f32)->f32 {let rand: f32=getRand(seed);let normVariance: f32=varianceAmount/255.0;let dither: f32=mix(-normVariance,normVariance,rand);return dither;}
const rgbdMaxRange: f32=255.0;fn toRGBD(color: vec3<f32>)->vec4<f32> {let maxRGB: f32=max(max(color.r,max(color.g,color.b)),Epsilon);var D: f32 =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);var rgb: vec3<f32> =color.rgb*D;rgb=toGammaSpaceVec3(rgb);return vec4<f32>(clamp(rgb,vec3<f32>(0.,0.,0.),vec3<f32>(1.,1.,1.)),D); }
fn fromRGBD(rgbd: vec4<f32>)->vec3<f32> {let rgb=toLinearSpaceVec3(rgbd.rgb);return rgb/rgbd.a;}
fn parallaxCorrectNormal(vertexPos: vec3<f32>,origVec: vec3<f32>,cubeSize: vec3<f32>,cubePos: vec3<f32>)->vec3<f32> {let invOrigVec: vec3<f32>=vec3<f32>(1.0,1.0,1.0)/origVec;let halfSize: vec3<f32>=cubeSize*0.5;let intersecAtMaxPlane: vec3<f32>=(cubePos+halfSize-vertexPos)*invOrigVec;let intersecAtMinPlane: vec3<f32>=(cubePos-halfSize-vertexPos)*invOrigVec;let largestIntersec: vec3<f32>=max(intersecAtMaxPlane,intersecAtMinPlane);let distance: f32=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);let intersectPositionWS: vec3<f32>=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
/** @internal */
const helperFunctionsWGSL = { name, shader };
//# sourceMappingURL=helperFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/rgbdEncode.fragment.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/rgbdEncode.fragment.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rgbdEncodePixelShaderWGSL: () => (/* binding */ rgbdEncodePixelShaderWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
/* harmony import */ var _ShadersInclude_helperFunctions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShadersInclude/helperFunctions.js */ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js");
// Do not edit.


const name = "rgbdEncodePixelShader";
const shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=toRGBD(textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb);}`;
// Sideeffect
_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStoreWGSL[name] = shader;
/** @internal */
const rgbdEncodePixelShaderWGSL = { name, shader };
//# sourceMappingURL=rgbdEncode.fragment.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2JhYnlsb25qc19jb3JlX1NoYWRlcnNXR1NMX3JnYmRFbmNvZGVfZnJhZ21lbnRfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMkQ7QUFDM0Q7QUFDQSxnRUFBZ0UsNENBQTRDLDhDQUE4QztBQUMxSix1Q0FBdUMsOERBQThELHdFQUF3RSw0QkFBNEIsd0JBQXdCO0FBQ2pPLDBCQUEwQjtBQUMxQixrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLDhDQUE4Qyw4QkFBOEIsOEJBQThCLDhCQUE4QjtBQUN4STtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsNENBQTRDLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDZCQUE2Qiw4QkFBOEIsNkJBQTZCLHFDQUFxQztBQUNyYTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHlGQUF5RjtBQUM1STtBQUNBLENBQUMsMkNBQTJDLHFGQUFxRjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3REFBd0Q7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBLENBQUM7QUFDRCxrQ0FBa0M7QUFDbEMscURBQXFELDRCQUE0QiwyQ0FBMkMscURBQXFEO0FBQ2pMLDhCQUE4Qix3Q0FBd0MsK0RBQStELHdDQUF3QywrQkFBK0IsZ0NBQWdDLDBCQUEwQjtBQUN0USx5Q0FBeUMsb0NBQW9DO0FBQzdFLHFIQUFxSCx5REFBeUQscUNBQXFDLDBFQUEwRSwwRUFBMEUsMEVBQTBFLGtGQUFrRiw4REFBOEQ7QUFDamtCO0FBQ0E7QUFDQSxnRUFBVztBQUNYO0FBQ08sOEJBQThCO0FBQ3JDOzs7Ozs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ3dEO0FBQ1g7QUFDN0M7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpR0FBaUc7QUFDbEo7QUFDQSxnRUFBVztBQUNYO0FBQ08sb0NBQW9DO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FtcGxlMS8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvU2hhZGVyc0luY2x1ZGUvaGVscGVyRnVuY3Rpb25zLmpzIiwid2VicGFjazovL3NhbXBsZTEvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML3JnYmRFbmNvZGUuZnJhZ21lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJoZWxwZXJGdW5jdGlvbnNcIjtcbmNvbnN0IHNoYWRlciA9IGBjb25zdCBQSTogZjMyPTMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTtjb25zdCBSRUNJUFJPQ0FMX1BJOiBmMzI9MC4zMTgzMDk4ODYxODM3OTA3O2NvbnN0IFJFQ0lQUk9DQUxfUEkyOiBmMzI9MC4xNTkxNTQ5NDMwOTE4OTUzNTtjb25zdCBIQUxGX01JTjogZjMyPTUuOTYwNDY0NDhlLTA4OyBcbmNvbnN0IExpbmVhckVuY29kZVBvd2VyQXBwcm94OiBmMzI9Mi4yO2NvbnN0IEdhbW1hRW5jb2RlUG93ZXJBcHByb3g6IGYzMj0xLjAvTGluZWFyRW5jb2RlUG93ZXJBcHByb3g7Y29uc3QgTHVtaW5hbmNlRW5jb2RlQXBwcm94OiB2ZWMzPGYzMj49dmVjMzxmMzI+ICgwLjIxMjYsMC43MTUyLDAuMDcyMik7Y29uc3QgRXBzaWxvbjpmMzI9MC4wMDAwMDAxO2ZuIHNxdWFyZSh4OiBmMzIpLT5mMzIge3JldHVybiB4Kng7fVxuZm4gc2F0dXJhdGUoeDogZjMyKS0+ZjMyIHtyZXR1cm4gY2xhbXAoeCwwLjAsMS4wKTt9XG5mbiBzYXR1cmF0ZVZlYzMoeDogdmVjM2YpLT52ZWMzZiB7cmV0dXJuIGNsYW1wKHgsdmVjM2YoMC4wKSx2ZWMzZigxLjApKTt9XG5mbiBzYXR1cmF0ZUVwcyh4OiBmMzIpLT5mMzIge3JldHVybiBjbGFtcCh4LEVwc2lsb24sMS4wKTt9IFxuZm4gbWF4RXBzKHg6IGYzMiktPmYzMiB7cmV0dXJuIG1heCh4LEVwc2lsb24pO31cbmZuIG1heEVwc1ZlYzMoeDogdmVjM2YpLT52ZWMzZiB7cmV0dXJuIG1heCh4LHZlYzNmKEVwc2lsb24pKTt9XG5mbiBhYnNFcHMoeDogZjMyKS0+ZjMyIHtyZXR1cm4gYWJzKHgpK0Vwc2lsb247fVxuZm4gdHJhbnNwb3NlTWF0Myhpbk1hdHJpeDogbWF0M3gzZiktPm1hdDN4M2Yge2xldCBpMDogdmVjMzxmMzI+PWluTWF0cml4WzBdO2xldCBpMTogdmVjMzxmMzI+PWluTWF0cml4WzFdO2xldCBpMjogdmVjMzxmMzI+PWluTWF0cml4WzJdO2xldCBvdXRNYXRyaXg6bWF0M3gzZj1tYXQzeDNmKFxudmVjMyhpMC54LGkxLngsaTIueCksXG52ZWMzKGkwLnksaTEueSxpMi55KSxcbnZlYzMoaTAueixpMS56LGkyLnopXG4pO3JldHVybiBvdXRNYXRyaXg7fVxuZm4gaW52ZXJzZU1hdDMoaW5NYXRyaXg6IG1hdDN4M2YpLT5tYXQzeDNmIHtsZXQgYTAwOiBmMzI9aW5NYXRyaXhbMF1bMF07bGV0IGEwMTogZjMyPWluTWF0cml4WzBdWzFdO2xldCBhMDI6IGYzMj1pbk1hdHJpeFswXVsyXTtsZXQgYTEwOiBmMzI9aW5NYXRyaXhbMV1bMF07bGV0IGExMTogZjMyPWluTWF0cml4WzFdWzFdO2xldCBhMTI6IGYzMj1pbk1hdHJpeFsxXVsyXTtsZXQgYTIwOiBmMzI9aW5NYXRyaXhbMl1bMF07bGV0IGEyMTogZjMyPWluTWF0cml4WzJdWzFdO2xldCBhMjI6IGYzMj1pbk1hdHJpeFsyXVsyXTtsZXQgYjAxOiBmMzI9YTIyKmExMS1hMTIqYTIxO2xldCBiMTE6IGYzMj0tYTIyKmExMCthMTIqYTIwO2xldCBiMjE6IGYzMj1hMjEqYTEwLWExMSphMjA7bGV0IGRldDogZjMyPWEwMCpiMDErYTAxKmIxMSthMDIqYjIxO3JldHVybiBtYXQzeDNmKGIwMS9kZXQsKC1hMjIqYTAxK2EwMiphMjEpL2RldCwoYTEyKmEwMS1hMDIqYTExKS9kZXQsXG5iMTEvZGV0LChhMjIqYTAwLWEwMiphMjApL2RldCwoLWExMiphMDArYTAyKmExMCkvZGV0LFxuYjIxL2RldCwoLWEyMSphMDArYTAxKmEyMCkvZGV0LChhMTEqYTAwLWEwMSphMTApL2RldCk7fVxuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5mbiB0b0xpbmVhclNwYWNlRXhhY3QoY29sb3I6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue2xldCBuZWFyWmVyb1NlY3Rpb246IHZlYzM8ZjMyPj0wLjA3NzM5OTM4MDgqY29sb3I7bGV0IHJlbWFpbmluZ1NlY3Rpb246IHZlYzM8ZjMyPj1wb3coMC45NDc4NjcyOTkqKGNvbG9yK3ZlYzM8ZjMyPigwLjA1NSkpLHZlYzM8ZjMyPigyLjQpKTtyZXR1cm4gbWl4KHJlbWFpbmluZ1NlY3Rpb24sbmVhclplcm9TZWN0aW9uLGxlc3NUaGFuRXF1YWwoY29sb3IsdmVjMzxmMzI+KDAuMDQwNDUpKSk7fVxuZm4gdG9HYW1tYVNwYWNlRXhhY3QoY29sb3I6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue2xldCBuZWFyWmVyb1NlY3Rpb246IHZlYzM8ZjMyPj0xMi45Mipjb2xvcjtsZXQgcmVtYWluaW5nU2VjdGlvbjogdmVjMzxmMzI+PTEuMDU1KnBvdyhjb2xvcix2ZWMzPGYzMj4oMC40MTY2NikpLXZlYzM8ZjMyPigwLjA1NSk7cmV0dXJuIG1peChyZW1haW5pbmdTZWN0aW9uLG5lYXJaZXJvU2VjdGlvbixsZXNzVGhhbkVxdWFsKGNvbG9yLHZlYzM8ZjMyPigwLjAwMzEzMDgpKSk7fVxuI2VuZGlmXG5mbiB0b0xpbmVhclNwYWNlKGNvbG9yOiBmMzIpLT5mMzJcbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xudmFyIG5lYXJaZXJvU2VjdGlvbj0wLjA3NzM5OTM4MDgqY29sb3I7dmFyIHJlbWFpbmluZ1NlY3Rpb249cG93KDAuOTQ3ODY3Mjk5Kihjb2xvciswLjA1NSksMi40KTtyZXR1cm4gc2VsZWN0KHJlbWFpbmluZ1NlY3Rpb24sbmVhclplcm9TZWN0aW9uLGNvbG9yPD0wLjA0MDQ1KTtcbiNlbHNlXG5yZXR1cm4gcG93KGNvbG9yLExpbmVhckVuY29kZVBvd2VyQXBwcm94KTtcbiNlbmRpZlxufVxuZm4gdG9MaW5lYXJTcGFjZVZlYzMoY29sb3I6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdG9MaW5lYXJTcGFjZUV4YWN0KGNvbG9yKTtcbiNlbHNlXG5yZXR1cm4gcG93KGNvbG9yLHZlYzM8ZjMyPihMaW5lYXJFbmNvZGVQb3dlckFwcHJveCkpO1xuI2VuZGlmXG59XG5mbiB0b0xpbmVhclNwYWNlVmVjNChjb2xvcjogdmVjNDxmMzI+KS0+dmVjNDxmMzI+XG57XG4jaWYgVVNFX0VYQUNUX1NSR0JfQ09OVkVSU0lPTlNcbnJldHVybiB2ZWM0Zih0b0xpbmVhclNwYWNlRXhhY3QoY29sb3IucmdiKSxjb2xvci5hKTtcbiNlbHNlXG5yZXR1cm4gdmVjNGYocG93KGNvbG9yLnJnYix2ZWMzZihMaW5lYXJFbmNvZGVQb3dlckFwcHJveCkpLGNvbG9yLmEpO1xuI2VuZGlmXG59XG5mbiB0b0dhbW1hU3BhY2UoY29sb3I6IHZlYzQ8ZjMyPiktPnZlYzQ8ZjMyPlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdmVjNDxmMzI+KHRvR2FtbWFTcGFjZUV4YWN0KGNvbG9yLnJnYiksY29sb3IuYSk7XG4jZWxzZVxucmV0dXJuIHZlYzQ8ZjMyPihwb3coY29sb3IucmdiLHZlYzM8ZjMyPihHYW1tYUVuY29kZVBvd2VyQXBwcm94KSksY29sb3IuYSk7XG4jZW5kaWZcbn1cbmZuIHRvR2FtbWFTcGFjZVZlYzMoY29sb3I6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdG9HYW1tYVNwYWNlRXhhY3QoY29sb3IpO1xuI2Vsc2VcbnJldHVybiBwb3coY29sb3IsdmVjMzxmMzI+KEdhbW1hRW5jb2RlUG93ZXJBcHByb3gpKTtcbiNlbmRpZlxufVxuZm4gc3F1YXJlVmVjMyh2YWx1ZTogdmVjMzxmMzI+KS0+dmVjMzxmMzI+XG57cmV0dXJuIHZhbHVlKnZhbHVlO31cbmZuIHBvdzUodmFsdWU6IGYzMiktPmYzMiB7bGV0IHNxOiBmMzI9dmFsdWUqdmFsdWU7cmV0dXJuIHNxKnNxKnZhbHVlO31cbmZuIGdldEx1bWluYW5jZShjb2xvcjogdmVjMzxmMzI+KS0+ZjMyXG57cmV0dXJuIGNsYW1wKGRvdChjb2xvcixMdW1pbmFuY2VFbmNvZGVBcHByb3gpLDAuLDEuKTt9XG5mbiBnZXRSYW5kKHNlZWQ6IHZlYzI8ZjMyPiktPmYzMiB7cmV0dXJuIGZyYWN0KHNpbihkb3Qoc2VlZC54eSAsdmVjMjxmMzI+KDEyLjk4OTgsNzguMjMzKSkpKjQzNzU4LjU0NTMpO31cbmZuIGRpdGhlcihzZWVkOiB2ZWMyPGYzMj4sdmFyaWFuY2VBbW91bnQ6IGYzMiktPmYzMiB7bGV0IHJhbmQ6IGYzMj1nZXRSYW5kKHNlZWQpO2xldCBub3JtVmFyaWFuY2U6IGYzMj12YXJpYW5jZUFtb3VudC8yNTUuMDtsZXQgZGl0aGVyOiBmMzI9bWl4KC1ub3JtVmFyaWFuY2Usbm9ybVZhcmlhbmNlLHJhbmQpO3JldHVybiBkaXRoZXI7fVxuY29uc3QgcmdiZE1heFJhbmdlOiBmMzI9MjU1LjA7Zm4gdG9SR0JEKGNvbG9yOiB2ZWMzPGYzMj4pLT52ZWM0PGYzMj4ge2xldCBtYXhSR0I6IGYzMj1tYXgobWF4KGNvbG9yLnIsbWF4KGNvbG9yLmcsY29sb3IuYikpLEVwc2lsb24pO3ZhciBEOiBmMzIgPW1heChyZ2JkTWF4UmFuZ2UvbWF4UkdCLDEuKTtEID1jbGFtcChmbG9vcihEKS8yNTUuMCwwLiwxLik7dmFyIHJnYjogdmVjMzxmMzI+ID1jb2xvci5yZ2IqRDtyZ2I9dG9HYW1tYVNwYWNlVmVjMyhyZ2IpO3JldHVybiB2ZWM0PGYzMj4oY2xhbXAocmdiLHZlYzM8ZjMyPigwLiwwLiwwLiksdmVjMzxmMzI+KDEuLDEuLDEuKSksRCk7IH1cbmZuIGZyb21SR0JEKHJnYmQ6IHZlYzQ8ZjMyPiktPnZlYzM8ZjMyPiB7bGV0IHJnYj10b0xpbmVhclNwYWNlVmVjMyhyZ2JkLnJnYik7cmV0dXJuIHJnYi9yZ2JkLmE7fVxuZm4gcGFyYWxsYXhDb3JyZWN0Tm9ybWFsKHZlcnRleFBvczogdmVjMzxmMzI+LG9yaWdWZWM6IHZlYzM8ZjMyPixjdWJlU2l6ZTogdmVjMzxmMzI+LGN1YmVQb3M6IHZlYzM8ZjMyPiktPnZlYzM8ZjMyPiB7bGV0IGludk9yaWdWZWM6IHZlYzM8ZjMyPj12ZWMzPGYzMj4oMS4wLDEuMCwxLjApL29yaWdWZWM7bGV0IGhhbGZTaXplOiB2ZWMzPGYzMj49Y3ViZVNpemUqMC41O2xldCBpbnRlcnNlY0F0TWF4UGxhbmU6IHZlYzM8ZjMyPj0oY3ViZVBvcytoYWxmU2l6ZS12ZXJ0ZXhQb3MpKmludk9yaWdWZWM7bGV0IGludGVyc2VjQXRNaW5QbGFuZTogdmVjMzxmMzI+PShjdWJlUG9zLWhhbGZTaXplLXZlcnRleFBvcykqaW52T3JpZ1ZlYztsZXQgbGFyZ2VzdEludGVyc2VjOiB2ZWMzPGYzMj49bWF4KGludGVyc2VjQXRNYXhQbGFuZSxpbnRlcnNlY0F0TWluUGxhbmUpO2xldCBkaXN0YW5jZTogZjMyPW1pbihtaW4obGFyZ2VzdEludGVyc2VjLngsbGFyZ2VzdEludGVyc2VjLnkpLGxhcmdlc3RJbnRlcnNlYy56KTtsZXQgaW50ZXJzZWN0UG9zaXRpb25XUzogdmVjMzxmMzI+PXZlcnRleFBvcytvcmlnVmVjKmRpc3RhbmNlO3JldHVybiBpbnRlcnNlY3RQb3NpdGlvbldTLWN1YmVQb3M7fVxuYDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSA9IHNoYWRlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBoZWxwZXJGdW5jdGlvbnNXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlckZ1bmN0aW9ucy5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmltcG9ydCBcIi4vU2hhZGVyc0luY2x1ZGUvaGVscGVyRnVuY3Rpb25zLmpzXCI7XG5jb25zdCBuYW1lID0gXCJyZ2JkRW5jb2RlUGl4ZWxTaGFkZXJcIjtcbmNvbnN0IHNoYWRlciA9IGB2YXJ5aW5nIHZVVjogdmVjMmY7dmFyIHRleHR1cmVTYW1wbGVyU2FtcGxlcjogc2FtcGxlcjt2YXIgdGV4dHVyZVNhbXBsZXI6IHRleHR1cmVfMmQ8ZjMyPjtcbiNpbmNsdWRlPGhlbHBlckZ1bmN0aW9ucz5cbiNkZWZpbmUgQ1VTVE9NX0ZSQUdNRU5UX0RFRklOSVRJT05TXG5AZnJhZ21lbnRcbmZuIG1haW4oaW5wdXQ6IEZyYWdtZW50SW5wdXRzKS0+RnJhZ21lbnRPdXRwdXRzIHtmcmFnbWVudE91dHB1dHMuY29sb3I9dG9SR0JEKHRleHR1cmVTYW1wbGUodGV4dHVyZVNhbXBsZXIsdGV4dHVyZVNhbXBsZXJTYW1wbGVyLGlucHV0LnZVVikucmdiKTt9YDtcbi8vIFNpZGVlZmZlY3RcblNoYWRlclN0b3JlLlNoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcmdiZEVuY29kZVBpeGVsU2hhZGVyV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZ2JkRW5jb2RlLmZyYWdtZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==